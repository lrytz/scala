incOptions := incOptions.value
  .withRecompileAllFraction(1.0)

Compile / classDirectory := baseDirectory.value / "target/classes"
Compile / classDirectory := baseDirectory.value / "target/classes"

InputKey[Unit]("checkRecompilations") := {
  val stepArg :: expected = complete.DefaultParsers.spaceDelimited("<arg>").parsed
  val step = stepArg.toInt
  val a = (Compile / compile).value.asInstanceOf[sbt.internal.inc.Analysis]
  val allCompilations = a.compilations.allCompilations
  val recompiledClasses: Seq[Set[String]] = allCompilations map { c =>
    val recompiledClasses = a.apis.internal.collect {
      case (className, api) if api.compilationTimestamp() == c.getStartTime => className
    }
    recompiledClasses.toSet
  }

  def recompiledClassesInIteration(iteration: Int, classNames: Set[String]) = {
    assert(
      recompiledClasses(iteration) == classNames,
      s"""${recompiledClasses(iteration)} != $classNames
         |allCompilations = ${allCompilations.mkString("\n  ")}""".stripMargin
    )
  }

  assert(step < allCompilations.size)
  recompiledClassesInIteration(step, expected.toSet)
}

InputKey[Unit]("checkDependencies") := {
  val cls :: expected = complete.DefaultParsers.spaceDelimited("<arg>").parsed
  val className = cls.stripSuffix(":")
  val a = (Compile / compile).value.asInstanceOf[sbt.internal.inc.Analysis]
  def classDeps(cls: String): Set[String] = a.relations.internalClassDep.forward(cls)
  def assertDependencies(expected: Set[String], actual: Set[String]) =
    assert(expected == actual, s"Expected $expected dependencies, got $actual")
  assertDependencies(expected.toSet, classDeps(className))
}

InputKey[Unit]("checkProducts") := {
  val source :: expected = complete.DefaultParsers.spaceDelimited("<arg>").parsed
  val a = (Compile / compile).value.asInstanceOf[sbt.internal.inc.Analysis]
  val c = fileConverter.value
  val products = a.relations.products(c.toVirtualFile(baseDirectory.value.toPath / source.stripSuffix(":")))
  assert(expected.toSet == products.map(_.id), s"expected: ${expected.sorted.mkString("\n  ", "\n  ", "")}\nobtained: ${products.map(_.id).toList.sorted.mkString("\n  ", "\n  ", "")}")
}

InputKey[Unit]("checkProductsExists") := {
  val List(source) = complete.DefaultParsers.spaceDelimited("<arg>").parsed
  val a = (Compile / compile).value.asInstanceOf[sbt.internal.inc.Analysis]
  val c = fileConverter.value
  val missing = a.relations.products(c.toVirtualFile(baseDirectory.value.toPath / source)).filter(p =>
    !java.nio.file.Files.exists(c.toPath(p)))
  assert(missing.isEmpty, s"missing files: ${missing.map(_.id).toList.sorted.mkString("\n  ", "\n  ", "")}")
}
