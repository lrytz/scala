From bc16f7a4e5cac5438e399e8bef0f9ccb02e23544 Mon Sep 17 00:00:00 2001
From: Lukas Rytz <lukas.rytz@gmail.com>
Date: Tue, 29 Aug 2023 11:22:28 +0200
Subject: [PATCH] remaining 2.13.12 PRs

---
 .travis.yml                                   |   3 +-
 build.sbt                                     | 116 ++-
 project/DottySupport.scala                    |   2 +-
 project/MimaFilters.scala                     |  13 +
 .../reflect/quasiquotes/Placeholders.scala    |  13 +-
 .../reflect/reify/phases/Calculate.scala      |   4 +-
 .../reflect/reify/utils/NodePrinters.scala    |   3 +-
 .../reflect/reify/utils/SymbolTables.scala    |  10 +-
 src/compiler/scala/tools/nsc/Global.scala     |  10 +-
 .../scala/tools/nsc/PipelineMain.scala        |   4 +-
 src/compiler/scala/tools/nsc/Reporting.scala  | 193 +++-
 .../scala/tools/nsc/ast/Printers.scala        |   2 +-
 src/compiler/scala/tools/nsc/ast/Trees.scala  |  19 +-
 .../scala/tools/nsc/ast/parser/Parsers.scala  | 103 ++-
 .../scala/tools/nsc/ast/parser/Scanners.scala |  18 +-
 .../tools/nsc/backend/jvm/PerRunInit.scala    |   2 +-
 .../jvm/analysis/AliasingAnalyzer.scala       |   5 +-
 .../tools/nsc/backend/jvm/opt/BoxUnbox.scala  |   3 +-
 .../tools/nsc/backend/jvm/opt/CallGraph.scala |   8 +-
 .../tools/nsc/backend/jvm/opt/CopyProp.scala  |   4 +-
 .../tools/nsc/backend/jvm/opt/Inliner.scala   |   4 +-
 .../tools/nsc/backend/jvm/opt/LocalOpt.scala  |   4 +-
 .../ZipAndJarFileLookupFactory.scala          |  10 +-
 src/compiler/scala/tools/nsc/io/Jar.scala     |   4 +-
 .../tools/nsc/reporters/PrintReporter.scala   |   8 +-
 .../scala/tools/nsc/reporters/Reporter.scala  |  33 +-
 .../nsc/settings/StandardScalaSettings.scala  |  18 +
 .../scala/tools/nsc/transform/CleanUp.scala   |  10 +-
 .../tools/nsc/transform/Delambdafy.scala      |  10 +-
 .../scala/tools/nsc/transform/Fields.scala    |   4 +-
 .../nsc/transform/async/AnfTransform.scala    |   3 +-
 .../nsc/transform/async/AsyncNames.scala      |   4 +-
 .../nsc/transform/async/ExprBuilder.scala     |   6 +-
 .../tools/nsc/transform/patmat/Logic.scala    |   3 +-
 .../transform/patmat/PatternExpansion.scala   |   2 +-
 .../tools/nsc/transform/patmat/Solving.scala  |   3 +-
 .../tools/nsc/typechecker/Adaptations.scala   |  10 +-
 .../tools/nsc/typechecker/Analyzer.scala      |   2 +-
 .../tools/nsc/typechecker/ContextErrors.scala |  39 +-
 .../tools/nsc/typechecker/Contexts.scala      |  15 +-
 .../tools/nsc/typechecker/Implicits.scala     |   9 +-
 .../scala/tools/nsc/typechecker/Infer.scala   |   6 +-
 .../scala/tools/nsc/typechecker/Namers.scala  |  28 +-
 .../tools/nsc/typechecker/RefChecks.scala     | 203 +++--
 .../nsc/typechecker/StdAttachments.scala      |   4 +-
 .../nsc/typechecker/TypeDiagnostics.scala     |  19 +-
 .../scala/tools/nsc/typechecker/Typers.scala  | 100 +-
 .../tools/nsc/util/JavaCharArrayReader.scala  |   3 +-
 .../scala/tools/nsc/util/SimpleTracer.scala   |   2 +-
 .../scala/tools/nsc/util/WorkScheduler.scala  |   2 +-
 .../reflect/FastStringInterpolator.scala      |   2 +-
 .../scala/tools/reflect/ToolBoxFactory.scala  |   2 +-
 .../scala/tools/nsc/interactive/Pickler.scala |   3 +-
 .../tools/nsc/interactive/Picklers.scala      |   2 +-
 src/library/scala/beans/BeanProperty.scala    |   4 +-
 .../scala/beans/BooleanBeanProperty.scala     |   4 +-
 src/library/scala/collection/ArrayOps.scala   |   3 +-
 .../scala/collection/IterableOnce.scala       |   7 +-
 src/library/scala/collection/Seq.scala        |   3 +-
 src/library/scala/collection/SeqView.scala    |   3 +-
 .../convert/JavaCollectionWrappers.scala      |   4 +-
 .../collection/immutable/ChampCommon.scala    |   6 +-
 .../scala/collection/immutable/HashMap.scala  |  43 +-
 .../scala/collection/immutable/HashSet.scala  |  18 +-
 .../scala/collection/immutable/LazyList.scala |   3 +-
 .../scala/collection/immutable/Map.scala      |  30 +-
 .../collection/immutable/RedBlackTree.scala   |   5 +-
 .../scala/collection/immutable/SeqMap.scala   |  18 +-
 .../scala/collection/immutable/Set.scala      |  21 +-
 .../scala/collection/immutable/Stream.scala   |   3 +-
 .../scala/collection/immutable/Vector.scala   |  20 +-
 .../scala/collection/mutable/ArrayDeque.scala |   6 +-
 src/library/scala/util/matching/Regex.scala   |   2 +-
 .../scala/tools/partest/ReplTest.scala        |   7 +-
 .../scala/tools/partest/ScriptTest.scala      |   2 +-
 .../tools/partest/StubErrorMessageTest.scala  |   2 +-
 .../scala/tools/partest/nest/Runner.scala     |   4 +-
 src/reflect/scala/reflect/api/Symbols.scala   |   2 +-
 .../reflect/internal/AnnotationInfos.scala    |  12 +-
 .../scala/reflect/internal/BaseTypeSeqs.scala |   3 +-
 .../scala/reflect/internal/Definitions.scala  |   8 +-
 .../scala/reflect/internal/Flags.scala        |   6 +-
 .../scala/reflect/internal/HasFlags.scala     |   6 +-
 .../scala/reflect/internal/Names.scala        |   2 +
 .../scala/reflect/internal/Scopes.scala       |   2 +-
 .../scala/reflect/internal/SymbolTable.scala  |   6 +-
 .../scala/reflect/internal/Symbols.scala      |  12 +-
 .../scala/reflect/internal/TreeGen.scala      |   6 +-
 .../scala/reflect/internal/Trees.scala        |  18 +-
 .../reflect/internal/util/CodeAction.scala    |  14 +-
 .../reflect/internal/util/Collections.scala   |   3 +-
 .../reflect/runtime/SynchronizedSymbols.scala |   2 +-
 .../nsc/interpreter/shell/Reporter.scala      |  21 +-
 src/sbt-bridge/scala/tools/xsbt/API.scala     | 221 +++++
 .../scala/tools/xsbt/AbstractZincFile.scala   |  45 +
 .../scala/tools/xsbt/Analyzer.scala           | 106 +++
 .../scala/tools/xsbt/CallbackGlobal.scala     | 285 ++++++
 .../scala/tools/xsbt/ClassName.scala          | 107 +++
 src/sbt-bridge/scala/tools/xsbt/Compat.scala  |  53 ++
 .../scala/tools/xsbt/CompilerBridge.scala     | 201 ++++
 .../scala/tools/xsbt/ConsoleBridge.scala      | 109 +++
 .../scala/tools/xsbt/DelegatingReporter.scala | 354 ++++++++
 .../scala/tools/xsbt/Dependency.scala         | 485 ++++++++++
 .../scala/tools/xsbt/ExtractAPI.scala         | 856 ++++++++++++++++++
 .../scala/tools/xsbt/ExtractUsedNames.scala   | 363 ++++++++
 .../scala/tools/xsbt/GlobalHelpers.scala      | 186 ++++
 .../tools/xsbt/InteractiveConsoleBridge.scala | 103 +++
 .../InteractiveConsoleFactoryBridge.scala     |  44 +
 .../tools/xsbt/InteractiveConsoleHelper.scala |  29 +
 .../xsbt/InteractiveConsoleResponse.scala     |  21 +
 .../scala/tools/xsbt/JarUtils.scala           |  53 ++
 .../scala/tools/xsbt/JavaUtils.scala          |  39 +
 .../tools/xsbt/LocalToNonLocalClass.scala     |  79 ++
 .../scala/tools/xsbt/LocateClassFile.scala    |  57 ++
 src/sbt-bridge/scala/tools/xsbt/Log.scala     |  22 +
 src/sbt-bridge/scala/tools/xsbt/Message.scala |  24 +
 .../scala/tools/xsbt/ScaladocBridge.scala     |  87 ++
 .../scala/tools/xsbt/ZincCompat.scala         |  27 +
 .../nsc/doc/base/CommentFactoryBase.scala     |  36 +-
 .../tools/nsc/doc/base/comment/Body.scala     |   2 +-
 .../tools/nsc/doc/base/comment/Comment.scala  |   4 +-
 .../tools/nsc/doc/doclet/Generator.scala      |   2 +-
 .../tools/nsc/doc/html/HtmlFactory.scala      |   2 +-
 .../tools/nsc/doc/model/CommentFactory.scala  |   2 +-
 .../scala/tools/nsc/doc/model/Entity.scala    |   1 -
 .../tools/nsc/doc/model/ModelFactory.scala    |  62 +-
 .../model/ModelFactoryImplicitSupport.scala   |   7 +-
 .../doc/model/ModelFactoryTypeSupport.scala   |   2 +-
 .../tools/nsc/doc/model/TreeEntity.scala      |   3 +-
 .../tools/nsc/doc/model/TreeFactory.scala     |   2 +-
 .../tools/nsc/doc/model/TypeEntity.scala      |   2 +-
 .../scala/tools/testkit/ReflectUtil.scala     |   8 +
 test/files/jvm/interpreter.check              |   2 +-
 test/files/neg/auto-application.check         |   2 +-
 test/files/neg/checksensible.check            |   2 +-
 test/files/neg/deprecated-annots.check        |   6 +
 test/files/neg/deprecated-annots.scala        |  11 +
 test/files/neg/deprecated_widening.check      |  36 +-
 test/files/neg/dotless-targs-a.check          |   6 +-
 test/files/neg/dotless-targs-b.check          |   6 +-
 test/files/neg/dotless-targs-ranged-a.check   |  10 +-
 test/files/neg/for-comprehension-old.check    |  16 +-
 test/files/neg/for-comprehension-val.check    |  16 +-
 test/files/neg/implicits.check                |   4 +-
 test/files/neg/lint-int-div-to-float.check    |  10 +-
 test/files/neg/literals.check                 |   4 +-
 test/files/neg/macro-deprecate-idents.check   |   2 +-
 test/files/neg/names-defaults-neg.check       |   4 +-
 test/files/neg/nullary-override-3a.check      |  20 +-
 test/files/neg/nullary-override-3b.check      |   8 +-
 test/files/neg/nullary-override.check         |  15 +-
 test/files/neg/override-final-implicit.check  |   2 +-
 test/files/neg/parens-for-params.check        |   2 +-
 .../neg/prefix-unary-nilary-deprecation.check |   6 +-
 .../neg/prefix-unary-nilary-removal.check     |   6 +-
 test/files/neg/private-implicit-class.check   |   2 +-
 test/files/neg/procedure-deprecation.check    |  10 +-
 test/files/neg/procedure-removal.check        |  16 +-
 test/files/neg/qmark-deprecated.check         |  16 +-
 test/files/neg/quickfix-silent.check          |  11 +
 test/files/neg/quickfix-silent.scala          |   5 +
 test/files/neg/scala3-keywords.check          |  12 +-
 test/files/neg/sip23-no-unit-type.check       |   8 +-
 .../neg/symbol-literal-deprecation.check      |   2 +-
 test/files/neg/t10678.check                   |   2 +-
 test/files/neg/t11921-alias.check             |   8 +-
 test/files/neg/t11921.check                   |   2 +-
 test/files/neg/t11921b.check                  |  24 +-
 test/files/neg/t11921b.scala                  |  16 +
 test/files/neg/t11962.check                   |   4 +-
 test/files/neg/t12728.check                   |  32 +-
 test/files/neg/t12798-migration.check         |  14 +-
 test/files/neg/t12798.check                   |  14 +-
 test/files/neg/t12815.check                   |   4 +-
 test/files/neg/t12816.check                   |   4 +-
 test/files/neg/t12816b.check                  |   4 +-
 test/files/neg/t12851b.check                  |   9 +
 test/files/neg/t12851b/C_2.scala              |   2 +
 test/files/neg/t12851b/T_1.scala              |  11 +
 test/files/neg/t2206.check                    |   2 +-
 test/files/neg/t2421b.check                   |   2 +-
 test/files/neg/t3006.check                    |   2 +-
 test/files/neg/t3346i.check                   |  10 +-
 test/files/neg/t4271.check                    |  12 +-
 test/files/neg/t4457_1.check                  |  10 +-
 test/files/neg/t4457_2.check                  |  10 +-
 test/files/neg/t4568.check                    |   2 +-
 test/files/neg/t4851.check                    |   8 +-
 test/files/neg/t4889.check                    |   2 +-
 test/files/neg/t5265a.check                   |  10 +-
 test/files/neg/t5265b.check                   |   4 +-
 test/files/neg/t5429.check                    |   2 +-
 test/files/neg/t5606.check                    |   4 +-
 test/files/neg/t5715.check                    |   2 +-
 test/files/neg/t5728.check                    |   2 +-
 test/files/neg/t6436.check                    |   4 +-
 test/files/neg/t6436b.check                   |   4 +-
 test/files/neg/t6567.check                    |   2 +-
 test/files/neg/t6667.check                    |   2 +-
 test/files/neg/t692.check                     |   2 +-
 test/files/neg/t712.check                     |   4 +-
 test/files/neg/t7131.check                    |   4 +-
 test/files/neg/t7187-3.check                  |   8 +-
 test/files/neg/t7187-deprecation.check        |  12 +-
 test/files/neg/t7187.check                    |   6 +-
 test/files/neg/t7212.check                    |   6 +-
 test/files/neg/t729.check                     |   4 +-
 test/files/neg/t8015-ffb.check                |   2 +-
 test/files/neg/t8035-removed.check            |   2 +-
 test/files/neg/t8322.check                    |   4 +-
 test/files/neg/t8417.check                    |   4 +-
 test/files/neg/t8525.check                    |   4 +-
 test/files/neg/t8610-arg.check                |   2 +-
 test/files/neg/t8610.check                    |   4 +-
 .../neg/unicode-arrows-deprecation.check      |   6 +-
 test/files/neg/using-source3.check            |   2 +-
 test/files/neg/using-source3b.check           |   2 +-
 test/files/neg/warn-unused-privates.scala     |   6 +-
 test/files/pos/annotated-outer.scala          |  12 +
 test/files/pos/t12600.scala                   |   6 +
 test/files/pos/t12851/C_2.scala               |   2 +
 test/files/pos/t12851/T_1.scala               |   7 +
 test/files/pos/t12851c/ScalaNumber.java       |  20 +
 .../pos/t12851c/ScalaNumericConversions.scala |  30 +
 test/files/run/infixPostfixAttachments.check  |   4 +-
 test/files/run/literals.check                 |   8 +-
 test/files/run/reify_ann5.check               |   6 +-
 test/files/run/repl-errors.check              |   2 +-
 test/files/run/t11402.check                   |   2 +-
 test/files/run/t8610.check                    |   2 +-
 .../scala/collection/FactoriesTest.scala      |  85 +-
 .../collection/ValueClassSeqOpsTest.scala     |  27 +
 .../immutable/LazyListLazinessTest.scala      |   2 +-
 .../scala/collection/immutable/MapTest.scala  |  15 +-
 .../scala/collection/immutable/SetTest.scala  |  21 +-
 test/junit/scala/tools/nsc/QuickfixTest.scala |  84 ++
 .../reporters/AbstractCodeActionTest.scala    | 122 ++-
 .../tools/nsc/reporters/CodeActionTest.scala  |   2 +-
 .../reporters/CodeActionXsource3Test.scala    |  32 +-
 .../nsc/reporters/PositionFilterTest.scala    |   5 +-
 .../scala/tools/xsbt/BasicBridgeTest.scala    |  23 +
 .../scala/tools/xsbt/BridgeTesting.scala      | 203 +++++
 .../scala/tools/xsbt/ClassNameTest.scala      | 289 ++++++
 .../scala/tools/xsbt/CodeActionTest.scala     |  18 +
 .../scala/tools/xsbt/DependencyTest.scala     | 229 +++++
 .../scala/tools/xsbt/ExtractAPITest.scala     | 204 +++++
 .../tools/xsbt/ExtractUsedNamesTest.scala     | 266 ++++++
 .../InteractiveConsoleInterfaceTest.scala     |  64 ++
 test/junit/scala/tools/xsbt/SameAPI.scala     | 398 ++++++++
 .../junit/scala/tools/xsbt/TestCallback.scala | 183 ++++
 test/junit/scala/tools/xsbt/package.scala     |  14 +
 test/scaladoc/resources/`t12846`.scala        |   7 +
 test/scaladoc/run/diagrams-base.check         |   6 +-
 test/scaladoc/run/diagrams-filtering.check    |   4 +-
 test/scaladoc/run/implicits-ambiguating.check |   4 +-
 test/scaladoc/run/implicits-base.check        |  12 +-
 test/scaladoc/run/implicits-chaining.check    |  10 +-
 .../run/implicits-known-type-classes.check    |  32 +-
 test/scaladoc/run/implicits-shadowing.check   |   2 +-
 test/scaladoc/run/implicits-var-exp.check     |   4 +-
 test/scaladoc/run/t12846.check                |   2 +
 test/scaladoc/run/t12846.scala                |  21 +
 262 files changed, 7705 insertions(+), 938 deletions(-)
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/API.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/AbstractZincFile.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/Analyzer.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/CallbackGlobal.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/ClassName.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/Compat.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/CompilerBridge.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/ConsoleBridge.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/DelegatingReporter.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/Dependency.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/ExtractAPI.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/ExtractUsedNames.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/GlobalHelpers.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleBridge.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleFactoryBridge.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleHelper.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleResponse.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/JarUtils.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/JavaUtils.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/LocalToNonLocalClass.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/LocateClassFile.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/Log.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/Message.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/ScaladocBridge.scala
 create mode 100644 src/sbt-bridge/scala/tools/xsbt/ZincCompat.scala
 create mode 100644 test/files/neg/deprecated-annots.check
 create mode 100644 test/files/neg/deprecated-annots.scala
 create mode 100644 test/files/neg/quickfix-silent.check
 create mode 100644 test/files/neg/quickfix-silent.scala
 create mode 100644 test/files/neg/t12851b.check
 create mode 100644 test/files/neg/t12851b/C_2.scala
 create mode 100644 test/files/neg/t12851b/T_1.scala
 create mode 100644 test/files/pos/annotated-outer.scala
 create mode 100644 test/files/pos/t12600.scala
 create mode 100644 test/files/pos/t12851/C_2.scala
 create mode 100644 test/files/pos/t12851/T_1.scala
 create mode 100644 test/files/pos/t12851c/ScalaNumber.java
 create mode 100644 test/files/pos/t12851c/ScalaNumericConversions.scala
 create mode 100644 test/junit/scala/collection/ValueClassSeqOpsTest.scala
 create mode 100644 test/junit/scala/tools/nsc/QuickfixTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/BasicBridgeTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/BridgeTesting.scala
 create mode 100644 test/junit/scala/tools/xsbt/ClassNameTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/CodeActionTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/DependencyTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/ExtractAPITest.scala
 create mode 100644 test/junit/scala/tools/xsbt/ExtractUsedNamesTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/InteractiveConsoleInterfaceTest.scala
 create mode 100644 test/junit/scala/tools/xsbt/SameAPI.scala
 create mode 100644 test/junit/scala/tools/xsbt/TestCallback.scala
 create mode 100644 test/junit/scala/tools/xsbt/package.scala
 create mode 100644 test/scaladoc/resources/`t12846`.scala
 create mode 100644 test/scaladoc/run/t12846.check
 create mode 100644 test/scaladoc/run/t12846.scala

diff --git a/.travis.yml b/.travis.yml
index bfdc8a0693..5d3ea93174 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -127,8 +127,7 @@ jobs:
     - stage: build
       if: type = pull_request OR type = push
       name: language spec
-      # wkhtmltopdf requires libssl1.1, which we can't install on xenial
-      dist: bionic
+      dist: focal
       language: ruby
       install:
         - ruby -v
diff --git a/build.sbt b/build.sbt
index 4bc6320d36..3c06a4b5c8 100644
--- a/build.sbt
+++ b/build.sbt
@@ -45,6 +45,7 @@ val jnaDep            = "net.java.dev.jna"               % "jna"
 val jlineDeps         = Seq(jlineDep, jnaDep)
 val testInterfaceDep  = "org.scala-sbt"                  % "test-interface"                   % "1.0"
 val diffUtilsDep      = "io.github.java-diff-utils"      % "java-diff-utils"                  % "4.12"
+val compilerInterfaceDep = "org.scala-sbt"               % "compiler-interface"               % "1.9.3"
 
 val projectFolder = settingKey[String]("subfolder in src when using configureAsSubproject, else the project name")
 
@@ -275,8 +276,26 @@ def fixPom(extra: (String, scala.xml.Node)*): Setting[_] = {
   ) ++ extra) }
 }
 
+def ivyDependencyFilter(deps: Seq[(String, String)], scalaBinaryVersion: String) = {
+  import scala.xml._
+  import scala.xml.transform._
+  new RuleTransformer(new RewriteRule {
+    override def transform(node: Node) = node match {
+      case e: Elem if e.label == "dependency" && {
+        val org = e.attribute("org").getOrElse("").toString
+        val name = e.attribute("name").getOrElse("").toString
+        deps.exists { case (g, a) =>
+          org == g && (name == a || name == (a + "_" + scalaBinaryVersion))
+        }
+      } => Seq.empty
+      case n => n
+    }
+  })
+}
+
 val pomDependencyExclusions =
   settingKey[Seq[(String, String)]]("List of (groupId, artifactId) pairs to exclude from the POM and ivy.xml")
+lazy val fixCsrIvy = taskKey[Unit]("Apply pomDependencyExclusions to coursier ivy")
 
 Global / pomDependencyExclusions := Nil
 
@@ -294,27 +313,47 @@ lazy val removePomDependencies: Seq[Setting[_]] = Seq(
               e.child.contains(<groupId>{g}</groupId>) &&
                 (e.child.contains(<artifactId>{a}</artifactId>) || e.child.contains(<artifactId>{a + "_" + scalaBinaryVersion.value}</artifactId>))
             } => Seq.empty
-        case n => Seq(n)
+        case n => n
       }
     }).transform(Seq(n2)).head
   },
+  fixCsrIvy := {
+    //  - coursier makes target/sbt-bridge/resolution-cache/org.scala-lang/scala2-sbt-bridge/2.13.12-bin-SNAPSHOT/resolved.xml.xml
+    //  - copied to target/sbt-bridge//ivy-2.13.12-bin-SNAPSHOT.xml
+    //  - copied to ~/.ivy2/local/org.scala-lang/scala2-sbt-bridge/2.13.12-bin-SNAPSHOT/ivys/ivy.xml
+    import scala.jdk.CollectionConverters._
+    import scala.xml._
+    val currentProject = csrProject.value
+    val ivyModule = org.apache.ivy.core.module.id.ModuleRevisionId.newInstance(
+      currentProject.module.organization.value,
+      currentProject.module.name.value,
+      currentProject.version,
+      currentProject.module.attributes.asJava)
+    val ivyFile = ivySbt.value.withIvy(streams.value.log)(_.getResolutionCacheManager).getResolvedIvyFileInCache(ivyModule)
+    val e = ivyDependencyFilter(pomDependencyExclusions.value, scalaBinaryVersion.value)
+      .transform(Seq(XML.loadFile(ivyFile))).head
+    XML.save(ivyFile.getAbsolutePath, e, xmlDecl = true)
+  },
+  publishConfiguration := Def.taskDyn {
+    val pc = publishConfiguration.value
+    Def.task {
+      fixCsrIvy.value
+      pc
+    }
+  }.value,
+  publishLocalConfiguration := Def.taskDyn {
+    val pc = publishLocalConfiguration.value
+    Def.task {
+      fixCsrIvy.value
+      pc
+    }
+  }.value,
   deliverLocal := {
+    // this doesn't seem to do anything currently, it probably worked before sbt used coursier
     import scala.xml._
-    import scala.xml.transform._
     val f = deliverLocal.value
-    val deps = pomDependencyExclusions.value
-    val e = new RuleTransformer(new RewriteRule {
-      override def transform(node: Node) = node match {
-        case e: Elem if e.label == "dependency" && {
-          val org = e.attribute("org").getOrElse("").toString
-          val name = e.attribute("name").getOrElse("").toString
-          deps.exists { case (g, a) =>
-             org == g && (name == a || name == (a + "_" + scalaBinaryVersion.value))
-          }
-        } => Seq.empty
-        case n => Seq(n)
-      }
-    }).transform(Seq(XML.loadFile(f))).head
+    val e = ivyDependencyFilter(pomDependencyExclusions.value, scalaBinaryVersion.value)
+      .transform(Seq(XML.loadFile(f))).head
     XML.save(f.getAbsolutePath, e, xmlDecl = true)
     f
   }
@@ -579,6 +618,47 @@ lazy val scaladoc = configureAsSubproject(project)
   )
   .dependsOn(compiler)
 
+// dependencies on compiler and compiler-interface are "provided" to align with scala3-sbt-bridge
+lazy val sbtBridge = configureAsSubproject(project, srcdir = Some("sbt-bridge"))
+  .settings(Osgi.settings)
+  .settings(AutomaticModuleName.settings("scala.sbtbridge"))
+  //.settings(fatalWarningsSettings)
+  .settings(
+    name := "scala2-sbt-bridge",
+    description := "sbt compiler bridge for Scala 2",
+    libraryDependencies += compilerInterfaceDep % Provided,
+    Compile / scalacOptions ++= Seq(
+      "-Xlint",
+      "-feature",
+      "-Wconf:cat=deprecation&msg=early initializers:s", // compiler heavily relies upon early initializers
+    ),
+    generateServiceProviderResources("xsbti.compile.CompilerInterface2" -> "scala.tools.xsbt.CompilerBridge"),
+    generateServiceProviderResources("xsbti.compile.ConsoleInterface1"  -> "scala.tools.xsbt.ConsoleBridge"),
+    generateServiceProviderResources("xsbti.compile.ScaladocInterface2" -> "scala.tools.xsbt.ScaladocBridge"),
+    generateServiceProviderResources("xsbti.InteractiveConsoleFactory"  -> "scala.tools.xsbt.InteractiveConsoleBridgeFactory"),
+    Compile / managedResourceDirectories := Seq((Compile / resourceManaged).value),
+    pomDependencyExclusions ++= List((organization.value, "scala-repl-frontend"), (organization.value, "scala-compiler-doc")),
+    fixPom(
+      "/project/name" -> <name>Scala 2 sbt Bridge</name>,
+      "/project/description" -> <description>sbt compiler bridge for Scala 2</description>,
+      "/project/packaging" -> <packaging>jar</packaging>
+    ),
+    headerLicense := Some(HeaderLicense.Custom(
+      s"""Zinc - The incremental compiler for Scala.
+         |Copyright Scala Center, Lightbend, and Mark Harrah
+         |
+         |Scala (${(ThisBuild/homepage).value.get})
+         |Copyright EPFL and Lightbend, Inc.
+         |
+         |Licensed under Apache License 2.0
+         |(http://www.apache.org/licenses/LICENSE-2.0).
+         |
+         |See the NOTICE file distributed with this work for
+         |additional information regarding copyright ownership.
+         |""".stripMargin)),
+  )
+  .dependsOn(compiler % Provided, replFrontend, scaladoc)
+
 lazy val scalap = configureAsSubproject(project)
   .settings(fatalWarningsSettings)
   .settings(
@@ -727,7 +807,7 @@ val addOpensForTesting = "-XX:+IgnoreUnrecognizedVMOptions" +: "--add-exports=jd
   Seq("java.util.concurrent.atomic", "java.lang", "java.lang.reflect", "java.net").map(p => s"--add-opens=java.base/$p=ALL-UNNAMED")
 
 lazy val junit = project.in(file("test") / "junit")
-  .dependsOn(testkit, compiler, replFrontend, scaladoc)
+  .dependsOn(testkit, compiler, replFrontend, scaladoc, sbtBridge)
   .settings(commonSettings)
   .settings(disableDocs)
   .settings(fatalWarningsSettings)
@@ -745,7 +825,7 @@ lazy val junit = project.in(file("test") / "junit")
       "-Ypatmat-exhaust-depth", "40", // despite not caring about patmat exhaustiveness, we still get warnings for this
     ),
     Compile / javacOptions ++= Seq("-Xlint"),
-    libraryDependencies ++= Seq(junitInterfaceDep, jolDep, diffUtilsDep),
+    libraryDependencies ++= Seq(junitInterfaceDep, jolDep, diffUtilsDep, compilerInterfaceDep),
     testOptions += Tests.Argument(TestFrameworks.JUnit, "-a", "-v", "-s"),
     Compile / unmanagedSourceDirectories := Nil,
     Test / unmanagedSourceDirectories := List(baseDirectory.value),
@@ -1048,7 +1128,7 @@ lazy val root: Project = (project in file("."))
 
     setIncOptions
   )
-  .aggregate(library, reflect, compiler, interactive, repl, replFrontend,
+  .aggregate(library, reflect, compiler, interactive, repl, replFrontend, sbtBridge,
     scaladoc, scalap, testkit, partest, junit, scalacheck, tasty, tastytest, scalaDist).settings(
     Compile / sources := Seq.empty,
     onLoadMessage := s"""|*** Welcome to the sbt build definition for Scala! ***
diff --git a/project/DottySupport.scala b/project/DottySupport.scala
index 4640ef9be3..6d22e0aca3 100644
--- a/project/DottySupport.scala
+++ b/project/DottySupport.scala
@@ -12,7 +12,7 @@ import sbt.librarymanagement.{
   * Settings to support validation of TastyUnpickler against the release of dotty with the matching TASTy version
   */
 object TastySupport {
-  val supportedTASTyRelease = "3.3.1-RC4" // TASTy version 28.4-1
+  val supportedTASTyRelease = "3.3.1-RC6" // TASTy version 28.4-1
   val scala3Compiler = "org.scala-lang" % "scala3-compiler_3" % supportedTASTyRelease
   val scala3Library = "org.scala-lang" % "scala3-library_3" % supportedTASTyRelease
 
diff --git a/project/MimaFilters.scala b/project/MimaFilters.scala
index 9f75e4349a..daeb36a56d 100644
--- a/project/MimaFilters.scala
+++ b/project/MimaFilters.scala
@@ -41,6 +41,19 @@ object MimaFilters extends AutoPlugin {
 
     // PR 10406
     ProblemFilters.exclude[DirectMissingMethodProblem]("scala.reflect.runtime.JavaUniverse#PerRunReporting.deprecationWarning"),
+
+    // extend AbstractIterator
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.MapKeyIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.MapKeyValueTupleHashIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.MapKeyValueTupleIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.MapKeyValueTupleReverseIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.MapNodeRemoveAllSetNodeIterator"),
+    ProblemFilters.exclude[DirectMissingMethodProblem]("scala.collection.immutable.MapNodeRemoveAllSetNodeIterator.next"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.MapValueIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.NewVectorIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.SetHashIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.SetIterator"),
+    ProblemFilters.exclude[MissingTypesProblem]("scala.collection.immutable.SetReverseIterator"),
   )
 
   override val buildSettings = Seq(
diff --git a/src/compiler/scala/reflect/quasiquotes/Placeholders.scala b/src/compiler/scala/reflect/quasiquotes/Placeholders.scala
index 0a6013400d..565436e7f4 100644
--- a/src/compiler/scala/reflect/quasiquotes/Placeholders.scala
+++ b/src/compiler/scala/reflect/quasiquotes/Placeholders.scala
@@ -32,14 +32,14 @@ trait Placeholders { self: Quasiquotes =>
   lazy val code = {
     val sb = new StringBuilder()
 
-    def appendPart(value: String, pos: Position) = {
+    def appendPart(value: String, pos: Position): Unit = {
       val start = sb.length
       sb.append(value)
       val end = sb.length
       posMap += pos -> ((start, end))
     }
 
-    def appendHole(tree: Tree, rank: Rank) = {
+    def appendHole(tree: Tree, rank: Rank): Unit = {
       val placeholderName = c.freshName(TermName(nme.QUASIQUOTE_PREFIX))
       sb.append(placeholderName)
       val holeTree =
@@ -76,14 +76,13 @@ trait Placeholders { self: Quasiquotes =>
       accessed += skey
       value
     }
-    def update(key: Name, hole: Hole) =
+    def update(key: Name, hole: Hole): Unit =
       underlying += key.toString -> hole
     def get(key: Name): Option[Hole] = {
       val skey = key.toString
-      underlying.get(skey).map { v =>
-        accessed += skey
-        v
-      }
+      val res = underlying.get(skey)
+      res.foreach(_ => accessed += skey)
+      res
     }
     def keysIterator: Iterator[TermName] = underlying.keysIterator.map(TermName(_))
   }
diff --git a/src/compiler/scala/reflect/reify/phases/Calculate.scala b/src/compiler/scala/reflect/reify/phases/Calculate.scala
index e7eca07b25..0263a7ea5e 100644
--- a/src/compiler/scala/reflect/reify/phases/Calculate.scala
+++ b/src/compiler/scala/reflect/reify/phases/Calculate.scala
@@ -60,8 +60,8 @@ trait Calculate {
         bindRelatedSymbol(tree.symbol.moduleClass, "moduleClass")
         bindRelatedSymbol(tree.symbol.companionClass, "companionClass")
         bindRelatedSymbol(tree.symbol.companionModule, "companionModule")
-        Some(tree.symbol) collect { case termSymbol: TermSymbol => bindRelatedSymbol(termSymbol.referenced, "referenced") }
-        Some(tree) collect { case labelDef: LabelDef => labelDef.params foreach (param => bindRelatedSymbol(param.symbol, "labelParam")) }
+        tree.symbol match { case termSymbol: TermSymbol => bindRelatedSymbol(termSymbol.referenced, "referenced") case _ => }
+        tree match { case labelDef: LabelDef => labelDef.params.foreach(param => bindRelatedSymbol(param.symbol, "labelParam")) case _ => }
         def bindRelatedSymbol(related: Symbol, name: String): Unit =
           if (related != null && related != NoSymbol) {
             if (reifyDebug) println("boundSym (" + name + "): " + related)
diff --git a/src/compiler/scala/reflect/reify/utils/NodePrinters.scala b/src/compiler/scala/reflect/reify/utils/NodePrinters.scala
index 3bb381736c..83f27cb7d7 100644
--- a/src/compiler/scala/reflect/reify/utils/NodePrinters.scala
+++ b/src/compiler/scala/reflect/reify/utils/NodePrinters.scala
@@ -14,6 +14,7 @@ package scala.reflect.reify
 package utils
 
 import java.lang.System.{lineSeparator => EOL}
+import scala.util.matching.Regex.quoteReplacement
 
 trait NodePrinters {
   self: Utils =>
@@ -63,7 +64,7 @@ trait NodePrinters {
           }
 
           val replacement = "Modifiers(" + buf.reverse.mkString(", ")  + ")"
-          java.util.regex.Matcher.quoteReplacement(replacement)
+          quoteReplacement(replacement)
         })
         s
       })
diff --git a/src/compiler/scala/reflect/reify/utils/SymbolTables.scala b/src/compiler/scala/reflect/reify/utils/SymbolTables.scala
index e4387bd41f..c48b2539d3 100644
--- a/src/compiler/scala/reflect/reify/utils/SymbolTables.scala
+++ b/src/compiler/scala/reflect/reify/utils/SymbolTables.scala
@@ -13,7 +13,7 @@
 package scala.reflect.reify
 package utils
 
-import scala.collection._
+import scala.collection.{immutable, mutable}, mutable.{ArrayBuffer, ListBuffer}
 import java.lang.System.{lineSeparator => EOL}
 
 trait SymbolTables {
@@ -22,7 +22,7 @@ trait SymbolTables {
   import global._
 
   class SymbolTable private[SymbolTable] (
-    private[SymbolTable] val symtab: immutable.ListMap[Symbol, Tree] = immutable.ListMap[Symbol, Tree](),
+    private[SymbolTable] val symtab: immutable.ListMap[Symbol, Tree] = immutable.ListMap.empty[Symbol, Tree],
     private[SymbolTable] val aliases: List[(Symbol, TermName)] = List[(Symbol, TermName)](),
     private[SymbolTable] val original: Option[List[Tree]] = None) {
 
@@ -166,8 +166,8 @@ trait SymbolTables {
       reifier.state.symtab = symtab0.asInstanceOf[reifier.SymbolTable]
       def currtab = reifier.symtab.asInstanceOf[SymbolTable]
       try {
-        val cumulativeSymtab = mutable.ArrayBuffer[Tree](symtab0.symtab.values.toList: _*)
-        val cumulativeAliases = mutable.ArrayBuffer[(Symbol, TermName)](symtab0.aliases: _*)
+        val cumulativeSymtab = ArrayBuffer[Tree](symtab0.symtab.values.toList: _*)
+        val cumulativeAliases = ArrayBuffer[(Symbol, TermName)](symtab0.aliases: _*)
 
         def fillInSymbol(sym: Symbol): Tree = {
           if (reifyDebug) println("Filling in: %s (%s)".format(sym, sym.accurateKindString))
@@ -203,7 +203,7 @@ trait SymbolTables {
         }
 
         val withAliases = cumulativeSymtab flatMap (entry => {
-          val result = mutable.ListBuffer[Tree]()
+          val result = ListBuffer[Tree]()
           result += entry
           val sym = reifyBinding(entry).symbol
           if (sym != NoSymbol)
diff --git a/src/compiler/scala/tools/nsc/Global.scala b/src/compiler/scala/tools/nsc/Global.scala
index 2b0c6d11f7..b4a1fc0823 100644
--- a/src/compiler/scala/tools/nsc/Global.scala
+++ b/src/compiler/scala/tools/nsc/Global.scala
@@ -82,8 +82,8 @@ class Global(var currentSettings: Settings, reporter0: Reporter)
   def findMemberFromRoot(fullName: Name): Symbol = rootMirror.findMemberFromRoot(fullName)
 
   override def openPackageModule(pkgClass: Symbol, force: Boolean): Unit = {
-    if (force || isPast(currentRun.namerPhase)) super.openPackageModule(pkgClass, true)
-    else analyzer.packageObjects.deferredOpen.add(pkgClass)
+    if (force || isPast(currentRun.namerPhase)) super.openPackageModule(pkgClass, force = true)
+    else analyzer.packageObjects.deferredOpen.addOne(pkgClass)
   }
 
   // alternate constructors ------------------------------------------
@@ -976,7 +976,7 @@ class Global(var currentSettings: Settings, reporter0: Reporter)
       cp.packages(parent).exists(_.name == fullPackageName)
     }
 
-    def invalidateOrRemove(pkg: ClassSymbol) = {
+    def invalidateOrRemove(pkg: ClassSymbol): Unit = {
       if (packageExists(fullClasspath))
         pkg setInfo new loaders.PackageLoader(fullPackageName, fullClasspath)
       else
@@ -1192,7 +1192,7 @@ class Global(var currentSettings: Settings, reporter0: Reporter)
     private class SyncedCompilationBuffer { self =>
       private val underlying = new mutable.ArrayBuffer[CompilationUnit]
       def size = synchronized { underlying.size }
-      def +=(cu: CompilationUnit): this.type = { synchronized { underlying += cu }; this }
+      def +=(cu: CompilationUnit): this.type = synchronized { underlying += cu; this }
       def head: CompilationUnit = synchronized { underlying.head }
       def apply(i: Int): CompilationUnit = synchronized { underlying(i) }
       def iterator: Iterator[CompilationUnit] = new collection.AbstractIterator[CompilationUnit] {
@@ -1691,7 +1691,7 @@ class Global(var currentSettings: Settings, reporter0: Reporter)
      */
     @tailrec
     private def resetPackageClass(pclazz: Symbol): Unit = if (typerPhase != NoPhase) {
-      enteringPhase(firstPhase) {
+      enteringPhase[Unit](firstPhase) {
         pclazz.setInfo(enteringPhase(typerPhase)(pclazz.info))
       }
       if (!pclazz.isRoot) resetPackageClass(pclazz.owner)
diff --git a/src/compiler/scala/tools/nsc/PipelineMain.scala b/src/compiler/scala/tools/nsc/PipelineMain.scala
index 0aa58520bc..23176c19ec 100644
--- a/src/compiler/scala/tools/nsc/PipelineMain.scala
+++ b/src/compiler/scala/tools/nsc/PipelineMain.scala
@@ -48,7 +48,7 @@ class PipelineMainClass(argFiles: Seq[Path], pipelineSettings: PipelineMain.Pipe
     val validRootPathComponent = root.toString.replace("/", "").replace(":", "")
     val result = changeExtension(pickleCache.resolve(validRootPathComponent).resolve(root.relativize(file)).normalize(), newExtension)
     if (useJars) Files.createDirectories(result.getParent)
-    strippedAndExportedClassPath.put(file.toRealPath().normalize(), result)
+    strippedAndExportedClassPath.update(file.toRealPath().normalize(), result)
     result
   }
 
@@ -176,7 +176,7 @@ class PipelineMainClass(argFiles: Seq[Path], pipelineSettings: PipelineMain.Pipe
       val awaitAllFutures: Future[_] = sequenceFailSlow(allFutures)
       var lastNumCompleted = allFutures.count(_.isCompleted)
       while (true) try {
-        Await.result(awaitAllFutures, Duration(60, "s"))
+        Await.ready(awaitAllFutures, Duration(60, "s"))
         timer.stop()
         val numCompleted = allFutures.count(_.isCompleted)
         reporterEcho(s"PROGRESS: $numCompleted / $numAllFutures")
diff --git a/src/compiler/scala/tools/nsc/Reporting.scala b/src/compiler/scala/tools/nsc/Reporting.scala
index 0ec4a672fe..d0d23edef0 100644
--- a/src/compiler/scala/tools/nsc/Reporting.scala
+++ b/src/compiler/scala/tools/nsc/Reporting.scala
@@ -14,12 +14,15 @@ package scala
 package tools
 package nsc
 
+import java.io.IOException
+import java.nio.charset.Charset
+import java.nio.file.{Files, Path, Paths}
 import java.util.regex.PatternSyntaxException
-import scala.annotation.nowarn
+import scala.annotation.{nowarn, tailrec}
 import scala.collection.mutable
 import scala.reflect.internal
 import scala.reflect.internal.util.StringOps.countElementsAsString
-import scala.reflect.internal.util.{CodeAction, NoSourceFile, Position, SourceFile}
+import scala.reflect.internal.util.{CodeAction, NoSourceFile, Position, SourceFile, TextEdit}
 import scala.tools.nsc.Reporting.Version.{NonParseableVersion, ParseableVersion}
 import scala.tools.nsc.Reporting._
 import scala.tools.nsc.settings.NoScalaVersion
@@ -62,6 +65,43 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
         else conf
     }
 
+    private lazy val quickfixFilters = {
+      if (settings.quickfix.isSetByUser && settings.quickfix.value.isEmpty) {
+        globalError(s"Missing message filter for `-quickfix`; see `-quickfix:help` or use `-quickfix:any` to apply all available quick fixes.")
+        Nil
+      } else if (settings.quickFixSilent) {
+        Nil
+      } else {
+        val parsed = settings.quickfix.value.map(WConf.parseFilter(_, rootDirPrefix))
+        val msgs = parsed.collect { case Left(msg) => msg }
+        if (msgs.nonEmpty) {
+          globalError(s"Failed to parse `-quickfix` filters: ${settings.quickfix.value.mkString(",")}\n${msgs.mkString("\n")}")
+          Nil
+        } else parsed.collect { case Right(f) => f }
+      }
+    }
+
+    private val skipRewriteAction = Set(Action.WarningSummary, Action.InfoSummary, Action.Silent)
+
+    private def registerTextEdit(m: Message): Boolean =
+      if (quickfixFilters.exists(f => f.matches(m))) {
+        textEdits.addAll(m.actions.flatMap(_.edits))
+        true
+      }
+      else false
+
+    private def registerErrorTextEdit(pos: Position, msg: String, actions: List[CodeAction]): Boolean = {
+      val matches = quickfixFilters.exists({
+        case MessageFilter.Any => true
+        case mp: MessageFilter.MessagePattern => mp.check(msg)
+        case sp: MessageFilter.SourcePattern => sp.check(pos)
+        case _ => false
+      })
+      if (matches)
+        textEdits.addAll(actions.flatMap(_.edits))
+      matches
+    }
+
     private val summarizedWarnings: mutable.Map[WarningCategory, mutable.LinkedHashMap[Position, Message]] = mutable.HashMap.empty
     private val summarizedInfos: mutable.Map[WarningCategory, mutable.LinkedHashMap[Position, Message]] = mutable.HashMap.empty
 
@@ -69,6 +109,8 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
     private val suppressionsComplete: mutable.Set[SourceFile] = mutable.Set.empty
     private val suspendedMessages: mutable.LinkedHashMap[SourceFile, mutable.LinkedHashSet[Message]] = mutable.LinkedHashMap.empty
 
+    private val textEdits: mutable.Set[TextEdit] = mutable.Set.empty
+
     // Used in REPL. The old run is used for parsing. Don't discard its suspended warnings.
     def initFrom(old: PerRunReporting): Unit = {
       suspendedMessages ++= old.suspendedMessages
@@ -100,6 +142,10 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
           sups   <- suppressions.remove(source)
           sup    <- sups.reverse
         } if (!sup.used && !sup.synthetic) issueWarning(Message.Plain(sup.annotPos, "@nowarn annotation does not suppress any warnings", WarningCategory.UnusedNowarn, "", Nil))
+
+      // apply quick fixes
+      quickfix(textEdits)
+      textEdits.clear()
     }
 
     def reportSuspendedMessages(unit: CompilationUnit): Unit = {
@@ -119,6 +165,14 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
     }
 
     private def issueWarning(warning: Message): Unit = {
+      val action = wconf.action(warning)
+
+      val quickfixed = {
+        if (!skipRewriteAction(action) && registerTextEdit(warning)) s"[rewritten by -quickfix] ${warning.msg}"
+        else if (warning.actions.exists(_.edits.nonEmpty) && !settings.quickFixSilent) s"${warning.msg} [quickfixable]"
+        else warning.msg
+      }
+
       def ifNonEmpty(kind: String, filter: String) = if (filter.nonEmpty) s", $kind=$filter" else ""
       def filterHelp =
         s"msg=<part of the message>, cat=${warning.category.name}" +
@@ -133,12 +187,13 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
           "\nScala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings."
         else ""
       def helpMsg(kind: String, isError: Boolean = false) =
-        s"${warning.msg}${scala3migration(isError)}\nApplicable -Wconf / @nowarn filters for this $kind: $filterHelp"
-      wconf.action(warning) match {
+        s"$quickfixed${scala3migration(isError)}\nApplicable -Wconf / @nowarn filters for this $kind: $filterHelp"
+
+      action match {
         case Action.Error => reporter.error(warning.pos, helpMsg("fatal warning", isError = true), warning.actions)
-        case Action.Warning => reporter.warning(warning.pos, warning.msg, warning.actions)
+        case Action.Warning => reporter.warning(warning.pos, quickfixed, warning.actions)
         case Action.WarningVerbose => reporter.warning(warning.pos, helpMsg("warning"), warning.actions)
-        case Action.Info => reporter.echo(warning.pos, warning.msg, warning.actions)
+        case Action.Info => reporter.echo(warning.pos, quickfixed, warning.actions)
         case Action.InfoVerbose => reporter.echo(warning.pos, helpMsg("message"), warning.actions)
         case a @ (Action.WarningSummary | Action.InfoSummary) =>
           val m = summaryMap(a, warning.category.summaryCategory)
@@ -255,16 +310,14 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
 
     def featureWarning(pos: Position, featureName: String, featureDesc: String, featureTrait: Symbol, construct: => String = "", required: Boolean, site: Symbol): Unit = {
       val req     = if (required) "needs to" else "should"
-      val fqname  = "scala.language." + featureName
-      val explain = (
-        if (reportedFeature contains featureTrait) "" else
-          s"""
-             |----
-             |This can be achieved by adding the import clause 'import $fqname'
-             |or by setting the compiler option -language:$featureName.
-             |See the Scaladoc for value $fqname for a discussion
-             |why the feature $req be explicitly enabled.""".stripMargin
-        )
+      val fqname  = s"scala.language.$featureName"
+      val explain =
+        if (reportedFeature contains featureTrait) ""
+        else sm"""|
+                  |This can be achieved by adding the import clause 'import $fqname'
+                  |or by setting the compiler option -language:$featureName.
+                  |See the Scaladoc for value $fqname for a discussion
+                  |why the feature $req be explicitly enabled."""
       reportedFeature += featureTrait
 
       val msg = s"$featureDesc $req be enabled\nby making the implicit value $fqname visible.$explain".replace("#", construct)
@@ -299,6 +352,19 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
     def warning(pos: Position, msg: String, category: WarningCategory, site: Symbol, origin: String): Unit =
       issueIfNotSuppressed(Message.Origin(pos, msg, category, siteName(site), origin, actions = Nil))
 
+    def codeAction(title: String, pos: Position, newText: String, desc: String, expected: Option[(String, CompilationUnit)] = None) =
+      CodeAction(title, pos, newText, desc, expected.forall(e => e._1 == e._2.sourceAt(pos)))
+
+    // Remember CodeActions that match `-quickfix` and report the error through the reporter
+    def error(pos: Position, msg: String, actions: List[CodeAction]): Unit = {
+      val quickfixed = {
+        if (registerErrorTextEdit(pos, msg, actions)) s"[rewritten by -quickfix] $msg"
+        else if (actions.exists(_.edits.nonEmpty) && !settings.quickFixSilent) s"$msg [quickfixable]"
+        else msg
+      }
+      reporter.error(pos, quickfixed, actions)
+    }
+
     // used by Global.deprecationWarnings, which is used by sbt
     def deprecationWarnings: List[(Position, String)] = summaryMap(Action.WarningSummary, WarningCategory.Deprecation).toList.map(p => (p._1, p._2.msg))
     def uncheckedWarnings: List[(Position, String)]   = summaryMap(Action.WarningSummary, WarningCategory.Unchecked).toList.map(p => (p._1, p._2.msg))
@@ -330,6 +396,91 @@ trait Reporting extends internal.Reporting { self: ast.Positions with Compilatio
       if (settings.fatalWarnings.value && reporter.hasWarnings)
         reporter.error(NoPosition, "No warnings can be incurred under -Werror.")
     }
+
+    private object quickfix {
+      /** Source code at a position. Either a line with caret (offset), else the code at the range position. */
+      def codeOf(pos: Position, source: SourceFile): String =
+        if (pos.start < pos.end) new String(source.content.slice(pos.start, pos.end))
+        else {
+          val line = source.offsetToLine(pos.point)
+          val code = source.lines(line).next()
+          val caret = " " * (pos.point - source.lineToOffset(line)) + "^"
+          s"$code\n$caret"
+        }
+
+
+      def checkNoOverlap(patches: List[TextEdit], source: SourceFile): Boolean = {
+        var ok = true
+        for (List(p1, p2) <- patches.sliding(2) if p1.position.end > p2.position.start) {
+          ok = false
+          val msg =
+            s"""overlapping quick fixes in ${source.file.file.getAbsolutePath}:
+               |
+               |add `${p1.newText}` at
+               |${codeOf(p1.position, source)}
+               |
+               |add `${p2.newText}` at
+               |${codeOf(p2.position, source)}""".stripMargin.trim
+          issueWarning(Message.Plain(p1.position, msg, WarningCategory.Other, "", Nil))
+        }
+        ok
+      }
+
+      def underlyingFile(source: SourceFile): Option[Path] = {
+        val fileClass = source.file.getClass.getName
+        val p = if (fileClass.endsWith("xsbt.ZincVirtualFile")) {
+          import scala.language.reflectiveCalls
+          val path = source.file.asInstanceOf[ {def underlying(): {def id(): String}}].underlying().id()
+          Some(Paths.get(path))
+        } else
+          Option(source.file.file).map(_.toPath)
+        val r = p.filter(Files.exists(_))
+        if (r.isEmpty)
+          issueWarning(Message.Plain(NoPosition, s"Failed to apply quick fixes, file does not exist: ${source.file}", WarningCategory.Other, "", Nil))
+        r
+      }
+
+      val encoding = Charset.forName(settings.encoding.value)
+
+      def insertEdits(sourceChars: Array[Char], edits: List[TextEdit], file: Path): Array[Byte] = {
+        val patchedChars = new Array[Char](sourceChars.length + edits.iterator.map(_.delta).sum)
+        @tailrec def loop(edits: List[TextEdit], inIdx: Int, outIdx: Int): Unit = {
+          def copy(upTo: Int): Int = {
+            val untouched = upTo - inIdx
+            System.arraycopy(sourceChars, inIdx, patchedChars, outIdx, untouched)
+            outIdx + untouched
+          }
+          edits match {
+            case e :: es =>
+              val outNew = copy(e.position.start)
+              e.newText.copyToArray(patchedChars, outNew)
+              loop(es, e.position.end, outNew + e.newText.length)
+            case _ =>
+              val outNew = copy(sourceChars.length)
+              if (outNew != patchedChars.length)
+                issueWarning(Message.Plain(NoPosition, s"Unexpected content length when applying quick fixes; verify the changes to ${file.toFile.getAbsolutePath}", WarningCategory.Other, "", Nil))
+          }
+        }
+
+        loop(edits, 0, 0)
+        new String(patchedChars).getBytes(encoding)
+      }
+
+      def apply(edits: mutable.Set[TextEdit]): Unit = {
+        for ((source, edits) <- edits.groupBy(_.position.source).view.mapValues(_.toList.sortBy(_.position.start))) {
+          if (checkNoOverlap(edits, source)) {
+            underlyingFile(source) foreach { file =>
+              val sourceChars = new String(Files.readAllBytes(file), encoding).toCharArray
+              try Files.write(file, insertEdits(sourceChars, edits, file))
+              catch {
+                case e: IOException =>
+                  issueWarning(Message.Plain(NoPosition, s"Failed to apply quick fixes to ${file.toFile.getAbsolutePath}\n${e.getMessage}", WarningCategory.Other, "", Nil))
+              }
+            }
+          }
+        }
+      }
+    }
   }
 }
 
@@ -372,7 +523,7 @@ object Reporting {
     private val insertDash = "(?=[A-Z][a-z])".r
 
     val all: mutable.Map[String, WarningCategory] = mutable.Map.empty
-    private def add(c: WarningCategory): Unit = all.put(c.name, c).ensuring(_.isEmpty, s"lint '${c.name}' added twice")
+    private def add(c: WarningCategory): Unit = all.put(c.name, c).foreach(_ => assert(false, s"lint '${c.name}' added twice"))
 
     object Deprecation extends WarningCategory; add(Deprecation)
 
@@ -532,7 +683,8 @@ object Reporting {
     }
 
     final case class MessagePattern(pattern: Regex) extends MessageFilter {
-      def matches(message: Message): Boolean = pattern.findFirstIn(message.msg).nonEmpty
+      def check(msg: String) = pattern.findFirstIn(msg).nonEmpty
+      def matches(message: Message): Boolean = check(message.msg)
     }
 
     final case class SitePattern(pattern: Regex) extends MessageFilter {
@@ -542,10 +694,11 @@ object Reporting {
     final case class SourcePattern(pattern: Regex) extends MessageFilter {
       private[this] val cache = mutable.Map.empty[SourceFile, Boolean]
 
-      def matches(message: Message): Boolean = cache.getOrElseUpdate(message.pos.source, {
-        val sourcePath = message.pos.source.file.canonicalPath.replace("\\", "/")
+      def check(pos: Position) = cache.getOrElseUpdate(pos.source, {
+        val sourcePath = pos.source.file.canonicalPath.replace("\\", "/")
         pattern.findFirstIn(sourcePath).nonEmpty
       })
+      def matches(message: Message): Boolean = check(message.pos)
     }
 
     final case class DeprecatedOrigin(pattern: Regex) extends MessageFilter {
diff --git a/src/compiler/scala/tools/nsc/ast/Printers.scala b/src/compiler/scala/tools/nsc/ast/Printers.scala
index e7cdb13457..cbc98c2720 100644
--- a/src/compiler/scala/tools/nsc/ast/Printers.scala
+++ b/src/compiler/scala/tools/nsc/ast/Printers.scala
@@ -63,7 +63,7 @@ trait Printers extends scala.reflect.internal.Printers { this: Global =>
       treePrinter.println()
       treePrinter.print(definition)
 
-    case TypeTreeWithDeferredRefCheck() =>
+    case _: TypeTreeWithDeferredRefCheck =>
       treePrinter.print("<tree with deferred refcheck>")
 
     case SelectFromArray(qualifier, name, _) =>
diff --git a/src/compiler/scala/tools/nsc/ast/Trees.scala b/src/compiler/scala/tools/nsc/ast/Trees.scala
index b442e5ef9f..8ba674a4a8 100644
--- a/src/compiler/scala/tools/nsc/ast/Trees.scala
+++ b/src/compiler/scala/tools/nsc/ast/Trees.scala
@@ -66,7 +66,7 @@ trait Trees extends scala.reflect.internal.Trees { self: Global =>
   }
 
   /** emitted by typer, eliminated by refchecks */
-  case class TypeTreeWithDeferredRefCheck()(val check: () => TypeTree) extends TypTree {
+  case class TypeTreeWithDeferredRefCheck(precheck: TypeTree)(val check: () => TypeTree) extends TypTree {
     override def transform(transformer: ApiTransformer): Tree =
       transformer.treeCopy.TypeTreeWithDeferredRefCheck(this)
     override def traverse(traverser: Traverser): Unit = {
@@ -136,8 +136,8 @@ trait Trees extends scala.reflect.internal.Trees { self: Global =>
     def InjectDerivedValue(tree: Tree, arg: Tree) =
       new InjectDerivedValue(arg).copyAttrs(tree)
     def TypeTreeWithDeferredRefCheck(tree: Tree) = tree match {
-      case dc@TypeTreeWithDeferredRefCheck() => new TypeTreeWithDeferredRefCheck()(dc.check).copyAttrs(tree)
-      case x                                 => throw new MatchError(x)
+      case dc@TypeTreeWithDeferredRefCheck(prechk) => new TypeTreeWithDeferredRefCheck(prechk)(dc.check).copyAttrs(tree)
+      case x => throw new MatchError(x)
     }
   }
 
@@ -163,7 +163,7 @@ trait Trees extends scala.reflect.internal.Trees { self: Global =>
       case _ => this.treeCopy.InjectDerivedValue(tree, arg)
     }
     def TypeTreeWithDeferredRefCheck(tree: Tree) = tree match {
-      case t @ TypeTreeWithDeferredRefCheck() => t
+      case t: TypeTreeWithDeferredRefCheck => t
       case _ => this.treeCopy.TypeTreeWithDeferredRefCheck(tree)
     }
   }
@@ -202,7 +202,7 @@ trait Trees extends scala.reflect.internal.Trees { self: Global =>
     case InjectDerivedValue(arg) =>
       transformer.treeCopy.InjectDerivedValue(
         tree, transformer.transform(arg))
-    case TypeTreeWithDeferredRefCheck() =>
+    case _: TypeTreeWithDeferredRefCheck =>
       transformer.treeCopy.TypeTreeWithDeferredRefCheck(tree)
     case x => super.xtransform(transformer, tree)
   }
@@ -279,12 +279,9 @@ trait Trees extends scala.reflect.internal.Trees { self: Global =>
 
       override def traverse(tree: Tree) = {
         tree match {
-         case _: DefTree | Function(_, _) | Template(_, _, _) =>
-           markLocal(tree)
-         case _ =>
-           tree
+          case _: DefTree | Function(_, _) | Template(_, _, _) => markLocal(tree)
+          case _ =>
         }
-
         tree.traverse(this)
       }
     }
@@ -373,7 +370,7 @@ trait Trees extends scala.reflect.internal.Trees { self: Global =>
 
    case Parens(expr)                                               (only used during parsing)
    case DocDef(comment, defn) =>                                   (eliminated by typer)
-   case TypeTreeWithDeferredRefCheck() =>                          (created and eliminated by typer)
+   case TypeTreeWithDeferredRefCheck(prechk) =>                    (created by typer and eliminated by refchecks)
    case SelectFromArray(_, _, _) =>                                (created and eliminated by erasure)
    case InjectDerivedValue(_) =>                                   (created and eliminated by erasure)
 
diff --git a/src/compiler/scala/tools/nsc/ast/parser/Parsers.scala b/src/compiler/scala/tools/nsc/ast/parser/Parsers.scala
index 554a173d27..bda9471785 100644
--- a/src/compiler/scala/tools/nsc/ast/parser/Parsers.scala
+++ b/src/compiler/scala/tools/nsc/ast/parser/Parsers.scala
@@ -17,18 +17,12 @@ package scala.tools.nsc
 package ast.parser
 
 import scala.annotation.tailrec
-import scala.collection.mutable, mutable.ListBuffer
-import scala.reflect.internal.{ModifierFlags => Flags, Precedence}
-import scala.reflect.internal.util.{
-  CodeAction,
-  FreshNameCreator,
-  ListOfNil,
-  Position,
-  SourceFile,
-  TextEdit,
-}
-import Tokens._
+import scala.collection.mutable
+import scala.collection.mutable.ListBuffer
+import scala.reflect.internal.util.{CodeAction, FreshNameCreator, ListOfNil, Position, SourceFile}
+import scala.reflect.internal.{Precedence, ModifierFlags => Flags}
 import scala.tools.nsc.Reporting.WarningCategory
+import scala.tools.nsc.ast.parser.Tokens._
 
 /** Historical note: JavaParsers started life as a direct copy of Parsers
  *  but at a time when that Parsers had been replaced by a different one.
@@ -251,11 +245,11 @@ self =>
     val syntaxErrors = new ListBuffer[(Int, String, List[CodeAction])]
     def showSyntaxErrors() =
       for ((offset, msg, actions) <- syntaxErrors)
-        reporter.error(o2p(offset), msg, actions)
+        runReporting.error(o2p(offset), msg, actions)
 
     override def syntaxError(offset: Offset, msg: String, actions: List[CodeAction]): Unit = {
       if (smartParsing) syntaxErrors += ((offset, msg, actions))
-      else reporter.error(o2p(offset), msg, actions)
+      else runReporting.error(o2p(offset), msg, actions)
     }
 
     override def incompleteInputError(msg: String, actions: List[CodeAction]): Unit = {
@@ -329,7 +323,7 @@ self =>
       def source = parser.source
     }
     val treeBuilder = new ParserTreeBuilder
-    import treeBuilder.{global => _, unit => _, source => _, fresh => _, _}
+    import treeBuilder.{fresh => _, global => _, source => _, unit => _, _}
 
     implicit def fresh: FreshNameCreator = unit.fresh
 
@@ -633,11 +627,11 @@ self =>
       else deprecationWarning(offset, msg, since, actions)
 
     // deprecation or migration under -Xsource:3, with different messages
-    def hardMigrationWarning(offset: Offset, depr: => String, migr: => String, since: String, actions: List[CodeAction]): Unit =
-      if (currentRun.isScala3) warning(offset, migr, WarningCategory.Scala3Migration, actions)
-      else deprecationWarning(offset, depr, since, actions)
+    def hardMigrationWarning(offset: Offset, depr: => String, migr: => String, since: String, actions: String => List[CodeAction]): Unit =
+      if (currentRun.isScala3) warning(offset, migr, WarningCategory.Scala3Migration, actions(migr))
+      else deprecationWarning(offset, depr, since, actions(depr))
     def hardMigrationWarning(offset: Offset, depr: => String, migr: => String, since: String): Unit =
-      hardMigrationWarning(offset, depr, migr, since, Nil)
+      hardMigrationWarning(offset, depr, migr, since, _ => Nil)
 
     def expectedMsgTemplate(exp: String, fnd: String) = s"$exp expected but $fnd found."
     def expectedMsg(token: Token): String =
@@ -748,12 +742,18 @@ self =>
     def isWildcardType = in.token == USCORE || isScala3WildcardType
     def isScala3WildcardType = isRawIdent && in.name == raw.QMARK
     def checkQMarkDefinition() =
-      if (isScala3WildcardType)
-        syntaxError(in.offset, "using `?` as a type name requires backticks.")
+      if (isScala3WildcardType) {
+        val msg = "using `?` as a type name requires backticks."
+        syntaxError(in.offset, msg,
+          runReporting.codeAction("add backticks", r2p(in.offset, in.offset, in.offset + 1), "`?`", msg, expected = Some(("?", unit))))
+      }
+
     def checkKeywordDefinition() =
-      if (isRawIdent && scala3Keywords.contains(in.name))
-        deprecationWarning(in.offset,
-          s"Wrap `${in.name}` in backticks to use it as an identifier, it will become a keyword in Scala 3.", "2.13.7")
+      if (isRawIdent && scala3Keywords.contains(in.name)) {
+        val msg = s"Wrap `${in.name}` in backticks to use it as an identifier, it will become a keyword in Scala 3."
+        deprecationWarning(in.offset, msg, "2.13.7",
+          runReporting.codeAction("add backticks", r2p(in.offset, in.offset, in.offset + in.name.length), s"`${in.name}`", msg, expected = Some((in.name.toString, unit))))
+      }
 
     def isIdent = in.token == IDENTIFIER || in.token == BACKQUOTED_IDENT
     def isMacro = in.token == IDENTIFIER && in.name == nme.MACROkw
@@ -816,8 +816,7 @@ self =>
         val wrn = sm"""|$msg
                        |Use '-Wconf:msg=lambda-parens:s' to silence this warning."""
         def actions =
-          if (tree.pos.isRange)
-            List(CodeAction("lambda parameter", Some(msg), List(TextEdit(tree.pos, s"(${unit.sourceAt(tree.pos)})"))))
+          if (tree.pos.isRange) runReporting.codeAction("add parentheses", tree.pos, s"(${unit.sourceAt(tree.pos)})", msg)
           else Nil
         migrationWarning(tree.pos.point, wrn, "2.13.11", actions)
         List(convertToParam(tree))
@@ -1029,11 +1028,17 @@ self =>
 
     def finishBinaryOp(isExpr: Boolean, opinfo: OpInfo, rhs: Tree): Tree = {
       import opinfo._
-      if (targs.nonEmpty)
-        migrationWarning(offset, "type application is not allowed for infix operators", "2.13.11")
       val operatorPos: Position = Position.range(rhs.pos.source, offset, offset, offset + operator.length)
       val pos                   = lhs.pos.union(rhs.pos).union(operatorPos).withEnd(in.lastOffset).withPoint(offset)
 
+      if (targs.nonEmpty) {
+        val qual = unit.sourceAt(lhs.pos)
+        val fun = s"${CodeAction.maybeWrapInParens(qual)}.${unit.sourceAt(operatorPos.withEnd(rhs.pos.start))}".trim
+        val fix = s"$fun${CodeAction.wrapInParens(unit.sourceAt(rhs.pos))}"
+        val msg = "type application is not allowed for infix operators"
+        migrationWarning(offset, msg, "2.13.11",
+          runReporting.codeAction("use selection", pos, fix, msg))
+      }
       atPos(pos)(makeBinop(isExpr, lhs, operator, rhs, operatorPos, targs))
     }
 
@@ -1090,7 +1095,9 @@ self =>
         if (in.token == ARROW)
           atPos(start, in.skipToken()) { makeSafeFunctionType(ts, typ()) }
         else if (ts.isEmpty) {
-          syntaxError(start, "Illegal literal type (), use Unit instead")
+          val msg = "Illegal literal type (), use Unit instead"
+          syntaxError(start, msg,
+            runReporting.codeAction("use `Unit`", r2p(start, start, start + 2), "Unit", msg, expected = Some(("()", unit))))
           EmptyTree
         }
         else {
@@ -1174,7 +1181,9 @@ self =>
               if (lookingAhead(in.token == RPAREN)) {
                 in.nextToken()
                 in.nextToken()
-                syntaxError(start, "Illegal literal type (), use Unit instead")
+                val msg = "Illegal literal type (), use Unit instead"
+                syntaxError(start, msg,
+                  runReporting.codeAction("use `Unit`", r2p(start, start, start + 2), "Unit", msg, expected = Some(("()", unit))))
                 EmptyTree
               }
               else
@@ -1475,9 +1484,9 @@ self =>
         else withPlaceholders(interpolatedString(inPattern), isAny = true) // interpolator params are Any* by definition
       }
       else if (in.token == SYMBOLLIT) {
-        def msg(what: String) =
-          s"""symbol literal is $what; use Symbol("${in.strVal}") instead"""
-        deprecationWarning(in.offset, msg("deprecated"), "2.13.0")
+        val msg = s"""symbol literal is deprecated; use Symbol("${in.strVal}") instead"""
+        deprecationWarning(in.offset, msg, "2.13.0",
+          runReporting.codeAction("replace symbol literal", r2p(in.offset, in.offset, in.offset + 1 + in.strVal.length), s"""Symbol("${in.strVal}")""", msg, expected = Some((s"'${in.strVal}", unit))))
         Apply(scalaDot(nme.Symbol), List(finish(in.strVal)))
       }
       else finish(in.token match {
@@ -2095,17 +2104,15 @@ self =>
       val hasEq = in.token == EQUALS
 
       if (hasVal) {
-        def actions = {
-          val pos = r2p(valOffset, valOffset, valOffset + 4)
-          if (unit.sourceAt(pos) != "val ") Nil else
-            List(CodeAction("val in for comprehension", None, List(TextEdit(pos, ""))))
-        }
+        def actions(msg: String) = runReporting.codeAction("remove `val` keyword", r2p(valOffset, valOffset, valOffset + 4), "", msg, expected = Some(("val ", unit)))
         def msg(what: String, instead: String): String = s"`val` keyword in for comprehension is $what: $instead"
         if (hasEq) {
           val without = "instead, bind the value without `val`"
           hardMigrationWarning(in.offset, msg("deprecated", without), msg("unsupported", without), "2.10.0", actions)
+        } else {
+          val m = msg("unsupported", "just remove `val`")
+          syntaxError(in.offset, m, actions(m))
         }
-        else syntaxError(in.offset, msg("unsupported", "just remove `val`"), actions)
       }
 
       if (hasEq && eqOK && !hasCase) in.nextToken()
@@ -2969,7 +2976,11 @@ self =>
     def funDefOrDcl(start: Int, mods: Modifiers): Tree = {
       in.nextToken()
       if (in.token == THIS) {
-        def missingEquals() = hardMigrationWarning(in.lastOffset, "procedure syntax is deprecated for constructors: add `=`, as in method definition", "2.13.2")
+        def missingEquals() = {
+          val msg = "procedure syntax is deprecated for constructors: add `=`, as in method definition"
+          hardMigrationWarning(in.lastOffset, msg, "2.13.2",
+            runReporting.codeAction("replace procedure syntax", o2p(in.lastOffset), " =", msg))
+        }
         atPos(start, in.skipToken()) {
           val vparamss = paramClauses(nme.CONSTRUCTOR, classContextBounds map (_.duplicate), ofCaseClass = false)
           newLineOptWhenFollowedBy(LBRACE)
@@ -3006,8 +3017,8 @@ self =>
         var restype = fromWithinReturnType(typedOpt())
         def msg(what: String, instead: String) =
           s"procedure syntax is $what: instead, add `$instead` to explicitly declare `$name`'s return type"
-        def declActions = List(CodeAction("procedure syntax (decl)", None, List(TextEdit(o2p(in.lastOffset), ": Unit"))))
-        def defnActions = List(CodeAction("procedure syntax (defn)", None, List(TextEdit(o2p(in.lastOffset), ": Unit ="))))
+        def declActions(msg: String) = runReporting.codeAction("add result type", o2p(in.lastOffset), ": Unit", msg)
+        def defnActions(msg: String) = runReporting.codeAction("replace procedure syntax", o2p(in.lastOffset), ": Unit =", msg)
         val rhs =
           if (isStatSep || in.token == RBRACE) {
             if (restype.isEmpty) {
@@ -3035,7 +3046,11 @@ self =>
         if (nme.isEncodedUnary(name) && vparamss.nonEmpty) {
           def instead = DefDef(newmods, name.toTermName.decodedName, tparams, vparamss.drop(1), restype, rhs)
           def unaryMsg(what: String) = s"unary prefix operator definition with empty parameter list is $what: instead, remove () to declare as `$instead`"
-          def warnNilary() = hardMigrationWarning(nameOffset, unaryMsg("deprecated"), unaryMsg("unsupported"), "2.13.4")
+          def action(msg: String) = {
+            val o = nameOffset + name.decode.length
+            runReporting.codeAction("remove ()", r2p(o, o, o + 2), "", msg, expected = Some(("()", unit)))
+          }
+          def warnNilary() = hardMigrationWarning(nameOffset, unaryMsg("deprecated"), unaryMsg("unsupported"), "2.13.4", action)
           vparamss match {
             case List(List())                               => warnNilary()
             case List(List(), x :: xs) if x.mods.isImplicit => warnNilary()
@@ -3313,7 +3328,9 @@ self =>
      */
     def templateOpt(mods: Modifiers, name: Name, constrMods: Modifiers, vparamss: List[List[ValDef]], tstart: Offset): Template = {
       def deprecatedUsage(): Boolean = {
-        deprecationWarning(in.offset, "Using `<:` for `extends` is deprecated", since = "2.12.5")
+        val msg = "Using `<:` for `extends` is deprecated"
+        deprecationWarning(in.offset, msg, since = "2.12.5",
+          runReporting.codeAction("use `extends`", r2p(in.offset, in.offset, in.offset + 2), "extends", msg, expected = Some(("<:", unit))))
         true
       }
       val (parents, self, body) =
diff --git a/src/compiler/scala/tools/nsc/ast/parser/Scanners.scala b/src/compiler/scala/tools/nsc/ast/parser/Scanners.scala
index 3a7d180416..4288366eb2 100644
--- a/src/compiler/scala/tools/nsc/ast/parser/Scanners.scala
+++ b/src/compiler/scala/tools/nsc/ast/parser/Scanners.scala
@@ -167,6 +167,8 @@ trait Scanners extends ScannersCommon {
   }
 
   abstract class Scanner extends CharArrayReader with TokenData with ScannerData with ScannerCommon with DocScanner {
+    def unit: CompilationUnit
+
     /** A switch whether operators at the start of lines can be infix operators. */
     private var allowLeadingInfixOperators = true
 
@@ -817,10 +819,14 @@ trait Scanners extends ScannersCommon {
         case _ =>
           def fetchOther() = {
             if (ch == '\u21D2') {
-              deprecationWarning("The unicode arrow `⇒` is deprecated, use `=>` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.", "2.13.0")
+              val msg = "The unicode arrow `⇒` is deprecated, use `=>` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code."
+              deprecationWarning(msg, "2.13.0",
+                runReporting.codeAction("replace unicode arrow", unit.position(offset).withEnd(offset + 1), "=>", msg, expected = Some(("⇒", unit))))
               nextChar(); token = ARROW
             } else if (ch == '\u2190') {
-              deprecationWarning("The unicode arrow `←` is deprecated, use `<-` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.", "2.13.0")
+              val msg = "The unicode arrow `←` is deprecated, use `<-` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code."
+              deprecationWarning(msg, "2.13.0",
+                runReporting.codeAction("replace unicode arrow", unit.position(offset).withEnd(offset + 1), "<-", msg, expected = Some(("←", unit))))
               nextChar(); token = LARROW
             } else if (isUnicodeIdentifierStart(ch)) {
               putChar(ch)
@@ -1370,7 +1376,9 @@ trait Scanners extends ScannersCommon {
       // 1l is an acknowledged bad practice
       def lintel(): Unit = {
         val msg = "Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead"
-        if (ch == 'l') deprecationWarning(numberOffset + cbuf.length, msg, since="2.13.0")
+        val o = numberOffset + cbuf.length
+        if (ch == 'l') deprecationWarning(o, msg, since="2.13.0",
+          runReporting.codeAction("use uppercase L", unit.position(o).withEnd(o + 1), "L", msg, expected = Some(("l", unit))))
       }
       // after int: 5e7f, 42L, 42.toDouble but not 42b.
       def restOfNumber(): Unit = {
@@ -1573,6 +1581,8 @@ trait Scanners extends ScannersCommon {
    *  Useful for looking inside source files that are not currently compiled to see what's there
    */
   class SourceFileScanner(val source: SourceFile) extends Scanner {
+    def unit = global.currentUnit
+
     val buf = source.content
 
     // suppress warnings, throw exception on errors
@@ -1584,7 +1594,7 @@ trait Scanners extends ScannersCommon {
 
   /** A scanner over a given compilation unit
    */
-  class UnitScanner(val unit: CompilationUnit, patches: List[BracePatch]) extends SourceFileScanner(unit.source) {
+  class UnitScanner(override val unit: CompilationUnit, patches: List[BracePatch]) extends SourceFileScanner(unit.source) {
     def this(unit: CompilationUnit) = this(unit, List())
 
     override def warning(off: Offset, msg: String, category: WarningCategory): Unit =
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/PerRunInit.scala b/src/compiler/scala/tools/nsc/backend/jvm/PerRunInit.scala
index 69eb97565d..89e6e7af6a 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/PerRunInit.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/PerRunInit.scala
@@ -25,7 +25,7 @@ trait PerRunInit {
   // so the back end may initialise them in parallel, and ListBuffer is not threadsafe
   private val inits = ListBuffer.empty[() => Unit]
 
-  def perRunInit(init: => Unit): Unit = inits.synchronized (inits += (() => init))
+  def perRunInit(init: => Unit): Unit = inits.synchronized[Unit](inits += (() => init))
 
   def initialize(): Unit = inits.synchronized(inits.foreach(_.apply()))
 }
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/analysis/AliasingAnalyzer.scala b/src/compiler/scala/tools/nsc/backend/jvm/analysis/AliasingAnalyzer.scala
index c766814a2d..3b5fe32d4d 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/analysis/AliasingAnalyzer.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/analysis/AliasingAnalyzer.scala
@@ -15,6 +15,7 @@ package backend.jvm
 package analysis
 
 import scala.annotation.switch
+import scala.collection.AbstractIterator
 import scala.collection.mutable
 import scala.tools.asm.Opcodes
 import scala.tools.asm.tree._
@@ -423,7 +424,7 @@ class BasicAliasingAnalyzer(methodNode: MethodNode, classInternalName: InternalN
 /**
  * An iterator over Int (required to prevent boxing the result of next).
  */
-abstract class IntIterator extends Iterator[Int] {
+abstract class IntIterator extends AbstractIterator[Int] {
   def hasNext: Boolean
   def next(): Int
 }
@@ -491,7 +492,7 @@ class AliasSet(var set: Object /*SmallBitSet | Array[Long]*/, var size: Int) {
   }
 
   override def clone(): AliasSet = {
-    val resSet = (set: @unchecked) match {
+    val resSet: Object = (set: @unchecked) match {
       case s: SmallBitSet => new SmallBitSet(s.a, s.b, s.c, s.d)
       case bits: Array[Long] => bits.clone()
     }
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/opt/BoxUnbox.scala b/src/compiler/scala/tools/nsc/backend/jvm/opt/BoxUnbox.scala
index 7d790313f6..227b52311b 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/opt/BoxUnbox.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/opt/BoxUnbox.scala
@@ -15,6 +15,7 @@ package backend.jvm
 package opt
 
 import scala.annotation.tailrec
+import scala.collection.AbstractIterator
 import scala.collection.mutable
 import scala.jdk.CollectionConverters._
 import scala.tools.asm.Opcodes._
@@ -551,7 +552,7 @@ abstract class BoxUnbox {
    * For a set of box creation operations and a corresponding set of box consumer operations,
    * this iterator returns all copy operations (load, store, dup) that are in between.
    */
-  class CopyOpsIterator(initialCreations: Set[BoxCreation], finalCons: Set[BoxConsumer], prodCons: ProdConsAnalyzer) extends Iterator[AbstractInsnNode] {
+  class CopyOpsIterator(initialCreations: Set[BoxCreation], finalCons: Set[BoxConsumer], prodCons: ProdConsAnalyzer) extends AbstractIterator[AbstractInsnNode] {
     private val queue = mutable.Queue.empty[AbstractInsnNode] ++= initialCreations.iterator.flatMap(_.boxConsumers(prodCons, ultimate = false))
 
     // a single copy operation can consume multiple producers: val a = if (b) box(1) else box(2).
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/opt/CallGraph.scala b/src/compiler/scala/tools/nsc/backend/jvm/opt/CallGraph.scala
index 48eadef4c4..ec355bbbe6 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/opt/CallGraph.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/opt/CallGraph.scala
@@ -96,7 +96,7 @@ abstract class CallGraph {
   def removeCallsite(invocation: MethodInsnNode, methodNode: MethodNode): Option[Callsite] = {
     val methodCallsites = callsites(methodNode)
     val newCallsites = methodCallsites - invocation
-    if (newCallsites.isEmpty) callsites.remove(methodNode)
+    if (newCallsites.isEmpty) callsites.subtractOne(methodNode)
     else callsites(methodNode) = newCallsites
     methodCallsites.get(invocation)
   }
@@ -111,7 +111,7 @@ abstract class CallGraph {
   def removeClosureInstantiation(indy: InvokeDynamicInsnNode, methodNode: MethodNode): Option[ClosureInstantiation] = {
     val methodClosureInits = closureInstantiations(methodNode)
     val newClosureInits = methodClosureInits - indy
-    if (newClosureInits.isEmpty) closureInstantiations.remove(methodNode)
+    if (newClosureInits.isEmpty) closureInstantiations.subtractOne(methodNode)
     else closureInstantiations(methodNode) = newClosureInits
     methodClosureInits.get(indy)
   }
@@ -122,8 +122,8 @@ abstract class CallGraph {
   }
 
   def refresh(methodNode: MethodNode, definingClass: ClassBType): Unit = {
-    callsites.remove(methodNode)
-    closureInstantiations.remove(methodNode)
+    callsites.subtractOne(methodNode)
+    closureInstantiations.subtractOne(methodNode)
     // callsitePositions, inlineAnnotatedCallsites, noInlineAnnotatedCallsites, staticallyResolvedInvokespecial
     // are left unchanged. They contain individual instructions, the state for those remains valid in case
     // the inliner performs a rollback.
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/opt/CopyProp.scala b/src/compiler/scala/tools/nsc/backend/jvm/opt/CopyProp.scala
index ff0fac95dd..177c1c54a1 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/opt/CopyProp.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/opt/CopyProp.scala
@@ -629,11 +629,11 @@ abstract class CopyProp {
 
     val pairStartStack = new mutable.Stack[(AbstractInsnNode, mutable.ListBuffer[RemovePairDependency])]
 
-    def push(insn: AbstractInsnNode) = {
+    def push(insn: AbstractInsnNode): Unit = {
       pairStartStack push ((insn, mutable.ListBuffer.empty))
     }
 
-    def addDepends(dependency: RemovePairDependency) = if (pairStartStack.nonEmpty) {
+    def addDepends(dependency: RemovePairDependency): Unit = if (pairStartStack.nonEmpty) {
       val (_, depends) = pairStartStack.top
       depends += dependency
     }
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/opt/Inliner.scala b/src/compiler/scala/tools/nsc/backend/jvm/opt/Inliner.scala
index 954637fd83..34bb2c680c 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/opt/Inliner.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/opt/Inliner.scala
@@ -359,7 +359,7 @@ abstract class Inliner {
             state.illegalAccessInstructions += instructionMap(ins)
           }
           val callInsn = r.callsite.callsiteInstruction
-          state.illegalAccessInstructions.remove(callInsn)
+          state.illegalAccessInstructions.subtractOne(callInsn)
           if (state.illegalAccessInstructions.isEmpty)
             state.undoLog = NoUndoLogging
           state.inlineLog.logSuccess(r, sizeBefore, method.instructions.size, state.outerCallsite(r.callsite.callsiteInstruction))
@@ -664,7 +664,7 @@ abstract class Inliner {
         BackendUtils.clearDceDone(methodNode)
         callGraph.refresh(methodNode, ownerClass)
 
-        onIndyLambdaImplMethodIfPresent(ownerClass.internalName)(_.remove(methodNode))
+        onIndyLambdaImplMethodIfPresent(ownerClass.internalName)(_.subtractOne(methodNode))
         if (currentIndyLambdaBodyMethods.nonEmpty)
           onIndyLambdaImplMethod(ownerClass.internalName)(ms => ms(methodNode) = mutable.Map.empty ++= currentIndyLambdaBodyMethods)
       }
diff --git a/src/compiler/scala/tools/nsc/backend/jvm/opt/LocalOpt.scala b/src/compiler/scala/tools/nsc/backend/jvm/opt/LocalOpt.scala
index f318b878d8..5c62f560de 100644
--- a/src/compiler/scala/tools/nsc/backend/jvm/opt/LocalOpt.scala
+++ b/src/compiler/scala/tools/nsc/backend/jvm/opt/LocalOpt.scala
@@ -584,7 +584,7 @@ abstract class LocalOpt {
     while (top != -1) {
       val insnIndex = deq()
       val insn = method.instructions.get(insnIndex)
-      visited.add(insnIndex)
+      visited.addOne(insnIndex)
 
       if (insn.getOpcode == -1) { // frames, labels, line numbers
         enqInsnIndex(insnIndex + 1)
@@ -1019,7 +1019,7 @@ object LocalOptImpls {
     }
 
     def removeJumpFromMap(jump: JumpInsnNode) = {
-      jumpInsns.remove(jump)
+      jumpInsns.subtractOne(jump)
       _jumpTargets = null
     }
 
diff --git a/src/compiler/scala/tools/nsc/classpath/ZipAndJarFileLookupFactory.scala b/src/compiler/scala/tools/nsc/classpath/ZipAndJarFileLookupFactory.scala
index fcf73b72cb..cb8972aae5 100644
--- a/src/compiler/scala/tools/nsc/classpath/ZipAndJarFileLookupFactory.scala
+++ b/src/compiler/scala/tools/nsc/classpath/ZipAndJarFileLookupFactory.scala
@@ -119,7 +119,7 @@ object ZipAndJarClassPathFactory extends ZipAndJarFileLookupFactory {
             case pkgFile :: rest =>
               val subpackages = getSubpackages(pkgFile)
               val fullPkgName = packagePrefix + pkgFile.name
-              packages.put(fullPkgName, PackageFileInfo(pkgFile, subpackages))
+              packages.update(fullPkgName, PackageFileInfo(pkgFile, subpackages))
               val newPackagePrefix = fullPkgName + "."
               subpackagesQueue.enqueue(PackageInfo(newPackagePrefix, subpackages))
               loop(rest)
@@ -128,7 +128,7 @@ object ZipAndJarClassPathFactory extends ZipAndJarFileLookupFactory {
           loop(filesForPrefix)
         }
       val subpackages = getSubpackages(file)
-      packages.put(ClassPath.RootPackage, PackageFileInfo(file, subpackages))
+      packages.update(ClassPath.RootPackage, PackageFileInfo(file, subpackages))
       val infos = mutable.Queue(PackageInfo(ClassPath.RootPackage, subpackages))
       traverse(infos)
       packages
@@ -225,7 +225,7 @@ final class FileBasedCache[K, T] {
                       override def run(): Unit = {
                         cache.synchronized {
                           if (e.referenceCount.compareAndSet(0, -1)) {
-                            cache.remove(key)
+                            cache.subtractOne(key)
                             cl.close()
                           }
                         }
@@ -294,7 +294,7 @@ final class FileBasedCache[K, T] {
           }
           val value = create()
           val entry = Entry(k, stamps, value)
-          cache.put(key, entry)
+          cache.update(key, entry)
           closeableRegistry.registerCloseable(referenceCountDecrementer(entry, key))
           value
         }
@@ -302,7 +302,7 @@ final class FileBasedCache[K, T] {
         // Cache miss
         val value = create()
         val entry = Entry(k, stamps, value)
-        cache.put(key, entry)
+        cache.update(key, entry)
         closeableRegistry.registerCloseable(referenceCountDecrementer(entry, key))
         value
     }
diff --git a/src/compiler/scala/tools/nsc/io/Jar.scala b/src/compiler/scala/tools/nsc/io/Jar.scala
index 12b6d90925..6e25ade030 100644
--- a/src/compiler/scala/tools/nsc/io/Jar.scala
+++ b/src/compiler/scala/tools/nsc/io/Jar.scala
@@ -64,9 +64,9 @@ class Jar(file: File) extends AbstractIterable[JarEntry] {
       jarFile getEntry name match {
         case null   => f(None)
         case entry  =>
-          val in = Some(jarFile getInputStream entry)
+          val in = Some(jarFile.getInputStream(entry))
           try f(in)
-          finally in map (_.close())
+          finally in.foreach(_.close())
       }
     try apply() finally jarFile.close()
   }
diff --git a/src/compiler/scala/tools/nsc/reporters/PrintReporter.scala b/src/compiler/scala/tools/nsc/reporters/PrintReporter.scala
index d09e2cb909..3d7a0175d9 100644
--- a/src/compiler/scala/tools/nsc/reporters/PrintReporter.scala
+++ b/src/compiler/scala/tools/nsc/reporters/PrintReporter.scala
@@ -54,19 +54,13 @@ trait PrintReporter extends internal.Reporter {
 
   /** Format a message and emit it. */
   protected def display(pos: Position, msg: String, severity: Severity): Unit = {
-    val text = formatMessage(pos, s"${clabel(severity)}${postProcess(msg)}", shortname)
+    val text = formatMessage(pos, s"${clabel(severity)}${msg}", shortname)
     severity match {
       case internal.Reporter.INFO => echoMessage(text)
       case _                      => printMessage(text)
     }
   }
 
-  /** Postprocess a message string for reporting.
-   *
-   *  The default implementation uses `Reporter.explanation` to include the explanatory addendum.
-   */
-  protected def postProcess(msg: String): String = Reporter.explanation(msg)
-
   def displayPrompt(): Unit = {
     writer.println()
     writer.print("a)bort, s)tack, r)esume: ")
diff --git a/src/compiler/scala/tools/nsc/reporters/Reporter.scala b/src/compiler/scala/tools/nsc/reporters/Reporter.scala
index 9510d87802..aa8cd85c80 100644
--- a/src/compiler/scala/tools/nsc/reporters/Reporter.scala
+++ b/src/compiler/scala/tools/nsc/reporters/Reporter.scala
@@ -55,32 +55,6 @@ object Reporter {
     val loader = new ClassLoader(getClass.getClassLoader) with ScalaClassLoader
     loader.create[FilteringReporter](settings.reporter.value, settings.errorFn)(settings)
   }
-
-  /** Take the message with its explanation, if it has one, but stripping the separator line.
-   */
-  def explanation(msg: String): String =
-    if (msg == null) {
-      msg
-    } else {
-      val marker = msg.indexOf("\n----\n")
-      if (marker > 0) msg.substring(0, marker + 1) + msg.substring(marker + 6) else msg
-    }
-
-  /** Drop any explanation from the message, including the newline between the message and separator line.
-   */
-  def stripExplanation(msg: String): String =
-    if (msg == null) {
-      msg
-    } else {
-      val marker = msg.indexOf("\n----\n")
-      if (marker > 0) msg.substring(0, marker) else msg
-    }
-
-  /** Split the message into main message and explanation, as iterators of the text. */
-  def splitExplanation(msg: String): (Iterator[String], Iterator[String]) = {
-    val (err, exp) = msg.linesIterator.span(!_.startsWith("----"))
-    (err, exp.drop(1))
-  }
 }
 
 /** The reporter used in a Global instance.
@@ -150,12 +124,17 @@ abstract class FilteringReporter extends Reporter {
       }
       if (show) {
         positions(fpos) = severity
-        messages(fpos) ::= Reporter.stripExplanation(msg) // ignore explanatory suffix for suppressing duplicates
+        messages(fpos) ::= stripQuickfixable(msg)
       }
       show
     }
   }
 
+  private def stripQuickfixable(msg: String): String = {
+    val i = msg.indexOf(" [quickfixable]")
+    if (i > 0) msg.substring(0, i) else msg
+  }
+
   override def reset(): Unit = {
     super.reset()
     positions.clear()
diff --git a/src/compiler/scala/tools/nsc/settings/StandardScalaSettings.scala b/src/compiler/scala/tools/nsc/settings/StandardScalaSettings.scala
index 4b798e0eb5..26457abeda 100644
--- a/src/compiler/scala/tools/nsc/settings/StandardScalaSettings.scala
+++ b/src/compiler/scala/tools/nsc/settings/StandardScalaSettings.scala
@@ -51,6 +51,24 @@ trait StandardScalaSettings { _: MutableSettings =>
   val nowarn =         BooleanSetting ("-nowarn", "Generate no warnings.") withAbbreviation "--no-warnings" withPostSetHook { s => if (s.value) maxwarns.value = 0 }
   val optimise:        BooleanSetting // depends on post hook which mutates other settings
   val print =          BooleanSetting ("-print", "Print program with Scala-specific features removed.") withAbbreviation "--print"
+  val quickfix =       MultiStringSetting(
+    "-quickfix",
+    "filters",
+    "Apply quick fixes provided by the compiler for warnings and errors to source files",
+    helpText = Some(
+      """Apply quick fixes provided by the compiler for warnings and errors to source files.
+        |Syntax: -quickfix:<filter>,...,<filter>
+        |
+        |<filter> syntax is the same as for configurable warnings, see `-Wconf:help`. Examples:
+        |  -quickfix:any                    apply all available quick fixes
+        |  -quickfix:msg=Auto-application   apply quick fixes where the message contains "Auto-application"
+        |
+        |Use `-Wconf:any:warning-verbose` to display applicable message filters with each warning.
+        |
+        |Use `-quickfix:silent` to omit the `[quickfixable]` tag in compiler messages.
+        |""".stripMargin),
+    prepend = true)
+  def quickFixSilent: Boolean = quickfix.value == List("silent")
   val release =
     ChoiceSetting("-release", "release", "Compile for a version of the Java API and target class file.", AllTargetVersions, normalizeTarget(javaSpecVersion))
       .withPostSetHook { setting =>
diff --git a/src/compiler/scala/tools/nsc/transform/CleanUp.scala b/src/compiler/scala/tools/nsc/transform/CleanUp.scala
index 60758c58c5..260053b69c 100644
--- a/src/compiler/scala/tools/nsc/transform/CleanUp.scala
+++ b/src/compiler/scala/tools/nsc/transform/CleanUp.scala
@@ -15,7 +15,7 @@ package transform
 
 import symtab._
 import Flags._
-import scala.collection._
+import scala.collection.mutable, mutable.{Buffer, ListBuffer}
 import scala.tools.nsc.Reporting.WarningCategory
 import scala.util.chaining._
 
@@ -35,8 +35,8 @@ abstract class CleanUp extends Statics with Transform with ast.TreeDSL {
     new CleanUpTransformer(unit)
 
   class CleanUpTransformer(unit: CompilationUnit) extends StaticsTransformer {
-    private val newStaticMembers      = mutable.Buffer.empty[Tree]
-    private val newStaticInits        = mutable.Buffer.empty[Tree]
+    private val newStaticMembers      = Buffer.empty[Tree]
+    private val newStaticInits        = Buffer.empty[Tree]
     private val symbolsStoredAsStatic = mutable.Map.empty[String, Symbol]
     private var transformListApplyLimit = 8
     private def reducingTransformListApply[A](depth: Int)(body: => A): A = {
@@ -438,7 +438,7 @@ abstract class CleanUp extends Statics with Transform with ast.TreeDSL {
          * resulting switch may need to correspond to a single case body.
          */
 
-        val labels = mutable.ListBuffer.empty[LabelDef]
+        val labels = ListBuffer.empty[LabelDef]
         var defaultCaseBody = Throw(New(MatchErrorClass.tpe_*, selArg)): Tree
 
         def LABEL(name: String) = currentOwner.newLabel(unit.freshTermName(name), swPos).setFlag(SYNTH_CASE_FLAGS)
@@ -523,7 +523,7 @@ abstract class CleanUp extends Statics with Transform with ast.TreeDSL {
               gen.evalOnce(classTagEvidence, currentOwner, unit) { ev =>
                 val arr = typedWithPos(tree.pos)(gen.mkMethodCall(classTagEvidence, definitions.ClassTagClass.info.decl(nme.newArray), Nil, Literal(Constant(elems.size)) :: Nil))
                 gen.evalOnce(arr, currentOwner, unit) { arr =>
-                  val stats = mutable.ListBuffer[Tree]()
+                  val stats = ListBuffer[Tree]()
                   foreachWithIndex(elems) { (elem, i) =>
                     stats += gen.mkMethodCall(gen.mkAttributedRef(definitions.ScalaRunTimeModule), currentRun.runDefinitions.arrayUpdateMethod,
                                               Nil, arr() :: Literal(Constant(i)) :: elem :: Nil)
diff --git a/src/compiler/scala/tools/nsc/transform/Delambdafy.scala b/src/compiler/scala/tools/nsc/transform/Delambdafy.scala
index 649f2f58ff..30cb0abbf6 100644
--- a/src/compiler/scala/tools/nsc/transform/Delambdafy.scala
+++ b/src/compiler/scala/tools/nsc/transform/Delambdafy.scala
@@ -15,7 +15,7 @@ package transform
 
 import symtab._
 import Flags._
-import scala.collection._
+import scala.collection.mutable
 
 /**
   * This transformer is responsible for preparing Function nodes for runtime,
@@ -68,7 +68,7 @@ abstract class Delambdafy extends Transform with TypingTransformers with ast.Tre
   class DelambdafyTransformer(unit: CompilationUnit) extends TypingTransformer(unit) {
     // we need to know which methods refer to the 'this' reference so that we can determine which lambdas need access to it
     // TODO: this looks expensive, so I made it a lazy val. Can we make it more pay-as-you-go / optimize for common shapes?
-    private[this] lazy val methodReferencesThis: Set[Symbol] =
+    private[this] lazy val methodReferencesThis: collection.Set[Symbol] =
       (new ThisReferringMethodsTraverser).methodReferencesThisIn(unit.body)
 
     private def mkLambdaMetaFactoryCall(fun: Function, target: Symbol, functionalInterface: Symbol, samUserDefined: Symbol, userSamCls: Symbol, isSpecialized: Boolean): Tree = {
@@ -360,12 +360,12 @@ abstract class Delambdafy extends Transform with TypingTransformers with ast.Tre
   // finds all methods that reference 'this'
   class ThisReferringMethodsTraverser extends InternalTraverser {
     // the set of methods that refer to this
-    private val thisReferringMethods = mutable.Set[Symbol]()
+    private val thisReferringMethods = mutable.Set.empty[Symbol]
 
     // the set of lifted lambda body methods that each method refers to
-    private val liftedMethodReferences = mutable.Map[Symbol, mutable.Set[Symbol]]()
+    private val liftedMethodReferences = mutable.Map.empty[Symbol, mutable.Set[Symbol]]
 
-    def methodReferencesThisIn(tree: Tree) = {
+    def methodReferencesThisIn(tree: Tree): collection.Set[Symbol] = {
       traverse(tree)
       liftedMethodReferences.keys foreach refersToThis
 
diff --git a/src/compiler/scala/tools/nsc/transform/Fields.scala b/src/compiler/scala/tools/nsc/transform/Fields.scala
index 1ffef3ed8e..6b6f9aa8f5 100644
--- a/src/compiler/scala/tools/nsc/transform/Fields.scala
+++ b/src/compiler/scala/tools/nsc/transform/Fields.scala
@@ -187,8 +187,8 @@ abstract class Fields extends InfoTransform with ast.TreeDSL with TypingTransfor
   // (in traits, getters must also hold annotations that target the underlying field,
   //  because the latter won't be created until the trait is mixed into a class)
   // TODO do bean getters need special treatment to suppress field-targeting annotations in traits?
-  def dropFieldAnnotationsFromGetter(sym: Symbol) =
-    sym setAnnotations (sym.annotations filter AnnotationInfo.mkFilter(GetterTargetClass, defaultRetention = false))
+  def dropFieldAnnotationsFromGetter(sym: Symbol): Unit =
+    sym.setAnnotations(sym.annotations.filter(AnnotationInfo.mkFilter(GetterTargetClass, defaultRetention = false)))
 
   def symbolAnnotationsTargetFieldAndGetter(sym: Symbol): Boolean = sym.isGetter && (sym.isLazy || sym.owner.isTrait)
 
diff --git a/src/compiler/scala/tools/nsc/transform/async/AnfTransform.scala b/src/compiler/scala/tools/nsc/transform/async/AnfTransform.scala
index 9d5449e1f8..f5be70eb7c 100644
--- a/src/compiler/scala/tools/nsc/transform/async/AnfTransform.scala
+++ b/src/compiler/scala/tools/nsc/transform/async/AnfTransform.scala
@@ -269,7 +269,8 @@ private[async] trait AnfTransform extends TransformUtils {
           onTail(ts)
         case i =>
           val group = new Array[T](i + 1)
-          ts.copyToArray(group)
+          @annotation.unused val copied = ts.copyToArray(group)
+          //assert(copied == group.length, s"$copied != ${group.length}")
           onGroup(group)
           foreachGroupsEndingWith(ts.drop(i + 1))(isGroupEnd, onGroup, onTail)
       }
diff --git a/src/compiler/scala/tools/nsc/transform/async/AsyncNames.scala b/src/compiler/scala/tools/nsc/transform/async/AsyncNames.scala
index 82fd4dc35a..bc8b1ca175 100644
--- a/src/compiler/scala/tools/nsc/transform/async/AsyncNames.scala
+++ b/src/compiler/scala/tools/nsc/transform/async/AsyncNames.scala
@@ -70,7 +70,7 @@ final class AsyncNames[U <: reflect.internal.Names with Singleton](val u: U) {
       if (seenPrefixes.contains(name)) {
         TermName(freshNameCreator.newName(name.toStringWithSuffix("$")))
       } else {
-        seenPrefixes.add(name)
+        seenPrefixes.addOne(name)
         name
       }
     }
@@ -78,7 +78,7 @@ final class AsyncNames[U <: reflect.internal.Names with Singleton](val u: U) {
       if (seenPrefixes.contains(name)) {
         TypeName(freshNameCreator.newName(name.toStringWithSuffix("$")))
       } else {
-        seenPrefixes.add(name)
+        seenPrefixes.addOne(name)
         name
       }
     }
diff --git a/src/compiler/scala/tools/nsc/transform/async/ExprBuilder.scala b/src/compiler/scala/tools/nsc/transform/async/ExprBuilder.scala
index 6cc413eba2..d624f94f73 100644
--- a/src/compiler/scala/tools/nsc/transform/async/ExprBuilder.scala
+++ b/src/compiler/scala/tools/nsc/transform/async/ExprBuilder.scala
@@ -198,7 +198,7 @@ trait ExprBuilder extends TransformUtils with AsyncAnalysis {
 
     addStats()
 
-    private def addState(state: AsyncState): AsyncState = {
+    private def addState(state: AsyncState): state.type = {
       assert(building, "must be building to add state")
       assert(!statesMap.contains(state.state), "Duplicate state: " + state)
       statesMap(state.state) = state
@@ -490,7 +490,7 @@ trait ExprBuilder extends TransformUtils with AsyncAnalysis {
         val (initial :: Nil, rest) = all.partition(_.state == blockBuilder.startState): @unchecked
         val map = all.iterator.map(x => (x.state, x)).toMap
         val seen = mutable.HashSet[Int]()
-        seen.add(all.last.state)
+        seen.addOne(all.last.state)
         def followEmptyState(state: AsyncState): AsyncState = if (state.isEmpty && state.nextStates.size == 1) {
           val next = state.nextStates(0)
           if (next == blockBuilder.endState) state
@@ -506,7 +506,7 @@ trait ExprBuilder extends TransformUtils with AsyncAnalysis {
         }
         def loop(state: AsyncState): Unit = {
           if (!emptyReplacements.contains(state.state))
-            seen.add(state.state)
+            seen.addOne(state.state)
           for (i <- state.nextStates if !seen.contains(i) && i != StateAssigner.Terminal) {
             loop(map(i))
           }
diff --git a/src/compiler/scala/tools/nsc/transform/patmat/Logic.scala b/src/compiler/scala/tools/nsc/transform/patmat/Logic.scala
index b5ea1d2f91..e67726eef8 100644
--- a/src/compiler/scala/tools/nsc/transform/patmat/Logic.scala
+++ b/src/compiler/scala/tools/nsc/transform/patmat/Logic.scala
@@ -230,7 +230,8 @@ trait Logic extends Debugging {
           checkPair(a, b) || checkPair(a, c) || checkPair(b, c)
         } else {
           val ops = new Array[Prop](size)
-          ops0.copyToArray(ops)
+          @annotation.unused val copied = ops0.copyToArray(ops)
+          //assert(copied == ops.length, "")
           var i = 0
           val len = ops.length
           while (i < len - 1) {
diff --git a/src/compiler/scala/tools/nsc/transform/patmat/PatternExpansion.scala b/src/compiler/scala/tools/nsc/transform/patmat/PatternExpansion.scala
index de10983e95..0b6adebb89 100644
--- a/src/compiler/scala/tools/nsc/transform/patmat/PatternExpansion.scala
+++ b/src/compiler/scala/tools/nsc/transform/patmat/PatternExpansion.scala
@@ -241,7 +241,7 @@ trait PatternExpansion {
       val offeringString = if (isErroneous) "<error>" else productTypes match {
         case tps if isSeq => (tps.map(_.toString) :+ s"${elementType}*").mkString("(", ", ", ")")
         case Nil       => "Boolean"
-        case tp :: Nil => tp
+        case tp :: Nil => tp.toString
         case tps       => tps.mkString("(", ", ", ")")
       }
       val offerString = if (isErroneous) "" else s" offering $offeringString"
diff --git a/src/compiler/scala/tools/nsc/transform/patmat/Solving.scala b/src/compiler/scala/tools/nsc/transform/patmat/Solving.scala
index 28b60686c5..7a67b20b5b 100644
--- a/src/compiler/scala/tools/nsc/transform/patmat/Solving.scala
+++ b/src/compiler/scala/tools/nsc/transform/patmat/Solving.scala
@@ -356,7 +356,8 @@ trait Solving extends Logic {
           // scala/bug#6942:
           // CNF(P1 /\ ... /\ PN) == CNF(P1) ++ CNF(...) ++ CNF(PN)
           val cnfs = new Array[Solvable](props.size)
-          props.iterator.map(x => cnfFor(x)).copyToArray(cnfs)
+          @annotation.unused val copied = props.iterator.map(x => cnfFor(x)).copyToArray(cnfs)
+          //assert(copied == cnfs.length, "")
           new Solvable(cnfs.flatten[Clause](_.cnf, reflect.classTag[Clause]), cnfs.head.symbolMapping)
         case p          =>
           cnfFor(p)
diff --git a/src/compiler/scala/tools/nsc/typechecker/Adaptations.scala b/src/compiler/scala/tools/nsc/typechecker/Adaptations.scala
index cee889f74e..d46731c5bd 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Adaptations.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Adaptations.scala
@@ -98,9 +98,13 @@ trait Adaptations {
         if (settings.lintArgDiscard && discardedArgs) context.warning(t.pos, adaptWarningMessage(
           s"adapted the argument list to expected Unit type: arguments will be discarded"),
           WarningCategory.LintAdaptedArgs)
-        else if (settings.warnAdaptedArgs && !isInfix) context.warning(t.pos, adaptWarningMessage(
-          s"adapted the argument list to the expected ${args.size}-tuple: add additional parens instead"),
-          WarningCategory.LintAdaptedArgs)
+        else if (settings.warnAdaptedArgs && !isInfix) {
+          val msg = adaptWarningMessage(
+            s"adapted the argument list to the expected ${args.size}-tuple: add additional parens instead")
+          val pos = wrappingPos(args)
+          context.warning(t.pos, msg, WarningCategory.LintAdaptedArgs,
+            runReporting.codeAction("add wrapping parentheses", pos, s"(${currentUnit.sourceAt(pos)})", msg))
+        }
         true // keep adaptation
       }
       if (args.nonEmpty)
diff --git a/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala b/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala
index 1161a3cb40..4d79178498 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala
@@ -68,7 +68,7 @@ trait Analyzer extends AnyRef
           case ModuleDef(_, _, _) =>
             if (tree.symbol.name == nme.PACKAGEkw) {
               // we've actually got a source file
-              deferredOpen.remove(tree.symbol.owner)
+              deferredOpen.subtractOne(tree.symbol.owner)
 
               openPackageModule(tree.symbol, tree.symbol.owner)
             }
diff --git a/src/compiler/scala/tools/nsc/typechecker/ContextErrors.scala b/src/compiler/scala/tools/nsc/typechecker/ContextErrors.scala
index c6051f7a41..b242ce3d39 100644
--- a/src/compiler/scala/tools/nsc/typechecker/ContextErrors.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/ContextErrors.scala
@@ -59,7 +59,7 @@ trait ContextErrors extends splain.SplainErrors {
     def errPos = underlyingTree.pos
   }
 
-  case class NormalTypeError(underlyingTree: Tree, errMsg: String)
+  case class NormalTypeError(underlyingTree: Tree, errMsg: String, override val actions: List[CodeAction] = Nil)
     extends TreeTypeError
 
   case class AccessTypeError(underlyingTree: Tree, errMsg: String)
@@ -104,8 +104,8 @@ trait ContextErrors extends splain.SplainErrors {
     extends AbsTypeError
 
   object ErrorUtils {
-    def issueNormalTypeError(tree: Tree, msg: String)(implicit context: Context): Unit = {
-      issueTypeError(NormalTypeError(tree, msg))
+    def issueNormalTypeError(tree: Tree, msg: String, actions: List[CodeAction] = Nil)(implicit context: Context): Unit = {
+      issueTypeError(NormalTypeError(tree, msg, actions))
     }
 
     def issueSymbolTypeError(sym: Symbol, msg: String)(implicit context: Context): Unit = {
@@ -196,8 +196,14 @@ trait ContextErrors extends splain.SplainErrors {
         s"Implicit definition ${if (currentRun.isScala3) "must" else "should"} have explicit type${
           if (!inferred.isErroneous) s" (inferred $inferred)" else ""
         }"
-      if (currentRun.isScala3) cx.warning(tree.pos, msg, WarningCategory.Scala3Migration)
-      else cx.warning(tree.pos, msg, WarningCategory.OtherImplicitType)
+      // Assumption: tree.pos.focus points to the beginning of the name.
+      // DefTree doesn't give the name position; also it can be a synthetic accessor DefDef with only offset pos.
+      val namePos = tree.pos.focus.withEnd(tree.pos.point + tree.symbol.decodedName.length)
+      val action =
+        if (currentUnit.sourceAt(namePos) == tree.symbol.decodedName) runReporting.codeAction("insert explicit type", namePos.focusEnd, s": $inferred", msg)
+        else Nil
+      if (currentRun.isScala3) cx.warning(tree.pos, msg, WarningCategory.Scala3Migration, action)
+      else cx.warning(tree.pos, msg, WarningCategory.OtherImplicitType, action)
     }
     val sym = tree.symbol
     // Defer warning field of class until typing getter (which is marked implicit)
@@ -216,7 +222,7 @@ trait ContextErrors extends splain.SplainErrors {
     object TyperErrorGen {
       implicit val contextTyperErrorGen: Context = infer.getContext
 
-      def UnstableTreeError(tree: Tree) = {
+      def UnstableTreeError(tree: Tree): tree.type = {
         def addendum = {
           "\n Note that "+tree.symbol+" is not stable because its type, "+tree.tpe+", is volatile."
         }
@@ -502,7 +508,7 @@ trait ContextErrors extends splain.SplainErrors {
         //setError(sel)
       }
 
-      def SelectWithUnderlyingError(sel: Tree, err: AbsTypeError) = {
+      def SelectWithUnderlyingError(sel: Tree, err: AbsTypeError): sel.type = {
         // if there's no position, this is likely the result of a MissingRequirementError
         // use the position of the selection we failed to type check to report the original message
         if (err.errPos == NoPosition) issueNormalTypeError(sel, err.errMsg)
@@ -525,19 +531,6 @@ trait ContextErrors extends splain.SplainErrors {
         setError(tree)
       }
 
-      //typedEta
-      private def mkUnderscoreNullaryEtaMessage(what: String) =
-        s"Methods without a parameter list and by-name params can $what be converted to functions as `m _`, " +
-          "write a function literal `() => m` instead"
-
-      final val UnderscoreNullaryEtaWarnMsg  = mkUnderscoreNullaryEtaMessage("no longer")
-      final val UnderscoreNullaryEtaErrorMsg = mkUnderscoreNullaryEtaMessage("not")
-
-      def UnderscoreNullaryEtaError(tree: Tree) = {
-        issueNormalTypeError(tree, UnderscoreNullaryEtaErrorMsg)
-        setError(tree)
-      }
-
       def UnderscoreEtaError(tree: Tree) = {
         issueNormalTypeError(tree, "_ must follow method; cannot follow " + tree.tpe)
         setError(tree)
@@ -754,12 +747,12 @@ trait ContextErrors extends splain.SplainErrors {
       }
 
       //checkClassType
-      def TypeNotAStablePrefixError(tpt: Tree, pre: Type) = {
+      def TypeNotAStablePrefixError(tpt: Tree, pre: Type): tpt.type = {
         issueNormalTypeError(tpt, "type "+pre+" is not a stable prefix")
         setError(tpt)
       }
 
-      def ClassTypeRequiredError(tree: Tree, found: AnyRef) = {
+      def ClassTypeRequiredError(tree: Tree, found: AnyRef): tree.type = {
         issueNormalTypeError(tree, "class type required but "+found+" found")
         setError(tree)
       }
@@ -1168,7 +1161,7 @@ trait ContextErrors extends splain.SplainErrors {
           "\n --- because ---\n" + msg)
 
       // TODO: no test case
-      def NoConstructorInstanceError(tree: Tree, restpe: Type, pt: Type, msg: String) = {
+      def NoConstructorInstanceError(tree: Tree, restpe: Type, pt: Type, msg: String): Unit = {
         issueNormalTypeError(tree,
           "constructor of type " + restpe +
           " cannot be uniquely instantiated to expected type " + pt +
diff --git a/src/compiler/scala/tools/nsc/typechecker/Contexts.scala b/src/compiler/scala/tools/nsc/typechecker/Contexts.scala
index f729ec3567..5c921ca520 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Contexts.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Contexts.scala
@@ -162,7 +162,8 @@ trait Contexts { self: Analyzer =>
             // force package objects in prefixes
             def force(pkg: String, next: String): String = {
               val full = if (pkg.isEmpty) next else s"$pkg.$next"
-              getPackageIfDefined(full).tap(sym => if (sym != NoSymbol) openPackageModule(sym, force = true))
+              val sym = getPackageIfDefined(full)
+              if (sym != NoSymbol) openPackageModule(sym, force = true)
               full
             }
             name.split('.').toList.init.foldLeft("")(force)
@@ -420,9 +421,9 @@ trait Contexts { self: Analyzer =>
           val dictClass = {
             class DictionarySubstituter extends TreeSymSubstituter(preSyms, postSyms) {
               override def transform(tree: Tree): Tree = {
-                if(tree.hasExistingSymbol) {
+                if (tree.hasExistingSymbol) {
                   val sym = tree.symbol
-                  symMap.get(sym.owner).map(sym.owner = _)
+                  symMap.get(sym.owner).foreach(sym.owner = _)
                 }
                 super.transform(tree)
               }
@@ -1636,7 +1637,11 @@ trait Contexts { self: Analyzer =>
           done = (cx eq NoContext) || foundCompetingSymbol()
           if (!done && (cx ne NoContext)) cx = cx.outer
         }
-        if (defSym.exists && (defSym ne defSym0)) {
+        val nonOverlapping = defSym.exists && {
+          if (defSym.isOverloaded || defSym0.isOverloaded) !defSym.alternatives.exists(defSym0.alternatives.contains)
+          else defSym ne defSym0
+        }
+        if (nonOverlapping) {
           val ambiguity =
             if (preferDef) ambiguousDefinitions(defSym, defSym0, wasFoundInSuper, cx0.enclClass.owner, thisContext.enclClass.owner)
             else Some(ambiguousDefnAndImport(owner = defSym.owner, imp1))
@@ -1851,7 +1856,7 @@ trait Contexts { self: Analyzer =>
 
   private[typechecker] class ImmediateReporter(_errorBuffer: mutable.LinkedHashSet[AbsTypeError] = null, _warningBuffer: mutable.LinkedHashSet[ContextWarning] = null) extends ContextReporter(_errorBuffer, _warningBuffer) {
     override def makeBuffering: ContextReporter = new BufferingReporter(errorBuffer, warningBuffer)
-    def error(pos: Position, msg: String, actions: List[CodeAction]): Unit = reporter.error(pos, msg, actions)
+    def error(pos: Position, msg: String, actions: List[CodeAction]): Unit = runReporting.error(pos, msg, actions)
  }
 
   private[typechecker] class BufferingReporter(_errorBuffer: mutable.LinkedHashSet[AbsTypeError] = null, _warningBuffer: mutable.LinkedHashSet[ContextWarning] = null) extends ContextReporter(_errorBuffer, _warningBuffer) {
diff --git a/src/compiler/scala/tools/nsc/typechecker/Implicits.scala b/src/compiler/scala/tools/nsc/typechecker/Implicits.scala
index 3f937ecdad..7c858ad800 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Implicits.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Implicits.scala
@@ -25,7 +25,6 @@ import scala.language.implicitConversions
 import scala.reflect.internal.util.{ReusableInstance, Statistics, TriState}
 import scala.reflect.internal.TypesStats
 import scala.tools.nsc.Reporting.WarningCategory
-import scala.util.matching.Regex
 import symtab.Flags._
 
 /** This trait provides methods to find various kinds of implicits.
@@ -40,6 +39,7 @@ trait Implicits extends splain.SplainData {
   import statistics._
   import typingStack.printTyping
   import typeDebug._
+  import scala.util.matching.Regex.Match
 
   // standard usage
   def inferImplicitFor(pt: Type, tree: Tree, context: Context, reportAmbiguous: Boolean = true): SearchResult =
@@ -1828,14 +1828,15 @@ trait Implicits extends splain.SplainData {
   object ImplicitAmbiguousMsg extends ImplicitAnnotationMsg(_.implicitAmbiguousMsg, ImplicitAmbiguousClass, "implicitAmbiguous")
 
   class Message(sym: Symbol, msg: String, annotationName: String) {
+    import scala.util.matching.Regex.{quoteReplacement, Groups}
     // https://dcsobral.blogspot.com/2010/01/string-interpolation-in-scala-with.html
     private val Intersobralator = """\$\{\s*([^}\s]+)\s*\}""".r
 
     private def interpolate(text: String, vars: Map[String, String]) =
-      Intersobralator.replaceAllIn(text, (_: Regex.Match) match {
-        case Regex.Groups(v) => Regex.quoteReplacement(vars.getOrElse(v, ""))
+      Intersobralator.replaceAllIn(text, (_: Match) match {
+        case Groups(v) => quoteReplacement(vars.getOrElse(v, ""))
           // #3915: need to quote replacement string since it may include $'s (such as the interpreter's $iw)
-        case x               => throw new MatchError(x)
+        case x         => throw new MatchError(x)
       })
 
     def referencedTypeParams: List[String] = Intersobralator.findAllMatchIn(msg).map(_.group(1)).distinct.toList
diff --git a/src/compiler/scala/tools/nsc/typechecker/Infer.scala b/src/compiler/scala/tools/nsc/typechecker/Infer.scala
index 14a0dffd09..3a7a5ba2aa 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Infer.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Infer.scala
@@ -212,7 +212,7 @@ trait Infer extends Checkable {
     import InferErrorGen._
 
     /* -- Error Messages --------------------------------------------------- */
-    def setError[T <: Tree](tree: T): T = {
+    def setError[T <: Tree](tree: T): tree.type = {
       // scala/bug#7388, one can incur a cycle calling sym.toString
       // (but it'd be nicer if that weren't so)
       def name = {
@@ -599,7 +599,7 @@ trait Infer extends Checkable {
               if (!result && !seen(t)) t.dealiasWidenChain.foreach(saw)
             }
           }
-          @`inline` def containsAny(t: Type) = collector.collect(t)
+          @inline def containsAny(t: Type): Boolean = collector.collect(t)
           val hasAny = containsAny(pt) || containsAny(restpe) ||
             formals.exists(containsAny) ||
             argtpes.exists(containsAny) ||
@@ -1564,7 +1564,7 @@ trait Infer extends Checkable {
       def fail() = PolyAlternativeError(tree, argtypes, matchingLength, errorKind)
       def finish(sym: Symbol, tpe: Type) = tree setSymbol sym setType tpe
       // Alternatives which conform to bounds
-      def checkWithinBounds(sym: Symbol) = sym.alternatives match {
+      def checkWithinBounds(sym: Symbol): Unit = sym.alternatives match {
         case Nil if argtypes.exists(_.isErroneous) =>
         case Nil                                   => fail()
         case alt :: Nil                            => finish(alt, pre memberType alt)
diff --git a/src/compiler/scala/tools/nsc/typechecker/Namers.scala b/src/compiler/scala/tools/nsc/typechecker/Namers.scala
index 0069cb568e..2a554cfed7 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Namers.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Namers.scala
@@ -145,7 +145,7 @@ trait Namers extends MethodSynthesis {
       vd.mods.hasAllFlags(JAVA_ENUM | STABLE | STATIC) && ownerHasEnumFlag
     }
 
-    def setPrivateWithin[T <: Symbol](tree: Tree, sym: T, mods: Modifiers): T =
+    def setPrivateWithin[T <: Symbol](tree: Tree, sym: T, mods: Modifiers): sym.type =
       if (sym.isPrivateLocal) sym
       else {
         val qualClass = if (mods.hasAccessBoundary)
@@ -155,7 +155,7 @@ trait Namers extends MethodSynthesis {
         sym setPrivateWithin qualClass
       }
 
-    def setPrivateWithin(tree: MemberDef, sym: Symbol): Symbol =
+    def setPrivateWithin(tree: MemberDef, sym: Symbol): sym.type =
       setPrivateWithin(tree, sym, tree.mods)
 
     def inConstructorFlag: Long = {
@@ -174,7 +174,7 @@ trait Namers extends MethodSynthesis {
     def moduleClassFlags(moduleFlags: Long) =
       (moduleFlags & ModuleToClassFlags) | inConstructorFlag
 
-    def updatePosFlags(sym: Symbol, pos: Position, flags: Long): Symbol = {
+    def updatePosFlags(sym: Symbol, pos: Position, flags: Long): sym.type = {
       debuglog("[overwrite] " + sym)
       val newFlags = (sym.flags & LOCKED) | flags
       // !!! needed for: pos/t5954d; the uniques type cache will happily serve up the same TypeRef
@@ -235,10 +235,10 @@ trait Namers extends MethodSynthesis {
     }
 
     /** Enter symbol into context's scope and return symbol itself */
-    def enterInScope(sym: Symbol): Symbol = enterInScope(sym, context.scope)
+    def enterInScope(sym: Symbol): sym.type = enterInScope(sym, context.scope)
 
     /** Enter symbol into given scope and return symbol itself */
-    def enterInScope(sym: Symbol, scope: Scope): Symbol = {
+    def enterInScope(sym: Symbol, scope: Scope): sym.type = {
       // FIXME - this is broken in a number of ways.
       //
       // 1) If "sym" allows overloading, that is not itself sufficient to skip
@@ -451,12 +451,11 @@ trait Namers extends MethodSynthesis {
       }
     }
 
-    def enterModuleDef(tree: ModuleDef) = {
+    def enterModuleDef(tree: ModuleDef): Unit = {
       val sym = enterModuleSymbol(tree)
       sym.moduleClass setInfo namerOf(sym).moduleClassTypeCompleter(tree)
       sym setInfo completerOf(tree)
       validateCompanionDefs(tree)
-      sym
     }
 
     /** Enter a module symbol.
@@ -489,7 +488,7 @@ trait Namers extends MethodSynthesis {
       m
     }
 
-    def enterSyms(trees: List[Tree]): Namer =
+    def enterSyms(trees: List[Tree]): Unit =
       trees.foldLeft(this: Namer) { (namer, t) =>
         val ctx = namer enterSym t
         // for Import trees, enterSym returns a changed context, so we need a new namer
@@ -693,7 +692,7 @@ trait Namers extends MethodSynthesis {
             // There are two ways in which we exclude the symbol from being added in typedStats::addSynthetics,
             // because we don't know when the completer runs with respect to this loop in addSynthetics
             //  for (sym <- scope)
-            //    for (tree <- context.unit.synthetics.get(sym) if shouldAdd(sym)) {
+            //    for (tree <- context.unit.synthetics.get(sym) if shouldAdd(sym))
             //      if (!sym.initialize.hasFlag(IS_ERROR))
             //        newStats += typedStat(tree)
             // If we're already in the loop, set the IS_ERROR flag and trigger the condition `sym.initialize.hasFlag(IS_ERROR)`
@@ -730,7 +729,7 @@ trait Namers extends MethodSynthesis {
         /* @M! TypeDef's type params are handled differently, e.g., in `type T[A[x <: B], B]`, A and B are entered
          * first as both are in scope in the definition of x. x is only in scope in `A[x <: B]`.
          * No symbols are created for the abstract type's params at this point, i.e. the following assertion holds:
-         *     !tree.symbol.isAbstractType || { tparams.forall(_.symbol == NoSymbol)
+         *     !tree.symbol.isAbstractType || tparams.forall(_.symbol == NoSymbol)
          * (tested with the above example, `trait C { type T[A[X <: B], B] }`). See also comment in PolyTypeCompleter.
          */
         if (!tree.symbol.isAbstractType) //@M TODO: change to isTypeMember ?
@@ -767,7 +766,7 @@ trait Namers extends MethodSynthesis {
       tree.symbol = sym
     }
 
-    def enterTypeDef(tree: TypeDef) = assignAndEnterFinishedSymbol(tree)
+    def enterTypeDef(tree: TypeDef): Unit = assignAndEnterFinishedSymbol(tree)
 
     def enterDefDef(tree: DefDef): Unit = {
       tree match {
@@ -1155,7 +1154,12 @@ trait Namers extends MethodSynthesis {
             val pts = pt.toString
             val leg = legacy.toString
             val help = if (pts != leg) s" instead of $leg" else ""
-            runReporting.warning(tree.pos, s"under -Xsource:3, inferred $pts$help", WarningCategory.Scala3Migration, tree.symbol)
+            val msg = s"under -Xsource:3, inferred $pts$help"
+            val namePos = tree.pos.focus.withEnd(tree.pos.point + tree.symbol.decodedName.length)
+            val action =
+              if (currentUnit.sourceAt(namePos) == tree.symbol.decodedName) runReporting.codeAction("add explicit type", namePos.focusEnd, s": $leg", msg)
+              else Nil
+            runReporting.warning(tree.pos, msg, WarningCategory.Scala3Migration, tree.symbol, action)
           }
           pt
         }
diff --git a/src/compiler/scala/tools/nsc/typechecker/RefChecks.scala b/src/compiler/scala/tools/nsc/typechecker/RefChecks.scala
index 50660058f7..d13adfd8d2 100644
--- a/src/compiler/scala/tools/nsc/typechecker/RefChecks.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/RefChecks.scala
@@ -15,6 +15,7 @@ package typechecker
 
 import scala.collection.mutable
 import scala.collection.mutable.ListBuffer
+import scala.reflect.internal.util.CodeAction
 import scala.tools.nsc.Reporting.WarningCategory
 import scala.tools.nsc.settings.ScalaVersion
 import scala.tools.nsc.settings.NoScalaVersion
@@ -79,6 +80,7 @@ abstract class RefChecks extends Transform {
   }
 
   class RefCheckTransformer(unit: CompilationUnit) extends AstTransformer {
+    private final val indent = "  "
 
     var localTyper: analyzer.Typer = typer
     var currentApplication: Tree = EmptyTree
@@ -103,8 +105,8 @@ abstract class RefChecks extends Transform {
       !seen
     }
 
-    private def refchecksWarning(pos: Position, msg: String, cat: WarningCategory): Unit =
-      runReporting.warning(pos, msg, cat, currentOwner)
+    private def refchecksWarning(pos: Position, msg: String, cat: WarningCategory, actions: List[CodeAction] = Nil): Unit =
+      runReporting.warning(pos, msg, cat, currentOwner, actions)
 
     // only one overloaded alternative is allowed to define default arguments
     private def checkOverloadedRestrictions(clazz: Symbol, defaultClass: Symbol): Unit = {
@@ -251,21 +253,27 @@ abstract class RefChecks extends Transform {
     private def checkAllOverrides(clazz: Symbol, typesOnly: Boolean = false): Unit = {
       val self = clazz.thisType
 
-      case class MixinOverrideError(member: Symbol, msg: String)
+      case class MixinOverrideError(member: Symbol, msg: String, actions: List[CodeAction], s3Migration: Boolean)
 
       val mixinOverrideErrors = new ListBuffer[MixinOverrideError]()
 
+      def issue(pos: Position, msg: String, actions: List[CodeAction], s3Migration: Boolean) =
+        if (s3Migration) runReporting.warning(pos, msg, WarningCategory.Scala3Migration, currentOwner, actions)
+        else runReporting.error(pos, msg, actions)
+
       def printMixinOverrideErrors(): Unit = {
         mixinOverrideErrors.toList match {
           case List() =>
-          case List(MixinOverrideError(_, msg)) =>
-            reporter.error(clazz.pos, msg)
-          case MixinOverrideError(member, msg) :: others =>
+          case List(MixinOverrideError(_, msg, actions, s3Migration)) =>
+            issue(clazz.pos, msg, actions, s3Migration)
+          case MixinOverrideError(member, msg, actions, s3Migration) :: others =>
             val others1 = others.map(_.member.name.decode).filter(member.name.decode != _).distinct
-            reporter.error(
+            issue(
               clazz.pos,
-              msg+(if (others1.isEmpty) ""
-                   else ";\n other members with override errors are: "+(others1 mkString ", ")))
+              if (others1.isEmpty) msg
+              else s"$msg;\n other members with override errors are: ${others1.mkString(", ")}",
+              actions,
+              s3Migration)
         }
       }
 
@@ -296,63 +304,74 @@ abstract class RefChecks extends Transform {
         val memberClass = member.owner
         val otherClass = other.owner
 
-        //        debuglog(s"Checking validity of ${member.fullLocationString} overriding ${other.fullLocationString}")
+        // debuglog(s"Checking validity of ${member.fullLocationString} overriding ${other.fullLocationString}")
 
         def noErrorType = !pair.isErroneous
         def isRootOrNone(sym: Symbol) = sym != null && sym.isRoot || sym == NoSymbol
-        def isNeitherInClass = memberClass != clazz && otherClass != clazz
+        val isMemberClass = memberClass == clazz
+        def isNeitherInClass = !isMemberClass && otherClass != clazz
+
+        /** Emit an error if member is owned by current class, using the member position.
+         *  Otherwise, accumulate the error, to be emitted after other messages, using the class position.
+         */
+        def emitOverrideError(fullmsg: String, actions: List[CodeAction] = Nil, s3Migration: Boolean = false): Unit =
+          if (isMemberClass) issue(member.pos, fullmsg, actions, s3Migration)
+          else mixinOverrideErrors += MixinOverrideError(member, fullmsg, actions, s3Migration)
 
-        val indent = "  "
         def overriddenWithAddendum(msg: String, foundReq: Boolean = settings.isDebug): String = {
           val isConcreteOverAbstract =
-            (otherClass isSubClass memberClass) && other.isDeferred && !member.isDeferred
+            otherClass.isSubClass(memberClass) && other.isDeferred && !member.isDeferred
           val addendum =
             if (isConcreteOverAbstract)
-              s";\n${indent}(note that ${infoStringWithLocation(other)} is abstract,\n" +
-              s"${indent}and is therefore overridden by concrete ${infoStringWithLocation(member)})"
+              sm"""|;
+                   |${indent}(note that ${infoStringWithLocation(other)} is abstract,
+                   |${indent}and is therefore overridden by concrete ${infoStringWithLocation(member)})"""
             else if (foundReq) {
               def info(sym: Symbol) = self.memberInfo(sym) match { case tp if sym.isGetter || sym.isValue && !sym.isMethod => tp.resultType case tp => tp }
               analyzer.foundReqMsg(info(member), info(other))
             }
             else ""
+          val msg1 = if (!msg.isEmpty) s"\n$indent$msg" else msg
 
-          infoStringWithLocation(other) + (if (msg.isEmpty) "" else s"\n$indent") + msg + addendum
+          s"${infoStringWithLocation(other)}${msg1}${addendum}"
         }
-        def emitOverrideError(fullmsg: String): Unit = {
-          if (memberClass == clazz) reporter.error(member.pos, fullmsg)
-          else mixinOverrideErrors += MixinOverrideError(member, fullmsg)
-        }
-
-        def overrideErrorWithMemberInfo(msg: String): Unit =
-          if (noErrorType) emitOverrideError(msg + "\n" + overriddenWithAddendum(if (member.owner == clazz) "" else s"with ${infoString(member)}"))
 
         def overrideError(msg: String): Unit =
           if (noErrorType) emitOverrideError(msg)
 
-        def overrideTypeError(): Unit = {
+        def getWithIt = if (isMemberClass) "" else s"with ${infoString(member)}"
+
+        def overrideErrorWithMemberInfo(msg: String, actions: List[CodeAction] = Nil, s3Migration: Boolean = false): Unit =
+          if (noErrorType) emitOverrideError(s"${msg}\n${overriddenWithAddendum(getWithIt)}", actions, s3Migration)
+
+        def overrideErrorOrNullaryWarning(msg: String, actions: List[CodeAction]): Unit = if (isMemberClass || !member.owner.isSubClass(other.owner))
+          if (currentRun.isScala3)
+            overrideErrorWithMemberInfo(msg, actions, s3Migration = true)
+          else if (isMemberClass)
+            refchecksWarning(member.pos, msg, WarningCategory.OtherNullaryOverride, actions)
+          else
+            refchecksWarning(clazz.pos, msg, WarningCategory.OtherNullaryOverride, actions)
+
+        def overrideTypeError(): Unit =
           if (member.isModule && other.isModule)
-            overrideError(s"overriding ${other.fullLocationString} with ${member.fullLocationString}:\n" +
-                          "an overriding object must conform to the overridden object's class bound" +
-                          analyzer.foundReqMsg(pair.lowClassBound, pair.highClassBound))
+            overrideError(sm"""|overriding ${other.fullLocationString} with ${member.fullLocationString}:
+                               |an overriding object must conform to the overridden object's class bound${
+                                analyzer.foundReqMsg(pair.lowClassBound, pair.highClassBound)}""")
           else {
             val needSameType = !other.isDeferred && other.isAliasType
-            val msg =
-              (if (member.owner == clazz) "" else s"with ${infoString(member)}") +
-              (if (needSameType) " (Equivalent type required when overriding a type alias.)" else "")
-
-            overrideError("incompatible type in overriding\n" + overriddenWithAddendum(msg, foundReq = !needSameType))
+            val msg = s"${getWithIt}${if (needSameType) " (Equivalent type required when overriding a type alias.)" else ""}"
+            overrideError(sm"""|incompatible type in overriding
+                               |${overriddenWithAddendum(msg, foundReq = !needSameType)}""")
           }
-        }
 
-        def overrideErrorConcreteMissingOverride() = {
-          if (isNeitherInClass && !(otherClass isSubClass memberClass))
+        def overrideErrorConcreteMissingOverride() =
+          if (isNeitherInClass && !otherClass.isSubClass(memberClass))
             emitOverrideError(sm"""|$clazz inherits conflicting members:
                                    |$indent${infoStringWithLocation(other)} and
                                    |$indent${infoStringWithLocation(member)}
                                    |$indent(note: this can be resolved by declaring an `override` in $clazz.)""")
           else
             overrideErrorWithMemberInfo("`override` modifier required to override concrete member:")
-        }
 
         def weakerAccessError(advice: String): Unit =
           overrideError(sm"""|weaker access privileges in overriding
@@ -389,78 +408,93 @@ abstract class RefChecks extends Transform {
             !isRootOrNone(ob) && (ob.hasTransOwner(mb) || companionBoundaryOK)
           }
           @inline def otherIsJavaProtected = other.isJavaDefined && other.isProtected
-          def isOverrideAccessOK =
+          val isOverrideAccessOK =
             member.isPublic ||     // member is public, definitely same or relaxed access
             protectedOK &&         // if o is protected, so is m
             (accessBoundaryOK ||   // m relaxes o's access boundary
               otherIsJavaProtected // overriding a protected java member, see #3946 #12349
             )
-          if (!isOverrideAccessOK) {
+          if (!isOverrideAccessOK)
             overrideAccessError()
-          } else if (other.isClass) {
+          else if (other.isClass)
             overrideErrorWithMemberInfo("class definitions cannot be overridden:")
-          } else if (!other.isDeferred && member.isClass) {
+          else if (!other.isDeferred && member.isClass)
             overrideErrorWithMemberInfo("classes can only override abstract types; cannot override:")
-          } else if (other.isEffectivelyFinal) { // (1.2)
+          else if (other.isEffectivelyFinal) // (1.2)
             overrideErrorWithMemberInfo("cannot override final member:")
-          } else {
+          else {
             // In Java, the OVERRIDE flag is implied
             val memberOverrides = member.isAnyOverride || (member.isJavaDefined && !member.isDeferred)
 
             // Concrete `other` requires `override` for `member`.
-            // Synthetic exclusion for (at least) default getters, fixes scala/bug#5178. We cannot assign the OVERRIDE flag to
-            // the default getter: one default getter might sometimes override, sometimes not. Example in comment on ticket.
-            if (!(memberOverrides || other.isDeferred) && !member.isSynthetic) {
+            // Synthetic exclusion for (at least) default getters, fixes scala/bug#5178.
+            // We cannot assign the OVERRIDE flag to the default getter:
+            // one default getter might sometimes override, sometimes not. Example in comment on ticket.
+            if (!memberOverrides && !other.isDeferred && !member.isSynthetic)
               overrideErrorConcreteMissingOverride()
-            } else if (other.isAbstractOverride && other.isIncompleteIn(clazz) && !member.isAbstractOverride) {
+            else if (other.isAbstractOverride && other.isIncompleteIn(clazz) && !member.isAbstractOverride)
               overrideErrorWithMemberInfo("`abstract override` modifiers required to override:")
-            }
-            else if (memberOverrides && (other hasFlag ACCESSOR) && !(other hasFlag STABLE | DEFERRED)) {
+            else if (memberOverrides && other.hasFlag(ACCESSOR) && !other.hasFlag(STABLE | DEFERRED))
               // TODO: this is not covered by the spec.
               overrideErrorWithMemberInfo("mutable variable cannot be overridden:")
-            }
             else if (memberOverrides &&
-                     !(memberClass.thisType.baseClasses exists (_ isSubClass otherClass)) &&
+                     !memberClass.thisType.baseClasses.exists(_.isSubClass(otherClass)) &&
                      !member.isDeferred && !other.isDeferred &&
-                     intersectionIsEmpty(member.extendedOverriddenSymbols, other.extendedOverriddenSymbols)) {
+                     intersectionIsEmpty(member.extendedOverriddenSymbols, other.extendedOverriddenSymbols))
               overrideErrorWithMemberInfo("cannot override a concrete member without a third member that's overridden by both " +
                                           "(this rule is designed to prevent accidental overrides)")
-            } else if (other.isStable && !member.isStable) { // (1.4)
+            else if (other.isStable && !member.isStable) // (1.4)
               overrideErrorWithMemberInfo("stable, immutable value required to override:")
-            } else if (member.isValue && member.isLazy &&
-                       other.isValue && other.hasFlag(STABLE) && !(other.isDeferred || other.isLazy)) {
+            else if (member.isValue && member.isLazy &&
+                       other.isValue && other.hasFlag(STABLE) && !other.isDeferred && !other.isLazy)
               overrideErrorWithMemberInfo("concrete non-lazy value cannot be overridden:")
-            } else if (other.isValue && other.isLazy &&
-                       member.isValue && !member.isLazy) {
+            else if (other.isValue && other.isLazy && member.isValue && !member.isLazy)
               overrideErrorWithMemberInfo("value must be lazy when overriding concrete lazy value:")
-            } else if (other.isDeferred && member.isTermMacro && member.extendedOverriddenSymbols.forall(_.isDeferred)) { // (1.9)
+            else if (other.isDeferred && member.isTermMacro && member.extendedOverriddenSymbols.forall(_.isDeferred)) // (1.9)
               overrideErrorWithMemberInfo("macro cannot override abstract method:")
-            } else if (other.isTermMacro && !member.isTermMacro) { // (1.10)
+            else if (other.isTermMacro && !member.isTermMacro) // (1.10)
               overrideErrorWithMemberInfo("macro can only be overridden by another macro:")
-            } else {
+            else {
               checkOverrideTypes()
               // Don't bother users with deprecations caused by classes they inherit.
               // Only warn for the pair that has one leg in `clazz`.
-              if (clazz == memberClass) checkOverrideDeprecated()
+              if (isMemberClass) checkOverrideDeprecated()
               def javaDetermined(sym: Symbol) = sym.isJavaDefined || isUniversalMember(sym)
+              def exempted = javaDetermined(member) || javaDetermined(other) || member.overrides.exists(javaDetermined)
+              // warn that nilary member matched nullary other, so either it was adapted by namer or will be silently mixed in by mixin
+              def warnAdaptedNullaryOverride(): Unit = {
+                val named = if (isMemberClass) "" else s" (${member.fullLocationString})"
+                val msg = s"method$named without a parameter list overrides a method with a single empty one"
+                val namePos = member.pos
+                val action =
+                  if (namePos.isDefined && currentUnit.sourceAt(namePos) == member.decodedName)
+                    runReporting.codeAction("add empty parameter list", namePos.focusEnd, "()", msg)
+                  else Nil
+                overrideErrorOrNullaryWarning(msg, action)
+              }
+              def warnExtraParens(): Unit = {
+                val named = if (isMemberClass) "" else s" (${member.fullLocationString})"
+                val msg = s"method$named with a single empty parameter list overrides method without any parameter list"
+                val namePos = member.pos
+                val action =
+                  if (namePos.isDefined && currentUnit.sourceAt(namePos) == member.decodedName)
+                    runReporting.codeAction("remove empty parameter list", namePos.focusEnd.withEnd(namePos.end + 2), "", msg, expected = Some(("()", currentUnit)))
+                  else Nil
+                overrideErrorOrNullaryWarning(msg, action)
+              }
               if (member.hasAttachment[NullaryOverrideAdapted.type]) {
-                def exempt() = member.overrides.exists(sym => sym.isJavaDefined || isUniversalMember(sym))
-                val msg = "method without a parameter list overrides a method with a single empty one"
-                if (!exempt())
-                  if (currentRun.isScala3)
-                    overrideErrorWithMemberInfo(msg)
-                  else
-                    refchecksWarning(member.pos, msg, WarningCategory.OtherNullaryOverride)
+                if (!exempted)
+                  warnAdaptedNullaryOverride()
               }
-              else if (other.paramss.isEmpty && !member.paramss.isEmpty &&
-                !javaDetermined(member) && !member.overrides.exists(javaDetermined) &&
-                !member.hasAnnotation(BeanPropertyAttr) && !member.hasAnnotation(BooleanBeanPropertyAttr)
-              ) {
-                val msg = "method with a single empty parameter list overrides method without any parameter list"
-                if (currentRun.isScala3)
-                  overrideErrorWithMemberInfo(msg)
-                else
-                  refchecksWarning(member.pos, msg, WarningCategory.OtherNullaryOverride)
+              else if (member.paramLists.isEmpty) {
+                // NullaryOverrideAdapted is only added to symbols being compiled, so check for a mismatch
+                // if both symbols are mixed in from the classpath
+                if (!member.isStable && other.paramLists.nonEmpty && !exempted)
+                  warnAdaptedNullaryOverride()
+              }
+              else if (other.paramLists.isEmpty) {
+                if (!exempted && !member.hasAnnotation(BeanPropertyAttr) && !member.hasAnnotation(BooleanBeanPropertyAttr))
+                  warnExtraParens()
               }
             }
           }
@@ -1606,7 +1640,7 @@ abstract class RefChecks extends Transform {
         case tpt@TypeTree() =>
           if (tpt.original != null)
             tpt.original.foreach {
-              case dc@TypeTreeWithDeferredRefCheck() =>
+              case dc: TypeTreeWithDeferredRefCheck =>
                 applyRefchecksToAnnotations(dc.check()) // #2416
               case _ =>
             }
@@ -1741,8 +1775,15 @@ abstract class RefChecks extends Transform {
           || sym.allOverriddenSymbols.exists(over => !(over.tpe.resultType =:= sym.tpe.resultType))
           || sym.isArtifact
         )
-        if (!isOk)
-          refchecksWarning(sym.pos, s"side-effecting nullary methods are discouraged: suggest defining as `def ${sym.name.decode}()` instead", WarningCategory.LintNullaryUnit)
+        if (!isOk) {
+          val msg = s"side-effecting nullary methods are discouraged: suggest defining as `def ${sym.name.decode}()` instead"
+          val namePos = sym.pos.focus.withEnd(sym.pos.point + sym.decodedName.length)
+          val action =
+            if (currentUnit.sourceAt(namePos) == sym.decodedName)
+              runReporting.codeAction("add empty parameter list", namePos.focusEnd, "()", msg)
+            else Nil
+          refchecksWarning(sym.pos, msg, WarningCategory.LintNullaryUnit, action)
+        }
       case _ => ()
     }
 
@@ -1880,11 +1921,11 @@ abstract class RefChecks extends Transform {
               currentOwner.primaryConstructor makeNotPrivate NoSymbol // scala/bug#6601, must be done *after* pickler!
             if (bridges.nonEmpty) deriveTemplate(tree)(_ ::: bridges) else tree
 
-          case dc@TypeTreeWithDeferredRefCheck() => abort("adapt should have turned dc: TypeTreeWithDeferredRefCheck into tpt: TypeTree, with tpt.original == dc")
+          case _: TypeTreeWithDeferredRefCheck => abort("adapt should have turned dc: TypeTreeWithDeferredRefCheck into tpt: TypeTree, with tpt.original == dc")
           case tpt@TypeTree() =>
             if(tpt.original != null) {
               tpt.original foreach {
-                case dc@TypeTreeWithDeferredRefCheck() =>
+                case dc: TypeTreeWithDeferredRefCheck =>
                   transform(dc.check()) // #2416 -- only call transform to do refchecks, but discard results
                   // tpt has the right type if the deferred checks are ok
                 case _ =>
diff --git a/src/compiler/scala/tools/nsc/typechecker/StdAttachments.scala b/src/compiler/scala/tools/nsc/typechecker/StdAttachments.scala
index 88f96e34c4..7a920f2197 100644
--- a/src/compiler/scala/tools/nsc/typechecker/StdAttachments.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/StdAttachments.scala
@@ -88,11 +88,11 @@ trait StdAttachments {
 
   /** Suppresses macro expansion of the tree by putting SuppressMacroExpansionAttachment on it.
    */
-  def suppressMacroExpansion(tree: Tree) = tree.updateAttachment(SuppressMacroExpansionAttachment)
+  def suppressMacroExpansion(tree: Tree): tree.type = tree.updateAttachment(SuppressMacroExpansionAttachment)
 
   /** Unsuppresses macro expansion of the tree by removing SuppressMacroExpansionAttachment from it and its children.
    */
-  def unsuppressMacroExpansion(tree: Tree): Tree = {
+  def unsuppressMacroExpansion(tree: Tree): tree.type = {
     tree.removeAttachment[SuppressMacroExpansionAttachment.type]
     tree match {
       // see the comment to `isMacroExpansionSuppressed` to learn why we need
diff --git a/src/compiler/scala/tools/nsc/typechecker/TypeDiagnostics.scala b/src/compiler/scala/tools/nsc/typechecker/TypeDiagnostics.scala
index b4b6fa5dad..6459ddf770 100644
--- a/src/compiler/scala/tools/nsc/typechecker/TypeDiagnostics.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/TypeDiagnostics.scala
@@ -369,7 +369,7 @@ trait TypeDiagnostics extends splain.SplainDiagnostics {
     private val savedName = sym.name
     private var postQualifiedWith: List[Symbol] = Nil
     def restoreName()     = sym.name = savedName
-    def modifyName(f: String => String) = sym setName newTypeName(f(sym.name.toString))
+    def modifyName(f: String => String): Unit = sym setName newTypeName(f(sym.name.toString))
 
     // functions to manipulate the name
     def preQualify()   = modifyName(trueOwner.fullName + "." + _)
@@ -550,21 +550,30 @@ trait TypeDiagnostics extends splain.SplainDiagnostics {
               else if (!sym.isConstructor && !sym.isVar && !isTrivial(rhs))
                 for (vs <- vparamss) params ++= vs.map(_.symbol)
               defnTrees += m
+            case TypeDef(mods@_, name@_, tparams@_, rhs@_) =>
+              if (!sym.isAbstract && !sym.isDeprecated)
+                defnTrees += m
             case _ =>
               defnTrees += m
-        }
+          }
         case CaseDef(pat, guard@_, rhs@_) if settings.warnUnusedPatVars && !t.isErrorTyped =>
           pat.foreach {
             case b @ Bind(n, _) if !atBounded(b) && n != nme.DEFAULT_CASE => patvars += b.symbol
             case _ =>
-        }
+          }
         case _: RefTree if isExisting(sym)            => targets += sym
         case Assign(lhs, _) if isExisting(lhs.symbol) => setVars += lhs.symbol
         case Function(ps, _) if settings.warnUnusedParams && !t.isErrorTyped => params ++=
           ps.filterNot(p => atBounded(p) || p.symbol.isSynthetic).map(_.symbol)
         case Literal(_) =>
           t.attachments.get[OriginalTreeAttachment].foreach(ota => traverse(ota.original))
-        case _                                        =>
+        case tt: TypeTree =>
+          tt.original match {
+            case null =>
+            case xo if xo ne tt => traverse(xo)
+            case _ =>
+          }
+        case _ =>
       }
 
       if (t.tpe ne null) {
@@ -764,7 +773,7 @@ trait TypeDiagnostics extends splain.SplainDiagnostics {
             if (s.name.startsWith(nme.EVIDENCE_PARAM_PREFIX)) s"evidence parameter ${s.nameString} of type ${s.tpe}"
             else s"parameter ${s.nameString}"
           val where =
-            if (s.owner.isAnonymousFunction) "anonymous function" else s.owner
+            if (s.owner.isAnonymousFunction) "anonymous function" else s.owner.toString
           emitUnusedWarning(s.pos, s"$what in $where is never used", WarningCategory.UnusedParams, s)
         }
       }
diff --git a/src/compiler/scala/tools/nsc/typechecker/Typers.scala b/src/compiler/scala/tools/nsc/typechecker/Typers.scala
index 64270cfbb1..8c07f451b4 100644
--- a/src/compiler/scala/tools/nsc/typechecker/Typers.scala
+++ b/src/compiler/scala/tools/nsc/typechecker/Typers.scala
@@ -15,16 +15,10 @@ package tools.nsc
 package typechecker
 
 import scala.annotation.{tailrec, unused}
-import scala.collection.mutable, mutable.ListBuffer
+import scala.collection.mutable
+import mutable.ListBuffer
 import scala.reflect.internal.{Chars, TypesStats}
-import scala.reflect.internal.util.{
-  CodeAction,
-  FreshNameCreator,
-  ListOfNil,
-  Statistics,
-  StringContextStripMarginOps,
-  TextEdit,
-}
+import scala.reflect.internal.util.{CodeAction, FreshNameCreator, ListOfNil, Statistics, StringContextStripMarginOps}
 import scala.tools.nsc.Reporting.{MessageFilter, Suppression, WConf, WarningCategory}
 import scala.util.chaining._
 import symtab.Flags._
@@ -971,15 +965,12 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
         // This means an accessor that overrides a Java-defined method gets a MethodType instead of a NullaryMethodType, which breaks lots of assumptions about accessors)
         def checkCanAutoApply(): Boolean = {
           if (!isPastTyper && !matchNullaryLoosely) {
-            val description =
+            val msg =
               s"""Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method ${meth.decodedName},
                  |or remove the empty argument list from its definition (Java-defined methods are exempt).
                  |In Scala 3, an unapplied method like this will be eta-expanded into a function.""".stripMargin
-            val actions = if (tree.pos.isRange)
-                List(CodeAction("auto-application of empty-paren methods", Some(description),
-                  List(TextEdit(tree.pos.focusEnd, "()"))))
-              else Nil
-            context.deprecationWarning(tree.pos, NoSymbol, description, "2.13.3", actions)
+            val action = runReporting.codeAction("add `()`", tree.pos.focusEnd, "()", msg)
+            context.deprecationWarning(tree.pos, NoSymbol, msg, "2.13.3", action)
           }
           true
         }
@@ -1142,15 +1133,20 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
               def longWidened = tpSym == LongClass && targetIsWide
               intWidened || longWidened
             }
-            if (isInharmonic)
+            if (isInharmonic) {
               // not `context.deprecationWarning` because they are not buffered in silent mode
-              context.warning(tree.pos, s"Widening conversion from ${tpSym.name} to ${ptSym.name} is deprecated because it loses precision. Write `.to${ptSym.name}` instead.", WarningCategory.Deprecation)
-            else {
+              val msg = s"Widening conversion from ${tpSym.name} to ${ptSym.name} is deprecated because it loses precision. Write `.to${ptSym.name}` instead."
+              val orig = currentUnit.sourceAt(tree.pos)
+              context.warning(tree.pos, msg, WarningCategory.Deprecation,
+                runReporting.codeAction("add conversion", tree.pos, s"${CodeAction.maybeWrapInParens(orig)}.to${ptSym.name}", msg))
+            } else {
               object warnIntDiv extends Traverser {
                 def isInt(t: Tree) = ScalaIntegralValueClasses(t.tpe.typeSymbol)
                 override def traverse(tree: Tree): Unit = tree match {
                   case Apply(Select(q, nme.DIV), _) if isInt(q) =>
-                    context.warning(tree.pos, s"integral division is implicitly converted (widened) to floating point. Add an explicit `.to${ptSym.name}`.", WarningCategory.LintIntDivToFloat)
+                    val msg = s"integral division is implicitly converted (widened) to floating point. Add an explicit `.to${ptSym.name}`."
+                    context.warning(tree.pos, msg, WarningCategory.LintIntDivToFloat,
+                      runReporting.codeAction("add conversion", tree.pos, s"(${currentUnit.sourceAt(tree.pos)}).to${ptSym.name}", msg))
                   case Apply(Select(a1, _), List(a2)) if isInt(tree) && isInt(a1) && isInt(a2) => traverse(a1); traverse(a2)
                   case Select(q, _) if isInt(tree) && isInt(q) => traverse(q)
                   case _ =>
@@ -1611,9 +1607,11 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
       // we'll have to check the probe for isTypeMacro anyways.
       // therefore I think it's reasonable to trade a more specific "inherits itself" error
       // for a generic, yet understandable "cyclic reference" error
-      var probe = typedTypeConstructor(core.duplicate).tpe.typeSymbol
-      if (probe == null) probe = NoSymbol
-      probe.initialize
+      val probe = {
+        val p = typedTypeConstructor(core.duplicate).tpe.typeSymbol
+        if (p == null) NoSymbol
+        else p.initialize
+      }
 
       def cookIfNeeded(tpt: Tree) = if (context.unit.isJava) tpt modifyType rawToExistential else tpt
       cookIfNeeded(if (probe.isTrait || inMixinPosition) {
@@ -2311,10 +2309,6 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
         case Nil => ""
         case xs  => xs.map(_.nameString).mkString(" (of ", " with ", ")")
       }
-      def fail(pos: Position, msg: String): Boolean = {
-        context.error(pos, msg)
-        false
-      }
       /* Have to examine all parameters in all lists.
        */
       def paramssTypes(tp: Type): List[List[Type]] = tp match {
@@ -2326,8 +2320,16 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
       def nthParamPos(n1: Int, n2: Int) =
         try ddef.vparamss(n1)(n2).pos catch { case _: IndexOutOfBoundsException => meth.pos }
 
-      def failStruct(pos: Position, what: String, where: String = "Parameter type") =
-        fail(pos, s"$where in structural refinement may not refer to $what")
+      def failStruct(pos: Position, member: String, referTo: String): Unit =
+        context.error(pos, s"$member in structural refinement may not refer to $referTo")
+      def failStructAbstractType(pos: Position, member: String): false = {
+        failStruct(pos, member, referTo="an abstract type defined outside that refinement")
+        false
+      }
+      def failStructTypeMember(pos: Position, member: String): false = {
+        failStruct(pos, member, referTo="a type member of that refinement")
+        false
+      }
 
       foreachWithIndex(paramssTypes(meth.tpe)) { (paramList, listIdx) =>
         foreachWithIndex(paramList) { (paramType, paramIdx) =>
@@ -2342,8 +2344,8 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
           def checkAbstract(tp0: Type, what: String): Boolean = {
             def check(sym: Symbol): Boolean = !sym.isAbstractType || {
               log(s"""checking $tp0 in refinement$parentString at ${meth.owner.owner.fullLocationString}""")
-              (    (!sym.hasTransOwner(meth.owner) && failStruct(paramPos, "an abstract type defined outside that refinement", what))
-                || (!sym.hasTransOwner(meth) && failStruct(paramPos, "a type member of that refinement", what))
+              (    (!sym.hasTransOwner(meth.owner) && failStructAbstractType(paramPos, what))
+                || (!sym.hasTransOwner(meth) && failStructTypeMember(paramPos, what))
                 || checkAbstract(sym.info.upperBound, "Type bound")
               )
             }
@@ -2352,13 +2354,13 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
           checkAbstract(paramType, "Parameter type")
 
           if (sym.isDerivedValueClass)
-            failStruct(paramPos, "a user-defined value class")
+            failStruct(paramPos, member="Parameter type", referTo="a user-defined value class")
           if (paramType.isInstanceOf[ThisType] && sym == meth.owner)
-            failStruct(paramPos, "the type of that refinement (self type)")
+            failStruct(paramPos, member="Parameter type", referTo="the type of that refinement (self type)")
         }
       }
       if (resultType.typeSymbol.isDerivedValueClass)
-        failStruct(ddef.tpt.pos, "a user-defined value class", where = "Result type")
+        failStruct(ddef.tpt.pos, member="Result type", referTo="a user-defined value class")
     }
 
     def typedDefDef(ddef: DefDef): DefDef = {
@@ -3837,7 +3839,7 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
                     lit.attachments.get[OriginalTreeAttachment] match {
                       case Some(OriginalTreeAttachment(id: Ident)) if rightAssocValDefs.contains(id.symbol) =>
                         inlinedRightAssocValDefs += id.symbol
-                        rightAssocValDefs.remove(id.symbol)
+                        rightAssocValDefs.subtractOne(id.symbol)
                       case _ =>
                     }
 
@@ -4013,6 +4015,8 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
         reportAnnotationError(DoesNotExtendAnnotation(typedFun, annTypeSym))
         return finish(ErroneousAnnotation)
       }
+      if (currentRun.isScala3 && (/*annTypeSym.eq(SpecializedClass) ||*/ annTypeSym.eq(ElidableMethodClass)))
+        context.warning(ann.pos, s"@${annTypeSym.fullNameString} is ignored in Scala 3", WarningCategory.Scala3Migration)
 
       /* Calling constfold right here is necessary because some trees (negated
        * floats and literals in particular) are not yet folded.
@@ -4968,13 +4972,23 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
 
           val result = typed(Function(Nil, methodValue) setSymbol funSym setPos pos, mode, pt)
 
-          if (currentRun.isScala3) {
-            UnderscoreNullaryEtaError(methodValue)
-          } else {
-            context.deprecationWarning(pos, NoSymbol, UnderscoreNullaryEtaWarnMsg, "2.13.2")
-            result
+          val msg = "Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, " +
+            "write a function literal `() => m` instead"
+
+          val action = {
+            val etaPos = pos.withEnd(pos.end + 2)
+            if (currentUnit.sourceAt(etaPos).endsWith(" _"))
+              runReporting.codeAction("replace by function literal", etaPos, s"() => ${currentUnit.sourceAt(pos)}", msg)
+            else Nil
           }
 
+          if (currentRun.isScala3)
+            context.warning(pos, msg, WarningCategory.Scala3Migration, action)
+          else
+            context.deprecationWarning(pos, NoSymbol, msg, "2.13.2", action)
+
+          result
+
         case ErrorType =>
           methodValue
 
@@ -5460,7 +5474,7 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
               case SelectFromTypeTree(qual@TypeTree(), name) if qual.tpe.typeArgs.nonEmpty => // TODO: somehow the new qual is not checked in refchecks
                 treeCopy.SelectFromTypeTree(
                   result,
-                  TypeTreeWithDeferredRefCheck() { () => val tp = qual.tpe; val sym = tp.typeSymbolDirect
+                  TypeTreeWithDeferredRefCheck(qual) { () => val tp = qual.tpe; val sym = tp.typeSymbolDirect
                     // will execute during refchecks -- TODO: make private checkTypeRef in refchecks public and call that one?
                     checkBounds(qual, tp.prefix, sym.owner, sym.typeParams, tp.typeArgs, "")
                     qual // you only get to see the wrapped tree after running this check :-p
@@ -5570,7 +5584,7 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
           case LookupSucceeded(qual, sym)   =>
             sym.getAndRemoveAttachment[LookupAmbiguityWarning].foreach(w => {
               val cat = if (currentRun.isScala3) WarningCategory.Scala3Migration else WarningCategory.Other
-              val fix = List(CodeAction("ambiguous reference", Some(w.msg), List(TextEdit(tree.pos.focusStart, w.fix))))
+              val fix = runReporting.codeAction("make reference explicit", tree.pos.focusStart, w.fix, w.msg)
               runReporting.warning(tree.pos, w.msg, cat, context.owner, fix)
             })
             (// this -> Foo.this
@@ -5698,7 +5712,7 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
             val result = TypeTree(appliedType(tpt1.tpe, argtypes)) setOriginal original
             val isPoly = tpt1.tpe.isInstanceOf[PolyType]
             if (isPoly) // did the type application (performed by appliedType) involve an unchecked beta-reduction?
-              TypeTreeWithDeferredRefCheck() { () =>
+              TypeTreeWithDeferredRefCheck(result) { () =>
                 // wrap the tree and include the bounds check -- refchecks will perform this check (that the beta reduction was indeed allowed) and unwrap
                 // we can't simply use original in refchecks because it does not contains types
                 // (and the only typed trees we have been mangled so they're not quite the original tree anymore)
@@ -6036,7 +6050,7 @@ trait Typers extends Adaptations with Tags with TypersTracking with PatternTyper
         case tree: SelectFromTypeTree           => typedSelect(tree, typedType(tree.qualifier, mode), tree.name)
         case tree: CompoundTypeTree             => typedCompoundTypeTree(tree)
         case tree: ExistentialTypeTree          => typedExistentialTypeTree(tree)
-        case tree: TypeTreeWithDeferredRefCheck => tree // TODO: retype the wrapped tree? TTWDRC would have to change to hold the wrapped tree (not a closure)
+        case tree: TypeTreeWithDeferredRefCheck => tree // TODO: retype the wrapped tree?
         case _                                  => abort(s"unexpected type-representing tree: ${tree.getClass}\n$tree")
       }
 
diff --git a/src/compiler/scala/tools/nsc/util/JavaCharArrayReader.scala b/src/compiler/scala/tools/nsc/util/JavaCharArrayReader.scala
index 92b7c51244..40987720d7 100644
--- a/src/compiler/scala/tools/nsc/util/JavaCharArrayReader.scala
+++ b/src/compiler/scala/tools/nsc/util/JavaCharArrayReader.scala
@@ -14,12 +14,13 @@ package scala
 package tools.nsc
 package util
 
+import scala.collection.AbstractIterator
 import scala.collection.immutable.ArraySeq
 import scala.reflect.internal.Chars._
 import scala.util.chaining._
 
 class JavaCharArrayReader(buf: ArraySeq.ofChar, start: Int, /* startline: int, startcol: int, */
-                      decodeUni: Boolean, error: String => Unit) extends Iterator[Char] with Cloneable {
+                      decodeUni: Boolean, error: String => Unit) extends AbstractIterator[Char] with Cloneable {
 
   def this(buf: ArraySeq.ofChar, decodeUni: Boolean, error: String => Unit) =
     this(buf, 0, /* 1, 1, */ decodeUni, error)
diff --git a/src/compiler/scala/tools/nsc/util/SimpleTracer.scala b/src/compiler/scala/tools/nsc/util/SimpleTracer.scala
index da9cccbcb9..287218657f 100644
--- a/src/compiler/scala/tools/nsc/util/SimpleTracer.scala
+++ b/src/compiler/scala/tools/nsc/util/SimpleTracer.scala
@@ -22,7 +22,7 @@ import java.io.PrintStream
  *  @param enabled A condition that must be true for trace info to be produced.
  */
 class SimpleTracer(out: PrintStream, enabled: Boolean = true) {
-  def apply[T](msg: => String)(value: T): T = {
+  def apply[T](msg: => String)(value: T): value.type = {
     if (enabled) out.println(msg+value)
     value
   }
diff --git a/src/compiler/scala/tools/nsc/util/WorkScheduler.scala b/src/compiler/scala/tools/nsc/util/WorkScheduler.scala
index 9f5f8a29f7..4b922a87b9 100644
--- a/src/compiler/scala/tools/nsc/util/WorkScheduler.scala
+++ b/src/compiler/scala/tools/nsc/util/WorkScheduler.scala
@@ -43,7 +43,7 @@ class WorkScheduler {
   }
 
   def dequeueAllInterrupts(f: InterruptReq => Unit): Unit = synchronized {
-    interruptReqs.dequeueAll { iq => f(iq); true }
+    interruptReqs.removeAll().foreach(f)
   }
 
   /** Called from server: return optional exception posted by client
diff --git a/src/compiler/scala/tools/reflect/FastStringInterpolator.scala b/src/compiler/scala/tools/reflect/FastStringInterpolator.scala
index 9103998b4e..27aa3237f6 100644
--- a/src/compiler/scala/tools/reflect/FastStringInterpolator.scala
+++ b/src/compiler/scala/tools/reflect/FastStringInterpolator.scala
@@ -74,7 +74,7 @@ trait FastStringInterpolator extends FormatInterpolator {
         val it1 = treated.iterator
         val it2 = args.iterator
         val res = new StringBuilder
-        def add(t: Tree) = res.append(t.asInstanceOf[Literal].value.value)
+        def add(t: Tree): Unit = res.append(t.asInstanceOf[Literal].value.value)
         add(it1.next())
         while (it2.hasNext) {
           add(it2.next())
diff --git a/src/compiler/scala/tools/reflect/ToolBoxFactory.scala b/src/compiler/scala/tools/reflect/ToolBoxFactory.scala
index 888fc0faed..a2c505331f 100644
--- a/src/compiler/scala/tools/reflect/ToolBoxFactory.scala
+++ b/src/compiler/scala/tools/reflect/ToolBoxFactory.scala
@@ -75,7 +75,7 @@ abstract class ToolBoxFactory[U <: JavaUniverse](val u: U) { factorySelf =>
         lastSeenContext = analyzer.NoContext
       }
 
-      def verify(expr: Tree): Tree = {
+      def verify(expr: Tree): expr.type = {
         // Previously toolboxes used to typecheck their inputs before compiling.
         // Actually, the initial demo by Martin first typechecked the reified tree,
         // then ran it, which typechecked it again, and only then launched the
diff --git a/src/interactive/scala/tools/nsc/interactive/Pickler.scala b/src/interactive/scala/tools/nsc/interactive/Pickler.scala
index 1e15e85cae..505be3e741 100644
--- a/src/interactive/scala/tools/nsc/interactive/Pickler.scala
+++ b/src/interactive/scala/tools/nsc/interactive/Pickler.scala
@@ -14,6 +14,7 @@ package scala.tools.nsc.interactive
 
 import Lexer._
 import java.io.Writer
+import scala.collection.AbstractIterator
 
 /** An abstract class for writing and reading Scala objects to and
  *  from a legible representation. The representation follows the following grammar:
@@ -277,7 +278,7 @@ object Pickler {
         p.pickle(wr, x)
       }
     }
-    def unpickle(rd: Lexer): Unpickled[Iterator[T]] = UnpickleSuccess(new Iterator[T] {
+    def unpickle(rd: Lexer): Unpickled[Iterator[T]] = UnpickleSuccess(new AbstractIterator[T] {
       var first = true
       def hasNext = {
         val t = rd.token
diff --git a/src/interactive/scala/tools/nsc/interactive/Picklers.scala b/src/interactive/scala/tools/nsc/interactive/Picklers.scala
index ccbe1d53e7..a08b54f624 100644
--- a/src/interactive/scala/tools/nsc/interactive/Picklers.scala
+++ b/src/interactive/scala/tools/nsc/interactive/Picklers.scala
@@ -98,7 +98,7 @@ trait Picklers { self: Global =>
     }
 
   implicit lazy val symPickler: Pickler[Symbol] = {
-    def ownerNames(sym: Symbol, buf: ListBuffer[Name]): ListBuffer[Name] = {
+    def ownerNames(sym: Symbol, buf: ListBuffer[Name]): buf.type = {
       if (!sym.isRoot) {
         ownerNames(sym.owner, buf)
         buf += (if (sym.isModuleClass) sym.sourceModule else sym).name
diff --git a/src/library/scala/beans/BeanProperty.scala b/src/library/scala/beans/BeanProperty.scala
index 597a0bfed5..c836c57457 100644
--- a/src/library/scala/beans/BeanProperty.scala
+++ b/src/library/scala/beans/BeanProperty.scala
@@ -12,6 +12,8 @@
 
 package scala.beans
 
+import scala.annotation.meta.{beanGetter, beanSetter, field}
+
 /** When attached to a field, this annotation adds a setter and a getter
  *  method following the Java Bean convention. For example:
  *  {{{
@@ -26,6 +28,6 @@ package scala.beans
  *  For fields of type `Boolean`, if you need a getter named `isStatus`,
  *  use the `scala.beans.BooleanBeanProperty` annotation instead.
  */
-@scala.annotation.meta.field
+@field @beanGetter @beanSetter
 @deprecatedInheritance("Scheduled for being final in the future", "2.13.0")
 class BeanProperty extends scala.annotation.StaticAnnotation
diff --git a/src/library/scala/beans/BooleanBeanProperty.scala b/src/library/scala/beans/BooleanBeanProperty.scala
index baa3e41e1f..714c332578 100644
--- a/src/library/scala/beans/BooleanBeanProperty.scala
+++ b/src/library/scala/beans/BooleanBeanProperty.scala
@@ -12,10 +12,12 @@
 
 package scala.beans
 
+import scala.annotation.meta.{beanGetter, beanSetter, field}
+
 /** This annotation has the same functionality as
  *  `scala.beans.BeanProperty`, but the generated Bean getter will be
  *  named `isFieldName` instead of `getFieldName`.
  */
-@scala.annotation.meta.field
+@field @beanGetter @beanSetter
 @deprecatedInheritance("Scheduled for being final in the future", "2.13.0")
 class BooleanBeanProperty extends scala.annotation.StaticAnnotation
diff --git a/src/library/scala/collection/ArrayOps.scala b/src/library/scala/collection/ArrayOps.scala
index 4854278866..b2ed04d02d 100644
--- a/src/library/scala/collection/ArrayOps.scala
+++ b/src/library/scala/collection/ArrayOps.scala
@@ -1478,7 +1478,8 @@ final class ArrayOps[A](private val xs: Array[A]) extends AnyVal {
   /** Create a copy of this array with the specified element type. */
   def toArray[B >: A: ClassTag]: Array[B] = {
     val destination = new Array[B](xs.length)
-    copyToArray(destination, 0)
+    @annotation.unused val copied = copyToArray(destination, 0)
+    //assert(copied == xs.length)
     destination
   }
 
diff --git a/src/library/scala/collection/IterableOnce.scala b/src/library/scala/collection/IterableOnce.scala
index 76ed2ac93e..70d95da028 100644
--- a/src/library/scala/collection/IterableOnce.scala
+++ b/src/library/scala/collection/IterableOnce.scala
@@ -1328,9 +1328,9 @@ trait IterableOnceOps[+A, +CC[_], +C] extends Any { this: IterableOnce[A] =>
   def toIndexedSeq: immutable.IndexedSeq[A] = immutable.IndexedSeq.from(this)
 
   @deprecated("Use .to(LazyList) instead of .toStream", "2.13.0")
-  @`inline` final def toStream: immutable.Stream[A] = to(immutable.Stream)
+  @inline final def toStream: immutable.Stream[A] = to(immutable.Stream)
 
-  @`inline` final def toBuffer[B >: A]: mutable.Buffer[B] = mutable.Buffer.from(this)
+  @inline final def toBuffer[B >: A]: mutable.Buffer[B] = mutable.Buffer.from(this)
 
   /** Convert collection to array.
     *
@@ -1339,7 +1339,8 @@ trait IterableOnceOps[+A, +CC[_], +C] extends Any { this: IterableOnce[A] =>
   def toArray[B >: A: ClassTag]: Array[B] =
     if (knownSize >= 0) {
       val destination = new Array[B](knownSize)
-      copyToArray(destination, 0)
+      @annotation.unused val copied = copyToArray(destination, 0)
+      //assert(copied == destination.length)
       destination
     }
     else mutable.ArrayBuilder.make[B].addAll(this).result()
diff --git a/src/library/scala/collection/Seq.scala b/src/library/scala/collection/Seq.scala
index d960838fdc..514d855aa1 100644
--- a/src/library/scala/collection/Seq.scala
+++ b/src/library/scala/collection/Seq.scala
@@ -723,7 +723,8 @@ trait SeqOps[+A, +CC[_], +C] extends Any
     else if (len > 1) {
       b.sizeHint(len)
       val arr = new Array[Any](len)
-      copyToArray(arr)
+      @annotation.unused val copied = copyToArray(arr)
+      //assert(copied == len)
       java.util.Arrays.sort(arr.asInstanceOf[Array[AnyRef]], ord.asInstanceOf[Ordering[AnyRef]])
       var i = 0
       while (i < len) {
diff --git a/src/library/scala/collection/SeqView.scala b/src/library/scala/collection/SeqView.scala
index ad16f01b91..cddd39b9fd 100644
--- a/src/library/scala/collection/SeqView.scala
+++ b/src/library/scala/collection/SeqView.scala
@@ -163,7 +163,8 @@ object SeqView {
         else if (len == 1) List(underlying.head)
         else {
           val arr = new Array[Any](len) // Array[Any] =:= Array[AnyRef]
-          underlying.copyToArray(arr)
+          @annotation.unused val copied = underlying.copyToArray(arr)
+          //assert(copied == len)
           java.util.Arrays.sort(arr.asInstanceOf[Array[AnyRef]], ord.asInstanceOf[Ordering[AnyRef]])
           // casting the Array[AnyRef] to Array[A] and creating an ArraySeq from it
           // is safe because:
diff --git a/src/library/scala/collection/convert/JavaCollectionWrappers.scala b/src/library/scala/collection/convert/JavaCollectionWrappers.scala
index 55dba53bc8..9f6eb2c255 100644
--- a/src/library/scala/collection/convert/JavaCollectionWrappers.scala
+++ b/src/library/scala/collection/convert/JavaCollectionWrappers.scala
@@ -42,7 +42,7 @@ private[collection] object JavaCollectionWrappers extends Serializable {
   }
 
   @SerialVersionUID(3L)
-  class JIteratorWrapper[A](val underlying: ju.Iterator[A]) extends AbstractIterator[A] with Iterator[A] with Serializable {
+  class JIteratorWrapper[A](val underlying: ju.Iterator[A]) extends AbstractIterator[A] with Serializable {
     def hasNext = underlying.hasNext
     def next() = underlying.next
     override def equals(other: Any): Boolean = other match {
@@ -53,7 +53,7 @@ private[collection] object JavaCollectionWrappers extends Serializable {
   }
 
   @SerialVersionUID(3L)
-  class JEnumerationWrapper[A](val underlying: ju.Enumeration[A]) extends AbstractIterator[A] with Iterator[A] with Serializable {
+  class JEnumerationWrapper[A](val underlying: ju.Enumeration[A]) extends AbstractIterator[A] with Serializable {
     def hasNext = underlying.hasMoreElements
     def next() = underlying.nextElement
     override def equals(other: Any): Boolean = other match {
diff --git a/src/library/scala/collection/immutable/ChampCommon.scala b/src/library/scala/collection/immutable/ChampCommon.scala
index 711332567b..2f6e8e7d45 100644
--- a/src/library/scala/collection/immutable/ChampCommon.scala
+++ b/src/library/scala/collection/immutable/ChampCommon.scala
@@ -12,7 +12,7 @@
 
 package scala.collection.immutable
 
-
+import scala.collection.AbstractIterator
 import java.lang.Integer.bitCount
 import java.lang.Math.ceil
 import java.lang.System.arraycopy
@@ -104,7 +104,7 @@ private[collection] abstract class Node[T <: Node[T]] {
   *
   * @tparam T the trie node type we are iterating over
   */
-private[immutable] abstract class ChampBaseIterator[T <: Node[T]] {
+private[immutable] abstract class ChampBaseIterator[A, T <: Node[T]] extends AbstractIterator[A] {
 
   import Node.MaxDepth
 
@@ -192,7 +192,7 @@ private[immutable] abstract class ChampBaseIterator[T <: Node[T]] {
   *
   * @tparam T the trie node type we are iterating over
   */
-private[immutable] abstract class ChampBaseReverseIterator[T <: Node[T]] {
+private[immutable] abstract class ChampBaseReverseIterator[A, T <: Node[T]] extends AbstractIterator[A] {
 
   import Node.MaxDepth
 
diff --git a/src/library/scala/collection/immutable/HashMap.scala b/src/library/scala/collection/immutable/HashMap.scala
index 475fd5e363..d84da09a11 100644
--- a/src/library/scala/collection/immutable/HashMap.scala
+++ b/src/library/scala/collection/immutable/HashMap.scala
@@ -57,7 +57,7 @@ final class HashMap[K, +V] private[immutable] (private[immutable] val rootNode:
 
   override def keySet: Set[K] = if (size == 0) Set.empty else new HashKeySet
 
-  private final class HashKeySet extends ImmutableKeySet {
+  private[immutable] final class HashKeySet extends ImmutableKeySet {
 
     private[this] def newKeySetOrThis(newHashMap: HashMap[K, _]): Set[K] =
       if (newHashMap eq HashMap.this) this else newHashMap.keySet
@@ -698,12 +698,12 @@ private final class BitmapIndexedMapNode[K, +V](
     if ((dataMap & bitpos) != 0) {
       val index = indexFrom(dataMap, mask, bitpos)
       val payload = getPayload(index)
-      if (key == payload._1) payload else throw new NoSuchElementException
+      if (key == payload._1) payload else Iterator.empty.next()
     } else if ((nodeMap & bitpos) != 0) {
       val index = indexFrom(nodeMap, mask, bitpos)
       getNode(index).getTuple(key, originalHash, hash, shift + BitPartitionSize)
     } else {
-      throw new NoSuchElementException
+      Iterator.empty.next()
     }
   }
 
@@ -1872,7 +1872,7 @@ private final class HashCollisionMapNode[K, +V ](
 
   def size: Int = content.length
 
-  def apply(key: K, originalHash: Int, hash: Int, shift: Int): V = get(key, originalHash, hash, shift).getOrElse(throw new NoSuchElementException)
+  def apply(key: K, originalHash: Int, hash: Int, shift: Int): V = get(key, originalHash, hash, shift).getOrElse(Iterator.empty.next())
 
   def get(key: K, originalHash: Int, hash: Int, shift: Int): Option[V] =
     if (this.hash == hash) {
@@ -1882,7 +1882,7 @@ private final class HashCollisionMapNode[K, +V ](
 
   override def getTuple(key: K, originalHash: Int, hash: Int, shift: Int): (K, V) = {
     val index = indexOf(key)
-    if (index >= 0) content(index) else throw new NoSuchElementException
+    if (index >= 0) content(index) else Iterator.empty.next()
   }
 
   def getOrElse[V1 >: V](key: K, originalHash: Int, hash: Int, shift: Int, f: => V1): V1 = {
@@ -2095,11 +2095,10 @@ private final class HashCollisionMapNode[K, +V ](
 }
 
 private final class MapKeyIterator[K, V](rootNode: MapNode[K, V])
-  extends ChampBaseIterator[MapNode[K, V]](rootNode) with Iterator[K] {
+  extends ChampBaseIterator[K, MapNode[K, V]](rootNode) {
 
   def next() = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     val key = currentValueNode.getKey(currentValueCursor)
     currentValueCursor += 1
@@ -2110,11 +2109,10 @@ private final class MapKeyIterator[K, V](rootNode: MapNode[K, V])
 }
 
 private final class MapValueIterator[K, V](rootNode: MapNode[K, V])
-  extends ChampBaseIterator[MapNode[K, V]](rootNode) with Iterator[V] {
+  extends ChampBaseIterator[V, MapNode[K, V]](rootNode) {
 
   def next() = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     val value = currentValueNode.getValue(currentValueCursor)
     currentValueCursor += 1
@@ -2124,11 +2122,10 @@ private final class MapValueIterator[K, V](rootNode: MapNode[K, V])
 }
 
 private final class MapKeyValueTupleIterator[K, V](rootNode: MapNode[K, V])
-  extends ChampBaseIterator[MapNode[K, V]](rootNode) with Iterator[(K, V)] {
+  extends ChampBaseIterator[(K, V), MapNode[K, V]](rootNode) {
 
   def next() = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     val payload = currentValueNode.getPayload(currentValueCursor)
     currentValueCursor += 1
@@ -2139,11 +2136,10 @@ private final class MapKeyValueTupleIterator[K, V](rootNode: MapNode[K, V])
 }
 
 private final class MapKeyValueTupleReverseIterator[K, V](rootNode: MapNode[K, V])
-  extends ChampBaseReverseIterator[MapNode[K, V]](rootNode) with Iterator[(K, V)] {
+  extends ChampBaseReverseIterator[(K, V), MapNode[K, V]](rootNode) {
 
   def next() = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     val payload = currentValueNode.getPayload(currentValueCursor)
     currentValueCursor -= 1
@@ -2153,13 +2149,12 @@ private final class MapKeyValueTupleReverseIterator[K, V](rootNode: MapNode[K, V
 }
 
 private final class MapKeyValueTupleHashIterator[K, V](rootNode: MapNode[K, V])
-  extends ChampBaseReverseIterator[MapNode[K, V]](rootNode) with Iterator[Any] {
+  extends ChampBaseReverseIterator[Any, MapNode[K, V]](rootNode) {
   private[this] var hash = 0
   private[this] var value: V = _
   override def hashCode(): Int = MurmurHash3.tuple2Hash(hash, value.##, MurmurHash3.productSeed)
   def next(): MapKeyValueTupleHashIterator[K, V] = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     hash = currentValueNode.getHash(currentValueCursor)
     value = currentValueNode.getValue(currentValueCursor)
@@ -2169,7 +2164,7 @@ private final class MapKeyValueTupleHashIterator[K, V](rootNode: MapNode[K, V])
 }
 
 /** Used in HashMap[K, V]#removeAll(HashSet[K]) */
-private final class MapNodeRemoveAllSetNodeIterator[K](rootSetNode: SetNode[K]) extends ChampBaseIterator(rootSetNode) {
+private final class MapNodeRemoveAllSetNodeIterator[K](rootSetNode: SetNode[K]) extends ChampBaseIterator[K, SetNode[K]](rootSetNode) {
   /** Returns the result of immutably removing all keys in `rootSetNode` from `rootMapNode` */
   def removeAll[V](rootMapNode: BitmapIndexedMapNode[K, V]): BitmapIndexedMapNode[K, V] = {
     var curr = rootMapNode
@@ -2185,6 +2180,8 @@ private final class MapNodeRemoveAllSetNodeIterator[K](rootSetNode: SetNode[K])
     }
     curr
   }
+
+  override def next() = Iterator.empty.next()
 }
 
 /**
@@ -2370,7 +2367,7 @@ private[immutable] final class HashMapBuilder[K, V] extends ReusableBuilder[(K,
     ensureUnaliased()
     xs match {
       case hm: HashMap[K, V] =>
-        new ChampBaseIterator[MapNode[K, V]](hm.rootNode) {
+        new ChampBaseIterator[(K, V), MapNode[K, V]](hm.rootNode) {
           while(hasNext) {
             val originalHash = currentValueNode.getHash(currentValueCursor)
             update(
@@ -2383,6 +2380,8 @@ private[immutable] final class HashMapBuilder[K, V] extends ReusableBuilder[(K,
             )
             currentValueCursor += 1
           }
+
+          override def next() = Iterator.empty.next()
         }
       case hm: collection.mutable.HashMap[K, V] =>
         val iter = hm.nodeIterator
diff --git a/src/library/scala/collection/immutable/HashSet.scala b/src/library/scala/collection/immutable/HashSet.scala
index 5816714ce5..736414a180 100644
--- a/src/library/scala/collection/immutable/HashSet.scala
+++ b/src/library/scala/collection/immutable/HashSet.scala
@@ -1883,11 +1883,10 @@ private final class HashCollisionSetNode[A](val originalHash: Int, val hash: Int
 }
 
 private final class SetIterator[A](rootNode: SetNode[A])
-  extends ChampBaseIterator[SetNode[A]](rootNode) with Iterator[A] {
+  extends ChampBaseIterator[A, SetNode[A]](rootNode) {
 
   def next() = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     val payload = currentValueNode.getPayload(currentValueCursor)
     currentValueCursor += 1
@@ -1898,11 +1897,10 @@ private final class SetIterator[A](rootNode: SetNode[A])
 }
 
 private final class SetReverseIterator[A](rootNode: SetNode[A])
-  extends ChampBaseReverseIterator[SetNode[A]](rootNode) with Iterator[A] {
+  extends ChampBaseReverseIterator[A, SetNode[A]](rootNode) {
 
   def next(): A = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     val payload = currentValueNode.getPayload(currentValueCursor)
     currentValueCursor -= 1
@@ -1913,13 +1911,12 @@ private final class SetReverseIterator[A](rootNode: SetNode[A])
 }
 
 private final class SetHashIterator[A](rootNode: SetNode[A])
-  extends ChampBaseIterator[SetNode[A]](rootNode) with Iterator[AnyRef] {
+  extends ChampBaseIterator[AnyRef, SetNode[A]](rootNode) {
   private[this] var hash = 0
   override def hashCode(): Int = hash
 
   def next(): AnyRef = {
-    if (!hasNext)
-      throw new NoSuchElementException
+    if (!hasNext) Iterator.empty.next()
 
     hash = currentValueNode.getHash(currentValueCursor)
     currentValueCursor += 1
@@ -2088,7 +2085,7 @@ private[collection] final class HashSetBuilder[A] extends ReusableBuilder[A, Has
     ensureUnaliased()
     xs match {
       case hm: HashSet[A] =>
-        new ChampBaseIterator[SetNode[A]](hm.rootNode) {
+        new ChampBaseIterator[A, SetNode[A]](hm.rootNode) {
           while(hasNext) {
             val originalHash = currentValueNode.getHash(currentValueCursor)
             update(
@@ -2100,6 +2097,7 @@ private[collection] final class HashSetBuilder[A] extends ReusableBuilder[A, Has
             )
             currentValueCursor += 1
           }
+          override def next() = Iterator.empty.next()
         }
       case other =>
         val it = other.iterator
diff --git a/src/library/scala/collection/immutable/LazyList.scala b/src/library/scala/collection/immutable/LazyList.scala
index 8b7ad26dc5..b6af234150 100644
--- a/src/library/scala/collection/immutable/LazyList.scala
+++ b/src/library/scala/collection/immutable/LazyList.scala
@@ -853,7 +853,7 @@ final class LazyList[+A] private(private[this] var lazyState: () => LazyList.Sta
     sb
   }
 
-  private[this] def addStringNoForce(b: JStringBuilder, start: String, sep: String, end: String): JStringBuilder = {
+  private[this] def addStringNoForce(b: JStringBuilder, start: String, sep: String, end: String): b.type = {
     b.append(start)
     if (!stateDefined) b.append("<not computed>")
     else if (!isEmpty) {
@@ -917,6 +917,7 @@ final class LazyList[+A] private(private[this] var lazyState: () => LazyList.Sta
       }
     }
     b.append(end)
+    b
   }
 
   /** $preservesLaziness
diff --git a/src/library/scala/collection/immutable/Map.scala b/src/library/scala/collection/immutable/Map.scala
index 9d334893b8..5311041f66 100644
--- a/src/library/scala/collection/immutable/Map.scala
+++ b/src/library/scala/collection/immutable/Map.scala
@@ -18,6 +18,7 @@ import scala.annotation.unchecked.uncheckedVariance
 import scala.collection.generic.DefaultSerializable
 import scala.collection.immutable.Map.Map4
 import scala.collection.mutable.{Builder, ReusableBuilder}
+import SeqMap.{SeqMap1, SeqMap2, SeqMap3, SeqMap4}
 
 /** Base type of immutable Maps */
 trait Map[K, +V]
@@ -28,7 +29,7 @@ trait Map[K, +V]
 
   override def mapFactory: scala.collection.MapFactory[Map] = Map
 
-  override final def toMap[K2, V2](implicit ev: (K, V) <:< (K2, V2)): Map[K2, V2] = this.asInstanceOf[Map[K2, V2]]
+  override final def toMap[K2, V2](implicit ev: (K, V) <:< (K2, V2)): Map[K2, V2] = Map.from(this.asInstanceOf[Map[K2, V2]])
 
   /** The same map with a given default function.
     *  Note: The default is only used for `apply`. Other methods like `get`, `contains`, `iterator`, `keys`, etc.
@@ -141,7 +142,7 @@ trait MapOps[K, +V, +CC[X, +Y] <: MapOps[X, Y, CC, _], +C <: MapOps[K, V, CC, C]
   override def keySet: Set[K] = new ImmutableKeySet
 
   /** The implementation class of the set returned by `keySet` */
-  protected class ImmutableKeySet extends AbstractSet[K] with GenKeySet with DefaultSerializable {
+  protected[immutable] class ImmutableKeySet extends AbstractSet[K] with GenKeySet with DefaultSerializable {
     def incl(elem: K): Set[K] = if (this(elem)) this else empty ++ this + elem
     def excl(elem: K): Set[K] = if (this(elem)) empty ++ this - elem else this
   }
@@ -206,11 +207,30 @@ object Map extends MapFactory[Map] {
 
   def empty[K, V]: Map[K, V] = EmptyMap.asInstanceOf[Map[K, V]]
 
-  def from[K, V](it: collection.IterableOnce[(K, V)]): Map[K, V] =
+  def from[K, V](it: IterableOnce[(K, V)]): Map[K, V] =
     it match {
       case it: Iterable[_] if it.isEmpty => empty[K, V]
-      case m: Map[K, V] => m
-      case _ => (newBuilder[K, V] ++= it).result()
+      // Since IterableOnce[(K, V)] launders the variance of K,
+      // identify only our implementations which can be soundly substituted.
+      // For example, the ordering used by sorted maps would fail on widened key type. (scala/bug#12745)
+      // The following type test is not sufficient: case m: Map[K, V] => m
+      case m: HashMap[K, V]    => m
+      case m: Map1[K, V]       => m
+      case m: Map2[K, V]       => m
+      case m: Map3[K, V]       => m
+      case m: Map4[K, V]       => m
+      //case m: WithDefault[K, V] => m    // cf SortedMap.WithDefault
+      //case m: SeqMap[K, V]     => SeqMap.from(it) // inlined here to avoid hard dependency
+      case m: ListMap[K, V]    => m
+      case m: TreeSeqMap[K, V] => m
+      case m: VectorMap[K, V]  => m
+      case m: SeqMap1[K, V]    => m
+      case m: SeqMap2[K, V]    => m
+      case m: SeqMap3[K, V]    => m
+      case m: SeqMap4[K, V]    => m
+
+      // Maps with a reified key type must be rebuilt, such as `SortedMap` and `IntMap`.
+      case _ => newBuilder[K, V].addAll(it).result()
     }
 
   def newBuilder[K, V]: Builder[(K, V), Map[K, V]] = new MapBuilderImpl
diff --git a/src/library/scala/collection/immutable/RedBlackTree.scala b/src/library/scala/collection/immutable/RedBlackTree.scala
index f67e66c16e..20a3467638 100644
--- a/src/library/scala/collection/immutable/RedBlackTree.scala
+++ b/src/library/scala/collection/immutable/RedBlackTree.scala
@@ -567,8 +567,8 @@ private[collection] object RedBlackTree {
     override def toString: String = s"${if(isRed) "RedTree" else "BlackTree"}($key, $value, $left, $right)"
 
     //mutable APIs
-    private[RedBlackTree] def makeImmutable: Tree[A, B] = {
-      def makeImmutableImpl() = {
+    private[RedBlackTree] def makeImmutable: this.type = {
+      def makeImmutableImpl(): Unit = {
         if (isMutable) {
           var size = 1
           if (_left ne null) {
@@ -581,7 +581,6 @@ private[collection] object RedBlackTree {
           }
           _count |= size //retains colour
         }
-        this
       }
       makeImmutableImpl()
       this
diff --git a/src/library/scala/collection/immutable/SeqMap.scala b/src/library/scala/collection/immutable/SeqMap.scala
index aca9e13916..654bfa3baa 100644
--- a/src/library/scala/collection/immutable/SeqMap.scala
+++ b/src/library/scala/collection/immutable/SeqMap.scala
@@ -46,7 +46,15 @@ object SeqMap extends MapFactory[SeqMap] {
 
   def from[K, V](it: collection.IterableOnce[(K, V)]): SeqMap[K, V] =
     it match {
-      case sm: SeqMap[K, V] => sm
+      //case sm: SeqMap[K, V] => sm
+      case m: ListMap[K, V]    => m
+      case m: TreeSeqMap[K, V] => m
+      case m: VectorMap[K, V]  => m
+      case m: SeqMap1[K, V]    => m
+      case m: SeqMap2[K, V]    => m
+      case m: SeqMap3[K, V]    => m
+      case m: SeqMap4[K, V]    => m
+      case it: Iterable[_] if it.isEmpty => empty[K, V]
       case _ => (newBuilder[K, V] ++= it).result()
     }
 
@@ -66,7 +74,7 @@ object SeqMap extends MapFactory[SeqMap] {
   }
 
   @SerialVersionUID(3L)
-  private final class SeqMap1[K, +V](key1: K, value1: V) extends SeqMap[K,V] with Serializable {
+  private[immutable] final class SeqMap1[K, +V](key1: K, value1: V) extends SeqMap[K,V] with Serializable {
     override def size: Int = 1
     override def knownSize: Int = 1
     override def apply(key: K) = if (key == key1) value1 else throw new NoSuchElementException("key not found: " + key)
@@ -90,7 +98,7 @@ object SeqMap extends MapFactory[SeqMap] {
   }
 
   @SerialVersionUID(3L)
-  private final class SeqMap2[K, +V](key1: K, value1: V, key2: K, value2: V) extends SeqMap[K,V] with Serializable {
+  private[immutable] final class SeqMap2[K, +V](key1: K, value1: V, key2: K, value2: V) extends SeqMap[K,V] with Serializable {
     override def size: Int = 2
     override def knownSize: Int = 2
     override def apply(key: K) =
@@ -125,7 +133,7 @@ object SeqMap extends MapFactory[SeqMap] {
   }
 
   @SerialVersionUID(3L)
-  private class SeqMap3[K, +V](key1: K, value1: V, key2: K, value2: V, key3: K, value3: V) extends SeqMap[K,V] with Serializable {
+  private[immutable] class SeqMap3[K, +V](key1: K, value1: V, key2: K, value2: V, key3: K, value3: V) extends SeqMap[K,V] with Serializable {
     override def size: Int = 3
     override def knownSize: Int = 3
     override def apply(key: K) =
@@ -166,7 +174,7 @@ object SeqMap extends MapFactory[SeqMap] {
   }
 
   @SerialVersionUID(3L)
-  private final class SeqMap4[K, +V](key1: K, value1: V, key2: K, value2: V, key3: K, value3: V, key4: K, value4: V) extends SeqMap[K,V] with Serializable {
+  private[immutable] final class SeqMap4[K, +V](key1: K, value1: V, key2: K, value2: V, key3: K, value3: V, key4: K, value4: V) extends SeqMap[K,V] with Serializable {
     override def size: Int = 4
     override def knownSize: Int = 4
     override def apply(key: K) =
diff --git a/src/library/scala/collection/immutable/Set.scala b/src/library/scala/collection/immutable/Set.scala
index f07eb66991..707ddf4035 100644
--- a/src/library/scala/collection/immutable/Set.scala
+++ b/src/library/scala/collection/immutable/Set.scala
@@ -96,12 +96,21 @@ object Set extends IterableFactory[Set] {
 
   def from[E](it: collection.IterableOnce[E]): Set[E] =
     it match {
-      // We want `SortedSet` (and subclasses, such as `BitSet`) to
-      // rebuild themselves to avoid element type widening issues
-      case _: SortedSet[E]         => (newBuilder[E] ++= it).result()
-      case _ if it.knownSize == 0  => empty[E]
-      case s: Set[E]               => s
-      case _                       => (newBuilder[E] ++= it).result()
+      case _ if it.knownSize == 0 => empty[E]
+      // Since IterableOnce[E] launders the variance of E,
+      // identify only our implementations which can be soundly substituted.
+      // It's not sufficient to match `SortedSet[E]` to rebuild and `Set[E]` to retain.
+      case s: HashSet[E] => s
+      case s: ListSet[E] => s
+      case s: Set1[E]    => s
+      case s: Set2[E]    => s
+      case s: Set3[E]    => s
+      case s: Set4[E]    => s
+      case s: HashMap[E @unchecked, _]#HashKeySet => s
+      case s: MapOps[E, Any, Map, Map[E, Any]]#ImmutableKeySet @unchecked => s
+      // We also want `SortedSet` (and subclasses, such as `BitSet`)
+      // to rebuild themselves, to avoid element type widening issues.
+      case _ => newBuilder[E].addAll(it).result()
     }
 
   def newBuilder[A]: Builder[A, Set[A]] = new SetBuilderImpl[A]
diff --git a/src/library/scala/collection/immutable/Stream.scala b/src/library/scala/collection/immutable/Stream.scala
index ae03641e97..8f377f199d 100644
--- a/src/library/scala/collection/immutable/Stream.scala
+++ b/src/library/scala/collection/immutable/Stream.scala
@@ -242,7 +242,7 @@ sealed abstract class Stream[+A] extends AbstractSeq[A]
     sb
   }
 
-  private[this] def addStringNoForce(b: JStringBuilder, start: String, sep: String, end: String): JStringBuilder = {
+  private[this] def addStringNoForce(b: JStringBuilder, start: String, sep: String, end: String): b.type = {
     b.append(start)
     if (nonEmpty) {
       b.append(head)
@@ -311,6 +311,7 @@ sealed abstract class Stream[+A] extends AbstractSeq[A]
       }
     }
     b.append(end)
+    b
   }
 
   /**
diff --git a/src/library/scala/collection/immutable/Vector.scala b/src/library/scala/collection/immutable/Vector.scala
index aa3fac5acd..b3b164b004 100644
--- a/src/library/scala/collection/immutable/Vector.scala
+++ b/src/library/scala/collection/immutable/Vector.scala
@@ -47,11 +47,13 @@ object Vector extends StrictOptimizedSeqFactory[Vector] {
               as.unsafeArray.asInstanceOf[Arr1]
             case it: Iterable[E] =>
               val a1 = new Arr1(knownSize)
-              it.copyToArray(a1.asInstanceOf[Array[Any]])
+              @annotation.unused val copied = it.copyToArray(a1.asInstanceOf[Array[Any]])
+              //assert(copied == knownSize)
               a1
             case _ =>
               val a1 = new Arr1(knownSize)
-              it.iterator.copyToArray(a1.asInstanceOf[Array[Any]])
+              @annotation.unused val copied = it.iterator.copyToArray(a1.asInstanceOf[Array[Any]])
+              //assert(copied == knownSize)
               a1.asInstanceOf[Arr1]
           }
           new Vector1[E](a1)
@@ -2192,7 +2194,8 @@ private object VectorStatics {
           case s =>
             val prefix1b = new Arr1(prefix1.length + s)
             System.arraycopy(prefix1, 0, prefix1b, s, prefix1.length)
-            it.copyToArray(prefix1b.asInstanceOf[Array[Any]], 0)
+            @annotation.unused val copied = it.copyToArray(prefix1b.asInstanceOf[Array[Any]], 0)
+            //assert(copied == s)
             prefix1b
         }
       } else null
@@ -2201,7 +2204,8 @@ private object VectorStatics {
       if(s > 0 && s <= WIDTH-prefix1.length) {
         val prefix1b = new Arr1(prefix1.length + s)
         System.arraycopy(prefix1, 0, prefix1b, s, prefix1.length)
-        it.iterator.copyToArray(prefix1b.asInstanceOf[Array[Any]], 0)
+        @annotation.unused val copied = it.iterator.copyToArray(prefix1b.asInstanceOf[Array[Any]], 0)
+        //assert(copied == s)
         prefix1b
       } else null
   }
@@ -2214,7 +2218,8 @@ private object VectorStatics {
           case 1 => copyAppend(suffix1, it.head.asInstanceOf[AnyRef])
           case s =>
             val suffix1b = copyOf(suffix1, suffix1.length + s)
-            it.copyToArray(suffix1b.asInstanceOf[Array[Any]], suffix1.length)
+            @annotation.unused val copied = it.copyToArray(suffix1b.asInstanceOf[Array[Any]], suffix1.length)
+            //assert(copied == s)
             suffix1b
         }
       } else null
@@ -2222,14 +2227,15 @@ private object VectorStatics {
       val s = it.knownSize
       if(s > 0 && s <= WIDTH-suffix1.length) {
         val suffix1b = copyOf(suffix1, suffix1.length + s)
-        it.iterator.copyToArray(suffix1b.asInstanceOf[Array[Any]], suffix1.length)
+        @annotation.unused val copied = it.iterator.copyToArray(suffix1b.asInstanceOf[Array[Any]], suffix1.length)
+        //assert(copied == s)
         suffix1b
       } else null
   }
 }
 
 
-private final class NewVectorIterator[A](v: Vector[A], private[this] var totalLength: Int, private[this] val sliceCount: Int) extends Iterator[A] with java.lang.Cloneable {
+private final class NewVectorIterator[A](v: Vector[A], private[this] var totalLength: Int, private[this] val sliceCount: Int) extends AbstractIterator[A] with java.lang.Cloneable {
 
   private[this] var a1: Arr1 = v.prefix1
   private[this] var a2: Arr2 = _
diff --git a/src/library/scala/collection/mutable/ArrayDeque.scala b/src/library/scala/collection/mutable/ArrayDeque.scala
index 205e1607f8..f164c76283 100644
--- a/src/library/scala/collection/mutable/ArrayDeque.scala
+++ b/src/library/scala/collection/mutable/ArrayDeque.scala
@@ -112,7 +112,8 @@ class ArrayDeque[A] protected (
         case srcLength if mustGrow(srcLength + n) =>
           val finalLength = srcLength + n
           val array2 = ArrayDeque.alloc(finalLength)
-          it.copyToArray(array2.asInstanceOf[Array[A]])
+          @annotation.unused val copied = it.copyToArray(array2.asInstanceOf[Array[A]])
+          //assert(copied == srcLength)
           copySliceToArray(srcStart = 0, dest = array2, destStart = srcLength, maxItems = n)
           reset(array = array2, start = 0, end = finalLength)
 
@@ -199,7 +200,8 @@ class ArrayDeque[A] protected (
         if (mustGrow(finalLength)) {
           val array2 = ArrayDeque.alloc(finalLength)
           copySliceToArray(srcStart = 0, dest = array2, destStart = 0, maxItems = idx)
-          it.copyToArray(array2.asInstanceOf[Array[A]], idx)
+          @annotation.unused val copied = it.copyToArray(array2.asInstanceOf[Array[A]], idx)
+          //assert(copied == srcLength)
           copySliceToArray(srcStart = idx, dest = array2, destStart = idx + srcLength, maxItems = n)
           reset(array = array2, start = 0, end = finalLength)
         } else if (2*idx >= n) { // Cheaper to shift the suffix right
diff --git a/src/library/scala/util/matching/Regex.scala b/src/library/scala/util/matching/Regex.scala
index eadb9170a1..2c3b45153c 100644
--- a/src/library/scala/util/matching/Regex.scala
+++ b/src/library/scala/util/matching/Regex.scala
@@ -803,7 +803,7 @@ object Regex {
    *  @see [[java.util.regex.Matcher]]
    */
   class MatchIterator(val source: CharSequence, val regex: Regex, private[Regex] val _groupNames: Seq[String])
-  extends AbstractIterator[String] with Iterator[String] with MatchData { self =>
+  extends AbstractIterator[String] with MatchData { self =>
 
     @deprecated("groupNames does not include inline group names, and should not be used anymore", "2.13.7")
     val groupNames: Seq[String] = _groupNames
diff --git a/src/partest/scala/tools/partest/ReplTest.scala b/src/partest/scala/tools/partest/ReplTest.scala
index 8c273eee49..d5b2acf17f 100644
--- a/src/partest/scala/tools/partest/ReplTest.scala
+++ b/src/partest/scala/tools/partest/ReplTest.scala
@@ -14,8 +14,7 @@ package scala.tools.partest
 
 import scala.tools.nsc.Settings
 import scala.tools.nsc.interpreter.shell.{ILoop, ShellConfig}
-import scala.util.matching.Regex
-import scala.util.matching.Regex.Match
+import scala.util.matching.Regex.{quoteReplacement, Match}
 
 /** Test code or commands in a REPL.
  *
@@ -76,7 +75,7 @@ trait Lambdaless extends ReplTest {
 }
 object Lambdaless {
   private val lambdaless = """\$Lambda(?:\$\d+)?/(?:0x[a-f0-9]{16}|\d+)(?:@[a-fA-F0-9]+)?""".r
-  private def stripLambdaClassName(s: String): String = lambdaless.replaceAllIn(s, Regex.quoteReplacement("<function>"))
+  private def stripLambdaClassName(s: String): String = lambdaless.replaceAllIn(s, quoteReplacement("<function>"))
 }
 
 /** Normalize a REPL stack trace by stripping line numbers and count of elided frames. */
@@ -132,7 +131,7 @@ abstract class SessionTest extends ReplTest  {
   override final def code = pasted.findAllMatchIn(expected.mkString("", "\n", "\n")).map {
     case pasted(null, null, prompted) =>
       def continued(m: Match): Option[String] = m match {
-        case margin(text) => Some(Regex.quoteReplacement(text))
+        case margin(text) => Some(quoteReplacement(text))
         case _            => None
       }
       margin.replaceSomeIn(prompted, continued)
diff --git a/src/partest/scala/tools/partest/ScriptTest.scala b/src/partest/scala/tools/partest/ScriptTest.scala
index 82a3f1d49a..ad5362e175 100644
--- a/src/partest/scala/tools/partest/ScriptTest.scala
+++ b/src/partest/scala/tools/partest/ScriptTest.scala
@@ -24,7 +24,7 @@ abstract class ScriptTest extends DirectTest {
   def code = scriptPath.toFile.slurp()
   def argv = Seq.empty[String]
   def show() = {
-    compile()
+    assert(compile())
     ScalaClassLoader(getClass.getClassLoader).run(testmain, argv)
   }
 }
diff --git a/src/partest/scala/tools/partest/StubErrorMessageTest.scala b/src/partest/scala/tools/partest/StubErrorMessageTest.scala
index 9c74a2c596..d8a9631890 100644
--- a/src/partest/scala/tools/partest/StubErrorMessageTest.scala
+++ b/src/partest/scala/tools/partest/StubErrorMessageTest.scala
@@ -51,7 +51,7 @@ trait StubErrorMessageTest extends StoreReporterDirectTest {
     if (extraUserCode == "") compileCode(userCode)
     else compileCode(userCode, extraUserCode)
     import scala.reflect.internal.util.Position
-    filteredInfos.map { report =>
+    filteredInfos.foreach { report =>
       print(if (report.severity == storeReporter.ERROR) "error: " else "")
       println(Position.formatMessage(report.pos, report.msg, true))
     }
diff --git a/src/partest/scala/tools/partest/nest/Runner.scala b/src/partest/scala/tools/partest/nest/Runner.scala
index 9bd1a39315..af12c961c8 100644
--- a/src/partest/scala/tools/partest/nest/Runner.scala
+++ b/src/partest/scala/tools/partest/nest/Runner.scala
@@ -32,7 +32,7 @@ import scala.util.{Failure, Success, Try, Using}
 import scala.util.Properties.isJavaAtLeast
 import scala.util.chaining._
 import scala.util.control.{ControlThrowable, NonFatal}
-import scala.util.matching.Regex
+import scala.util.matching.Regex.quoteReplacement
 import ClassPath.join
 import FileManager.{compareContents, joinPaths, withTempFile}
 import TestState.{Crash, Fail, Pass, Skip, Updated}
@@ -367,7 +367,7 @@ class Runner(val testInfo: TestInfo, val suiteRunner: AbstractRunner) {
     def canonicalize: String => String = {
       val hiders = toolArgs(ToolName.hide).map(_.r)
       (s: String) => {
-        val pathless = pathFinder.replaceAllIn(s, m => Regex.quoteReplacement(ellipsis + squashSlashes(m.group(1))))
+        val pathless = pathFinder.replaceAllIn(s, m => quoteReplacement(ellipsis + squashSlashes(m.group(1))))
         if (hiders.isEmpty) pathless
         else hiders.foldLeft(pathless)((s, r) => r.replaceAllIn(s, m => "***"))
       }
diff --git a/src/reflect/scala/reflect/api/Symbols.scala b/src/reflect/scala/reflect/api/Symbols.scala
index a4adf47d71..37d4479457 100644
--- a/src/reflect/scala/reflect/api/Symbols.scala
+++ b/src/reflect/scala/reflect/api/Symbols.scala
@@ -561,7 +561,7 @@ trait Symbols { self: Universe =>
    *  $SYMACCESSORS
    *  @group API
    */
-  trait TermSymbolApi extends SymbolApi { this: TermSymbol =>
+  trait TermSymbolApi extends SymbolApi { this: TermSymbol with TermSymbolApi =>
     /** Term symbols have their names of type `TermName`.
      */
     final type NameType = TermName
diff --git a/src/reflect/scala/reflect/internal/AnnotationInfos.scala b/src/reflect/scala/reflect/internal/AnnotationInfos.scala
index c8cbfd5b9a..4ac3606620 100644
--- a/src/reflect/scala/reflect/internal/AnnotationInfos.scala
+++ b/src/reflect/scala/reflect/internal/AnnotationInfos.scala
@@ -157,8 +157,9 @@ trait AnnotationInfos extends api.Annotations { self: SymbolTable =>
    *  definitions) have to be lazy (#1782)
    */
   class LazyAnnotationInfo(lazyInfo: => AnnotationInfo) extends AnnotationInfo {
-    private[this] var forced = false
-    private lazy val forcedInfo = try lazyInfo finally forced = true
+    private[this] var _forced = false
+    protected def forced = _forced
+    private lazy val forcedInfo = try lazyInfo finally _forced = true
 
     def atp: Type                               = forcedInfo.atp
     def args: List[Tree]                        = forcedInfo.args
@@ -167,16 +168,17 @@ trait AnnotationInfos extends api.Annotations { self: SymbolTable =>
     def setOriginal(t: Tree): this.type         = { forcedInfo.setOriginal(t); this }
 
     // We should always be able to print things without forcing them.
-    override def toString = if (forced) forcedInfo.toString else "@<?>"
+    override def toString = if (_forced) forcedInfo.toString else "@<?>"
 
-    override def pos: Position = if (forced) forcedInfo.pos else NoPosition
+    override def pos: Position = if (_forced) forcedInfo.pos else NoPosition
 
     override def completeInfo(): Unit = forcedInfo
   }
 
   final class ExtraLazyAnnotationInfo(sym: => Symbol, lazyInfo: => AnnotationInfo) extends LazyAnnotationInfo(lazyInfo) {
     private[this] lazy val typeSymbol = sym
-    override def symbol: Symbol = typeSymbol
+    // If `forced` to UnmappableAnnotation, ensure to return NoSymbol, otherwise `ann.matches(annCls)` can be incorrect
+    override def symbol: Symbol = if (forced) super.symbol else typeSymbol
   }
 
   /** Typed information about an annotation. It can be attached to either
diff --git a/src/reflect/scala/reflect/internal/BaseTypeSeqs.scala b/src/reflect/scala/reflect/internal/BaseTypeSeqs.scala
index 570a94e960..870f274ad7 100644
--- a/src/reflect/scala/reflect/internal/BaseTypeSeqs.scala
+++ b/src/reflect/scala/reflect/internal/BaseTypeSeqs.scala
@@ -257,7 +257,8 @@ trait BaseTypeSeqs {
       }
     }
     val elems = new Array[Type](btsSize)
-    buf.copyToArray(elems, 0)
+    @annotation.unused val copied = buf.copyToArray(elems, 0)
+    //assert(copied == btsSize, "array copied")
 //    Console.println("computed baseTypeSeq of " + tsym.tpe + " " + parents + ": "+elems.toString)//DEBUG
     newBaseTypeSeq(parents, elems)
   }
diff --git a/src/reflect/scala/reflect/internal/Definitions.scala b/src/reflect/scala/reflect/internal/Definitions.scala
index f25a757d06..8e737b9734 100644
--- a/src/reflect/scala/reflect/internal/Definitions.scala
+++ b/src/reflect/scala/reflect/internal/Definitions.scala
@@ -231,7 +231,7 @@ trait Definitions extends api.StandardDefinitions {
 
     /** Fully initialize the symbol, type, or scope.
      */
-    def fullyInitializeSymbol(sym: Symbol): Symbol = {
+    def fullyInitializeSymbol(sym: Symbol): sym.type = {
       sym.initialize
       // Watch out for those darn raw types on method parameters
       if (sym.owner.initialize.isJavaDefined)
@@ -241,17 +241,17 @@ trait Definitions extends api.StandardDefinitions {
       fullyInitializeType(sym.tpe_*)
       sym
     }
-    def fullyInitializeType(tp: Type): Type = {
+    def fullyInitializeType(tp: Type): tp.type = {
       tp.typeParams foreach fullyInitializeSymbol
       mforeach(tp.paramss)(fullyInitializeSymbol)
       tp
     }
-    def fullyInitializeScope(scope: Scope): Scope = {
+    def fullyInitializeScope(scope: Scope): scope.type = {
       scope.sorted foreach fullyInitializeSymbol
       scope
     }
     /** Is this symbol a member of Object or Any? */
-    def isUniversalMember(sym: Symbol) =
+    def isUniversalMember(sym: Symbol): Boolean =
       if (sym.isOverloaded) sym.alternatives.exists(alt => ObjectClass.isSubClass(alt.owner))
       else ObjectClass.isSubClass(sym.owner)
 
diff --git a/src/reflect/scala/reflect/internal/Flags.scala b/src/reflect/scala/reflect/internal/Flags.scala
index 9af3938bb9..e4402f377f 100644
--- a/src/reflect/scala/reflect/internal/Flags.scala
+++ b/src/reflect/scala/reflect/internal/Flags.scala
@@ -521,9 +521,9 @@ class Flags extends ModifierFlags {
         if ((flags & mask) != 0L) {
           val s = flagToString(mask)
           if (s.length > 0) {
-            if (sb eq null) sb = new StringBuilder append s
-            else if (sb.length == 0) sb append s
-            else sb append " " append s
+            if (sb eq null) sb = new StringBuilder
+            else if (!sb.isEmpty) sb.append(" ")
+            sb.append(s)
           }
         }
         i += 1
diff --git a/src/reflect/scala/reflect/internal/HasFlags.scala b/src/reflect/scala/reflect/internal/HasFlags.scala
index 013e278ecd..587aecc140 100644
--- a/src/reflect/scala/reflect/internal/HasFlags.scala
+++ b/src/reflect/scala/reflect/internal/HasFlags.scala
@@ -144,9 +144,9 @@ trait HasFlags {
         if ((bits & flag) != 0L) {
           val s = Flags.flagToString(flag)
           if (s.length > 0) {
-            if (sb eq null) sb = new StringBuilder append s
-            else if (sb.length == 0) sb append s
-            else sb append " " append s
+            if (sb eq null) sb = new StringBuilder
+            else if (!sb.isEmpty) sb.append(" ")
+            sb.append(s)
           }
         }
         i += 1
diff --git a/src/reflect/scala/reflect/internal/Names.scala b/src/reflect/scala/reflect/internal/Names.scala
index a1fa620e4a..8763a59c08 100644
--- a/src/reflect/scala/reflect/internal/Names.scala
+++ b/src/reflect/scala/reflect/internal/Names.scala
@@ -546,6 +546,8 @@ trait Names extends api.Names {
     override final def toString: String = if (cachedString == null) new String(_chrs, index, len) else cachedString
     final def appendTo(buffer: java.lang.StringBuffer, start: Int, length: Int): Unit =
       buffer.append(_chrs, this.start + start, length)
+    final def appendTo(sb: StringBuilder, start: Int, length: Int): sb.type =
+      sb.appendAll(_chrs, this.start + start, length)
   }
 
   implicit val NameTag: ClassTag[Name] = ClassTag[Name](classOf[Name])
diff --git a/src/reflect/scala/reflect/internal/Scopes.scala b/src/reflect/scala/reflect/internal/Scopes.scala
index 92e03eb431..74802ccdb5 100644
--- a/src/reflect/scala/reflect/internal/Scopes.scala
+++ b/src/reflect/scala/reflect/internal/Scopes.scala
@@ -64,7 +64,7 @@ trait Scopes extends api.Scopes { self: SymbolTable =>
   }
 
   /** A default Scope iterator, that retrieves elements in the order given by ScopeEntry. */
-  private[Scopes] class ScopeIterator(owner: Scope) extends Iterator[Symbol] {
+  private[Scopes] class ScopeIterator(owner: Scope) extends AbstractIterator[Symbol] {
     private[this] var elem: ScopeEntry = owner.elems
 
     def hasNext: Boolean = (elem ne null) && (elem.owner == this.owner)
diff --git a/src/reflect/scala/reflect/internal/SymbolTable.scala b/src/reflect/scala/reflect/internal/SymbolTable.scala
index c67fe257bf..ab0155bc5c 100644
--- a/src/reflect/scala/reflect/internal/SymbolTable.scala
+++ b/src/reflect/scala/reflect/internal/SymbolTable.scala
@@ -409,7 +409,7 @@ abstract class SymbolTable extends macros.Universe
     private[this] var caches = List[WeakReference[Clearable]]()
     private[this] var javaCaches = List[JavaClearable[_]]()
 
-    def recordCache[T <: Clearable](cache: T): T = {
+    def recordCache[T <: Clearable](cache: T): cache.type = {
       cache match {
         case jc: JavaClearable[_] =>
           javaCaches ::= jc
@@ -420,7 +420,7 @@ abstract class SymbolTable extends macros.Universe
     }
 
     /** Closes the provided classloader at the conclusion of this Run */
-    final def recordClassloader(loader: ClassLoader): ClassLoader = {
+    final def recordClassloader(loader: ClassLoader): loader.type = {
       def attemptClose(loader: ClassLoader): Unit = {
         loader match {
           case u: URLClassLoader => debuglog("Closing classloader " + u); u.close()
@@ -448,7 +448,7 @@ abstract class SymbolTable extends macros.Universe
       }
     }
 
-    def clearAll() = {
+    def clearAll(): Unit = {
       debuglog("Clearing " + (caches.size + javaCaches.size) + " caches.")
       caches foreach (ref => Option(ref.get).foreach(_.clear()))
       caches = caches.filterNot(_.get == null)
diff --git a/src/reflect/scala/reflect/internal/Symbols.scala b/src/reflect/scala/reflect/internal/Symbols.scala
index 0e5e0f331a..2d1385ed15 100644
--- a/src/reflect/scala/reflect/internal/Symbols.scala
+++ b/src/reflect/scala/reflect/internal/Symbols.scala
@@ -54,7 +54,7 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
   protected def freshExistentialName(suffix: String, id: Int): TypeName = newTypeName("_" + id + suffix)
 
   // Set the fields which point companions at one another.  Returns the module.
-  def connectModuleToClass(m: ModuleSymbol, moduleClass: ClassSymbol): ModuleSymbol = {
+  def connectModuleToClass(m: ModuleSymbol, moduleClass: ClassSymbol): m.type = {
     moduleClass.sourceModule = m
     m setModuleClass moduleClass
     m
@@ -1614,7 +1614,7 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
     }
 
     /** Set new info valid from start of this phase. */
-    def updateInfo(info: Type): Symbol = {
+    def updateInfo(info: Type): this.type = {
       val pid = phaseId(infos.validFrom)
       assert(pid <= phase.id, (pid, phase.id))
       if (pid == phase.id) infos = infos.prev
@@ -1916,6 +1916,8 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
     def filterAnnotations(p: AnnotationInfo => Boolean): this.type =
       setAnnotations(annotations filter p)
 
+    override def removeAnnotation(sym: Symbol): this.type = filterAnnotations(!_.matches(sym))
+
     def addAnnotation(annot: AnnotationInfo): this.type = setAnnotations(annotations.appended(annot))
 
     // Convenience for the overwhelmingly common cases, and avoid varags and listbuilders
@@ -2607,7 +2609,7 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
 
     /** Remove any access boundary and clear flags PROTECTED | PRIVATE.
      */
-    def makePublic = this setPrivateWithin NoSymbol resetFlag AccessFlags
+    def makePublic: this.type = this setPrivateWithin NoSymbol resetFlag AccessFlags
 
     /** The first parameter to the first argument list of this method,
      *  or NoSymbol if inapplicable.
@@ -2647,7 +2649,7 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
     final def sealedDescendants: Set[Symbol] = if (!isSealed) Set(this) else children.flatMap(_.sealedDescendants) + this
 
     @inline final def orElse(alt: => Symbol): Symbol = if (this ne NoSymbol) this else alt
-    @inline final def andAlso(f: Symbol => Unit): Symbol = { if (this ne NoSymbol) f(this) ; this }
+    @inline final def andAlso(f: Symbol => Unit): this.type = { if (this ne NoSymbol) f(this) ; this }
     @inline final def fold[T](none: => T)(f: Symbol => T): T = if (this ne NoSymbol) f(this) else none
     @inline final def map(f: Symbol => Symbol): Symbol = if (this eq NoSymbol) this else f(this)
 
@@ -2986,7 +2988,7 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
       if (unexpandedName endsWith (nme.OUTER)) initialize.referenced
       else NoSymbol
 
-    def setModuleClass(clazz: Symbol): TermSymbol = {
+    def setModuleClass(clazz: Symbol): this.type = {
       assert(isModule, this)
       referenced = clazz
       this
diff --git a/src/reflect/scala/reflect/internal/TreeGen.scala b/src/reflect/scala/reflect/internal/TreeGen.scala
index 283be1b733..035c24362e 100644
--- a/src/reflect/scala/reflect/internal/TreeGen.scala
+++ b/src/reflect/scala/reflect/internal/TreeGen.scala
@@ -16,6 +16,7 @@ package internal
 
 import Flags._
 import util._
+import scala.annotation.tailrec
 import scala.collection.mutable.ListBuffer
 
 abstract class TreeGen {
@@ -146,11 +147,12 @@ abstract class TreeGen {
   //            || patPre.typeSymbol.isPackageClass
   //            || selPre =:= patPre)
 
-  def mkAttributedQualifierIfPossible(prefix: Type): Option[Tree] = prefix match {
+  @tailrec final def mkAttributedQualifierIfPossible(prefix: Type): Option[Tree] = prefix match {
     case NoType | NoPrefix | ErrorType => None
     case TypeRef(_, sym, _) if sym.isModule || sym.isClass || sym.isType => None
     case RefinedType(parents, _) if !parents.exists(_.isStable) => None
-    case pre => Some(mkAttributedQualifier(prefix))
+    case AnnotatedType(_, tpe) => mkAttributedQualifierIfPossible(tpe)
+    case prefix => Some(mkAttributedQualifier(prefix))
   }
 
 
diff --git a/src/reflect/scala/reflect/internal/Trees.scala b/src/reflect/scala/reflect/internal/Trees.scala
index cf6545c781..ba502b46f9 100644
--- a/src/reflect/scala/reflect/internal/Trees.scala
+++ b/src/reflect/scala/reflect/internal/Trees.scala
@@ -235,7 +235,7 @@ trait Trees extends api.Trees {
     /** Sets the tree's type to the result of the given function.
      *  If the type is null, it remains null - the function is not called.
      */
-    def modifyType(f: Type => Type): Tree =
+    def modifyType(f: Type => Type): this.type =
       if (tpe eq null) this
       else this setType f(tpe)
 
@@ -246,14 +246,15 @@ trait Trees extends api.Trees {
       new ForeachPartialTreeTraverser(pf).traverse(this)
     }
 
-    def changeOwner(pairs: (Symbol, Symbol)*): Tree = {
-      pairs.foldLeft(this) { case (t, (oldOwner, newOwner)) =>
-        new ChangeOwnerTraverser(oldOwner, newOwner) apply t
+    def changeOwner(pairs: (Symbol, Symbol)*): this.type = {
+      pairs.foreach {
+        case (oldOwner, newOwner) => changeOwner(oldOwner, newOwner)
       }
+      this
     }
 
-    def changeOwner(from: Symbol, to: Symbol): Tree =
-      new ChangeOwnerTraverser(from, to) apply this
+    def changeOwner(from: Symbol, to: Symbol): this.type =
+      new ChangeOwnerTraverser(from, to).apply(this)
 
     def shallowDuplicate: Tree = new ShallowDuplicator(this) transform this
     def shortClass: String = (getClass.getName split "[.$]").last
@@ -1489,6 +1490,7 @@ trait Trees extends api.Trees {
   }
   class InternalTraverser extends Traverser {
     override def traverse(tree: Tree): Unit = tree.traverse(this)
+    override def apply[T <: Tree](tree: T): tree.type = super.apply(tree)
   }
 
   def newValDef(sym: Symbol, rhs: Tree)(
@@ -1635,7 +1637,7 @@ trait Trees extends api.Trees {
       }
     }
 
-    override def apply[T <: Tree](tree: T): T = {
+    override def apply[T <: Tree](tree: T): tree.type = {
       traverse(tree)
       if (changedSymbols.nonEmpty)
         new InvalidateTypeCaches(changedSymbols).invalidate(treeTypes)
@@ -1750,7 +1752,7 @@ trait Trees extends api.Trees {
 
       tree.traverse(this)
     }
-    override def apply[T <: Tree](tree: T): T = super.apply(tree.duplicate)
+    override def apply[T <: Tree](tree: T): tree.type = super.apply(tree.duplicate)
   }
 
   class TreeTypeSubstituter(val from: List[Symbol], val to: List[Type]) extends TypeMapTreeSubstituter(new SubstTypeMap(from, to)) {
diff --git a/src/reflect/scala/reflect/internal/util/CodeAction.scala b/src/reflect/scala/reflect/internal/util/CodeAction.scala
index b8525ebbff..26724b461d 100644
--- a/src/reflect/scala/reflect/internal/util/CodeAction.scala
+++ b/src/reflect/scala/reflect/internal/util/CodeAction.scala
@@ -29,6 +29,16 @@ package util
  */
 case class CodeAction(title: String, description: Option[String], edits: List[TextEdit])
 
+object CodeAction {
+  def apply(title: String, pos: Position, newText: String, desc: String, check: => Boolean = true): List[CodeAction] =
+    if (check) List(CodeAction(title, Some(desc), List(TextEdit(pos, newText))))
+    else Nil
+
+  private lazy val parens = raw"\(.*\)".r
+  def maybeWrapInParens(s: String) = if (s.contains(" ") && !parens.matches(s)) s"($s)" else s
+  def wrapInParens(s: String) = if (!parens.matches(s)) s"($s)" else s
+}
+
 /**
  *  <span class="badge badge-red" style="float: right;">EXPERIMENTAL</span>
  *
@@ -36,4 +46,6 @@ case class CodeAction(title: String, description: Option[String], edits: List[Te
  *  @groupname Common   Commonly used methods
  *  @group ReflectionAPI
  */
-case class TextEdit(position: Position, newText: String)
+case class TextEdit(position: Position, newText: String) {
+  def delta: Int = newText.length - (position.end - position.start)
+}
diff --git a/src/reflect/scala/reflect/internal/util/Collections.scala b/src/reflect/scala/reflect/internal/util/Collections.scala
index ee0aef7bce..f27a8e2611 100644
--- a/src/reflect/scala/reflect/internal/util/Collections.scala
+++ b/src/reflect/scala/reflect/internal/util/Collections.scala
@@ -14,6 +14,7 @@ package scala
 package reflect.internal.util
 
 import scala.reflect.ClassTag
+import scala.collection.AbstractIterator
 import scala.collection.{immutable, mutable}
 import scala.annotation.tailrec
 import mutable.ListBuffer
@@ -314,7 +315,7 @@ trait Collections {
   }
 
   final def mapFilter2[A, B, C](itA: Iterator[A], itB: Iterator[B])(f: (A, B) => Option[C]): Iterator[C] =
-    new Iterator[C] {
+    new AbstractIterator[C] {
       private[this] var head: Option[C] = None
       private[this] def advanceHead(): Unit =
         while (head.isEmpty && itA.hasNext && itB.hasNext) {
diff --git a/src/reflect/scala/reflect/runtime/SynchronizedSymbols.scala b/src/reflect/scala/reflect/runtime/SynchronizedSymbols.scala
index 0c6ff7bc04..5cc4dc1395 100644
--- a/src/reflect/scala/reflect/runtime/SynchronizedSymbols.scala
+++ b/src/reflect/scala/reflect/runtime/SynchronizedSymbols.scala
@@ -32,7 +32,7 @@ private[reflect] trait SynchronizedSymbols extends internal.Symbols { self: Symb
   override def recursionTable_=(value: immutable.Map[Symbol, Int]) = _recursionTable.set(value)
 
   // Set the fields which point companions at one another.  Returns the module.
-  override def connectModuleToClass(m: ModuleSymbol, moduleClass: ClassSymbol): ModuleSymbol =
+  override def connectModuleToClass(m: ModuleSymbol, moduleClass: ClassSymbol): m.type =
     gilSynchronized { super.connectModuleToClass(m, moduleClass) }
 
   override def newFreeTermSymbol(name: TermName, value: => Any, flags: Long = 0L, origin: String = null): FreeTermSymbol =
diff --git a/src/repl-frontend/scala/tools/nsc/interpreter/shell/Reporter.scala b/src/repl-frontend/scala/tools/nsc/interpreter/shell/Reporter.scala
index e8069b6427..8d97a8de01 100644
--- a/src/repl-frontend/scala/tools/nsc/interpreter/shell/Reporter.scala
+++ b/src/repl-frontend/scala/tools/nsc/interpreter/shell/Reporter.scala
@@ -16,7 +16,7 @@ import java.io.PrintWriter
 import scala.reflect.internal
 import scala.reflect.internal.util.{CodeAction, NoSourceFile, Position, StringOps}
 import scala.tools.nsc.interpreter.{Naming, ReplReporter, ReplRequest}
-import scala.tools.nsc.reporters.{FilteringReporter, Reporter}
+import scala.tools.nsc.reporters.FilteringReporter
 import scala.tools.nsc.{ConsoleWriter, NewLinePrintWriter, Settings}
 
 object ReplReporterImpl {
@@ -154,30 +154,15 @@ class ReplReporterImpl(val config: ShellConfig, val settings: Settings = new Set
       if (colorOk) severityColor(severity) + clabel(severity) + RESET
       else clabel(severity)
 
-    printMessage(pos, prefix + msg)
+    printMessageAt(pos, prefix + msg)
   }
 
-  private var boringExplanations = Set.empty[String]
-
   // indent errors, error message uses the caret to point at the line already on the screen instead of repeating it
   // TODO: can we splice the error into the code the user typed when multiple lines were entered?
   // (should also comment out the error to keep multi-line copy/pastable)
   // TODO: multiple errors are not very intuitive (should the second error for same line repeat the line?)
   // TODO: the console could be empty due to external changes (also, :reset? -- see unfortunate example in jvm/interpreter (plusOne))
-  def printMessage(posIn: Position, msg0: String): Unit = {
-    val msg = {
-      val main = Reporter.stripExplanation(msg0)
-      if (main eq msg0) main
-      else {
-        val (_, explanation) = Reporter.splitExplanation(msg0)
-        val suffix = explanation.mkString("\n")
-        if (boringExplanations(suffix)) main
-        else {
-          boringExplanations += suffix
-          s"$main\n$suffix"
-        }
-      }
-    }
+  def printMessageAt(posIn: Position, msg: String): Unit = {
     if ((posIn eq null) || (posIn.source eq NoSourceFile)) printMessage(msg)
     else if (posIn.source.file.name == "<console>" && posIn.line == 1) {
       // If there's only one line of input, and it's already printed on the console (as indicated by the position's source file name),
diff --git a/src/sbt-bridge/scala/tools/xsbt/API.scala b/src/sbt-bridge/scala/tools/xsbt/API.scala
new file mode 100644
index 0000000000..7dea9b705b
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/API.scala
@@ -0,0 +1,221 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import scala.tools.nsc.Phase
+import scala.tools.nsc.symtab.Flags
+import xsbti.api._
+import xsbti.VirtualFile
+
+object API {
+  val name = "xsbt-api"
+}
+
+final class API(val global: CallbackGlobal) extends Compat with GlobalHelpers with ClassName {
+  import global._
+
+  import scala.collection.mutable
+  private val nonLocalClassSymbolsInCurrentUnits = new mutable.HashSet[Symbol]()
+
+  def newPhase(prev: Phase) = new ApiPhase(prev)
+  class ApiPhase(prev: Phase) extends GlobalPhase(prev) {
+    override def description = "Extracts the public API from source files."
+    def name = API.name
+    override def run(): Unit = {
+      val start = System.currentTimeMillis
+      super.run()
+
+      // After processing all units, register generated classes
+      registerGeneratedClasses(nonLocalClassSymbolsInCurrentUnits.iterator)
+      nonLocalClassSymbolsInCurrentUnits.clear()
+
+      callback.apiPhaseCompleted()
+      val stop = System.currentTimeMillis
+      debuglog("API phase took : " + ((stop - start) / 1000.0) + " s")
+    }
+
+    // TODO In 2.13, shouldSkipThisPhaseForJava should be overridden instead of cancelled
+    // override def shouldSkipThisPhaseForJava = !global.callback.isPickleJava
+    override def cancelled(unit: CompilationUnit) = {
+      if (Thread.interrupted()) reporter.cancelled = true
+      reporter.cancelled || unit.isJava && !global.callback.isPickleJava
+    }
+
+    def apply(unit: global.CompilationUnit): Unit = processUnit(unit)
+
+    private def processUnit(unit: CompilationUnit): Unit = {
+      if (!unit.isJava || global.callback.isPickleJava) {
+        processScalaUnit(unit)
+      }
+    }
+
+    private def processScalaUnit(unit: CompilationUnit): Unit = {
+      val sourceFile: VirtualFile = unit.source.file match { case AbstractZincFile(vf) => vf case x => throw new MatchError(x) }
+      debuglog("Traversing " + sourceFile)
+      callback.startSource(sourceFile)
+      val extractApi = new ExtractAPI[global.type](global, sourceFile)
+      val traverser = new TopLevelHandler(extractApi)
+      traverser.apply(unit.body)
+
+      val extractUsedNames = new ExtractUsedNames[global.type](global)
+      extractUsedNames.extractAndReport(unit)
+
+      val classApis = traverser.allNonLocalClasses
+      val mainClasses = traverser.mainClasses
+
+      // Use of iterators make this code easier to profile
+
+      val classApisIt = classApis.iterator
+      while (classApisIt.hasNext) {
+        callback.api(sourceFile, classApisIt.next())
+      }
+
+      val mainClassesIt = mainClasses.iterator
+      while (mainClassesIt.hasNext) {
+        callback.mainClass(sourceFile, mainClassesIt.next())
+      }
+
+      extractApi.allExtractedNonLocalSymbols.foreach { cs =>
+        // Only add the class symbols defined in this compilation unit
+        if (cs.sourceFile != null) nonLocalClassSymbolsInCurrentUnits.+=(cs)
+      }
+    }
+  }
+
+  private case class FlattenedNames(binaryName: String, className: String)
+
+  /**
+   * Registers only non-local generated classes in the callback by extracting
+   * information about its names and using the names to generate class file paths.
+   *
+   * Mimics the previous logic that was present in `Analyzer`, despite the fact
+   * that now we construct the names that the compiler will give to every non-local
+   * class independently of genbcode.
+   *
+   * Why do we do this? The motivation is that we want to run the incremental algorithm
+   * independently of the compiler pipeline. This independence enables us to:
+   *
+   * 1. Offload the incremental compiler logic out of the primary pipeline and
+   *    run the incremental phases concurrently.
+   * 2. Know before the compilation is completed whether another compilation will or
+   *    will not be required. This is important to make incremental compilation work
+   *    with pipelining and enables further optimizations; for example, we can start
+   *    subsequent incremental compilations before (!) the initial compilation is done.
+   *    This can buy us ~30-40% faster incremental compiler iterations.
+   *
+   * This method only takes care of non-local classes because local classes have no
+   * relevance in the correctness of the algorithm and can be registered after genbcode.
+   * Local classes are only used to construct the relations of products and to produce
+   * the list of generated files + stamps, but names referring to local classes **never**
+   * show up in the name hashes of classes' APIs, hence never considered for name hashing.
+   *
+   * As local class files are owned by other classes that change whenever they change,
+   * we could most likely live without adding their class files to the products relation
+   * and registering their stamps. However, to be on the safe side, we will continue to
+   * register the local products in `Analyzer`.
+   *
+   * @param allClassSymbols The class symbols found in all the compilation units.
+   */
+  def registerGeneratedClasses(classSymbols: Iterator[Symbol]): Unit = {
+    classSymbols.foreach { symbol =>
+      val sourceFile = symbol.sourceFile
+      val sourceVF0 =
+        if (sourceFile == null) symbol.enclosingTopLevelClass.sourceFile
+        else sourceFile
+      val sourceVF: Option[VirtualFile] = sourceVF0 match {
+        case AbstractZincFile(vf) => Some(vf)
+        // This could be scala.reflect.io.FileZipArchive$LeakyEntry
+        case _ => None
+      }
+
+      def registerProductNames(names: FlattenedNames): Unit = {
+        // Guard against a local class in case it surreptitiously leaks here
+        if (!symbol.isLocalClass) {
+          val pathToClassFile = s"${names.binaryName}.class"
+          val classFile = {
+            JarUtils.outputJar match {
+              case Some(outputJar) =>
+                new java.io.File(JarUtils.classNameInJar(outputJar, pathToClassFile))
+              case None =>
+                val outputDir = global.settings.outputDirs.outputDirFor(sourceFile).file
+                new java.io.File(outputDir, pathToClassFile)
+            }
+          }
+          val zincClassName = names.className
+          val srcClassName = classNameAsString(symbol)
+          sourceVF foreach { source =>
+            callback.generatedNonLocalClass(
+              source,
+              classFile.toPath,
+              zincClassName,
+              srcClassName
+            )
+          }
+        } else ()
+      }
+
+      val names = FlattenedNames(
+        fullName(symbol, java.io.File.separatorChar, symbol.moduleSuffix, true),
+        fullName(symbol, '.', symbol.moduleSuffix, false)
+      )
+
+      registerProductNames(names)
+
+      // Register the names of top-level module symbols that emit two class files
+      val isTopLevelUniqueModule =
+        symbol.owner.isPackageClass && symbol.isModuleClass && symbol.companionClass == NoSymbol
+      if (isTopLevelUniqueModule || symbol.isPackageObject) {
+        val names = FlattenedNames(
+          fullName(symbol, java.io.File.separatorChar, "", true),
+          fullName(symbol, '.', "", false)
+        )
+        registerProductNames(names)
+      }
+    }
+  }
+
+  private final class TopLevelHandler(extractApi: ExtractAPI[global.type])
+      extends TopLevelTraverser {
+    def allNonLocalClasses: Set[ClassLike] = {
+      extractApi.allExtractedNonLocalClasses
+    }
+
+    def mainClasses: Set[String] = extractApi.mainClasses
+
+    def `class`(c: Symbol): Unit = {
+      extractApi.extractAllClassesOf(c.owner, c)
+    }
+  }
+
+  private abstract class TopLevelTraverser extends Traverser {
+    def `class`(s: Symbol): Unit
+    override def traverse(tree: Tree): Unit = {
+      tree match {
+        case (_: ClassDef | _: ModuleDef) if isTopLevel(tree.symbol) => `class`(tree.symbol)
+        case _: PackageDef =>
+          super.traverse(tree)
+        case _ =>
+      }
+    }
+    def isTopLevel(sym: Symbol): Boolean = {
+      !ignoredSymbol(sym) &&
+      sym.isStatic &&
+      (!sym.hasFlag(Flags.JAVA) || global.callback.isPickleJava) &&
+      !sym.isNestedClass
+    }
+  }
+
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/AbstractZincFile.scala b/src/sbt-bridge/scala/tools/xsbt/AbstractZincFile.scala
new file mode 100644
index 0000000000..35a388beac
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/AbstractZincFile.scala
@@ -0,0 +1,45 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import xsbti.{ PathBasedFile, VirtualFile }
+import scala.reflect.io.Streamable
+
+private trait AbstractZincFile extends scala.reflect.io.AbstractFile {
+  def underlying: VirtualFile
+}
+
+private final class ZincPlainFile private[xsbt] (val underlying: PathBasedFile)
+    extends scala.reflect.io.PlainFile(scala.reflect.io.Path(underlying.toPath.toFile))
+    with AbstractZincFile
+
+private final class ZincVirtualFile private[xsbt] (val underlying: VirtualFile)
+    extends scala.reflect.io.VirtualFile(underlying.name, underlying.id)
+    with AbstractZincFile {
+  Streamable.closing(output)(_.write(Streamable.bytes(underlying.input))) // fill in the content
+}
+
+private object AbstractZincFile {
+  def apply(virtualFile: VirtualFile): AbstractZincFile = virtualFile match {
+    case file: PathBasedFile => new ZincPlainFile(file)
+    case _                   => new ZincVirtualFile(virtualFile)
+  }
+
+  def unapply(file: scala.reflect.io.AbstractFile): Option[VirtualFile] = file match {
+    case wrapper: AbstractZincFile => Some(wrapper.underlying)
+    case _                         => None
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/Analyzer.scala b/src/sbt-bridge/scala/tools/xsbt/Analyzer.scala
new file mode 100644
index 0000000000..96954b8dcb
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/Analyzer.scala
@@ -0,0 +1,106 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.nio.file.Path
+import java.io.File
+import xsbti.VirtualFile
+import scala.tools.nsc.Phase
+import scala.jdk.CollectionConverters._
+
+object Analyzer {
+  def name = "xsbt-analyzer"
+}
+
+final class Analyzer(val global: CallbackGlobal) extends LocateClassFile {
+  import global._
+
+  def newPhase(prev: Phase): Phase = new AnalyzerPhase(prev)
+  private class AnalyzerPhase(prev: Phase) extends GlobalPhase(prev) {
+    override def description =
+      "Finds concrete instances of provided superclasses, and application entry points."
+    def name = Analyzer.name
+
+    /**
+     * When straight-to-jar compilation is enabled, returns the classes
+     * that are found in the jar of the last compilation. This method
+     * gets the existing classes from the analysis callback and adapts
+     * it for consumption in the compiler bridge.
+     *
+     * It's lazy because it triggers a read of the zip, which may be
+     * unnecessary if there are no local classes in a compilation unit.
+     */
+    private lazy val classesWrittenByGenbcode: Set[String] = {
+      JarUtils.outputJar match {
+        case Some(jar) =>
+          val classes = global.callback.classesInOutputJar().asScala
+          classes.map(JarUtils.classNameInJar(jar, _)).toSet
+        case None => Set.empty
+      }
+    }
+
+    def apply(unit: CompilationUnit): Unit = {
+      if (!unit.isJava) {
+        val sourceFile0: AbstractZincFile = unit.source.file match { case v: AbstractZincFile => v case x => throw new MatchError(x) }
+        val sourceFile: VirtualFile = sourceFile0.underlying
+        lazy val outputDir = settings.outputDirs.outputDirFor(sourceFile0).file
+        for (iclass <- unit.icode) {
+          val sym = iclass.symbol
+          def addGenerated(separatorRequired: Boolean): Unit = {
+            val locatedClass = {
+              JarUtils.outputJar match {
+                case Some(outputJar) => locateClassInJar(sym, outputJar, separatorRequired)
+                case None            => locatePlainClassFile(sym, outputDir, separatorRequired)
+              }
+            }
+
+            locatedClass.foreach { classFile =>
+              assert(sym.isClass, s"${sym.fullName} is not a class")
+              // Use own map of local classes computed before lambdalift to ascertain class locality
+              if (localToNonLocalClass.isLocal(sym).getOrElse(true)) {
+                // Inform callback about local classes, non-local classes have been reported in API
+                callback.generatedLocalClass(sourceFile, classFile.toPath)
+              }
+            }
+          }
+
+          if (sym.isModuleClass) {
+            if (isTopLevelModule(sym) && sym.companionClass == NoSymbol)
+              addGenerated(false)
+            addGenerated(true)
+          } else
+            addGenerated(false)
+        }
+      }
+    }
+
+    private def locatePlainClassFile(
+        sym: Symbol,
+        outputDir: File,
+        separatorRequired: Boolean
+    ): Option[File] = {
+      val classFile = fileForClass(outputDir, sym, separatorRequired)
+      if (classFile.exists()) Some(classFile) else None
+    }
+
+    private def locateClassInJar(sym: Symbol, jar: Path, sepRequired: Boolean): Option[File] = {
+      val classFile = pathToClassFile(sym, sepRequired)
+      val classInJar = JarUtils.classNameInJar(jar, classFile)
+      if (!classesWrittenByGenbcode.contains(classInJar)) None
+      else Some(new File(classInJar))
+    }
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/CallbackGlobal.scala b/src/sbt-bridge/scala/tools/xsbt/CallbackGlobal.scala
new file mode 100644
index 0000000000..25af9b0620
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/CallbackGlobal.scala
@@ -0,0 +1,285 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import xsbti.{ AnalysisCallback, Severity }
+import xsbti.compile._
+
+import scala.tools.nsc._
+import io.AbstractFile
+import java.nio.file.{ Files, Path }
+
+import scala.reflect.io.PlainFile
+
+/** Defines the interface of the incremental compiler hiding implementation details. */
+sealed abstract class CallbackGlobal(
+    settings: Settings,
+    reporter: reporters.Reporter,
+    output: Output
+) extends Global(settings, reporter) {
+
+  def callback: AnalysisCallback
+  def findAssociatedFile(name: String): Option[(AbstractFile, Boolean)]
+
+  def fullName(
+      symbol: Symbol,
+      separator: Char,
+      suffix: CharSequence,
+      includePackageObjectClassNames: Boolean
+  ): String
+
+  lazy val outputDirs: Iterable[Path] = {
+    output match {
+      case single: SingleOutput => List(single.getOutputDirectoryAsPath)
+      // Use Stream instead of List because Analyzer maps intensively over the directories
+      case multi: MultipleOutput =>
+        multi.getOutputGroups.iterator.map(_.getOutputDirectoryAsPath).toSeq
+      case x => throw new MatchError(x)
+    }
+  }
+
+  lazy val JarUtils = new JarUtils(outputDirs)
+
+  /**
+   * Defines the sbt phase in which the dependency analysis is performed.
+   * The reason why this is exposed in the callback global is because it's used
+   * in [[xsbt.LocalToNonLocalClass]] to make sure the we don't resolve local
+   * classes before we reach this phase.
+   */
+  private[xsbt] val sbtDependency: SubComponent
+
+  /**
+   * A map from local classes to non-local class that contains it.
+   *
+   * This map is used by both Dependency and Analyzer phase so it has to be
+   * exposed here. The Analyzer phase uses the cached lookups performed by
+   * the Dependency phase. By the time Analyzer phase is run (close to backend
+   * phases), original owner chains are lost so Analyzer phase relies on
+   * information saved before.
+   *
+   * The LocalToNonLocalClass duplicates the tracking that Scala compiler does
+   * internally for backed purposes (generation of EnclosingClass attributes) but
+   * that internal mapping doesn't have a stable interface we could rely on.
+   */
+  private[xsbt] val localToNonLocalClass = new LocalToNonLocalClass[this.type](this)
+}
+
+/** Defines the implementation of Zinc with all its corresponding phases. */
+sealed class ZincCompiler(settings: Settings, dreporter: DelegatingReporter, output: Output)
+    extends CallbackGlobal(settings, dreporter, output)
+    with ZincGlobalCompat {
+
+  final class ZincRun(compileProgress: CompileProgress) extends Run {
+    override def informUnitStarting(phase: Phase, unit: CompilationUnit): Unit = {
+      compileProgress.startUnit(phase.name, unit.source.path)
+    }
+
+    override def progress(current: Int, total: Int): Unit = {
+      if (!compileProgress.advance(current, total, phase.name, phase.next.name)) cancel()
+      else ()
+    }
+  }
+
+  object dummy // temporary fix for #4426
+
+  /** Phase that analyzes the generated class files and maps them to sources. */
+  object sbtAnalyzer extends {
+        val global: ZincCompiler.this.type = ZincCompiler.this
+        val phaseName = Analyzer.name
+        val runsAfter = List("jvm")
+        override val runsBefore = List("terminal")
+        val runsRightAfter = None
+      } with SubComponent {
+    val analyzer = new Analyzer(global)
+    def newPhase(prev: Phase) = analyzer.newPhase(prev)
+    def name = phaseName
+  }
+
+  /** Phase that extracts dependency information */
+  object sbtDependency extends {
+        val global: ZincCompiler.this.type = ZincCompiler.this
+        val phaseName = Dependency.name
+        val runsAfter = List(API.name)
+        override val runsBefore = List("refchecks")
+        // Keep API and dependency close to each other -- we may want to merge them in the future.
+        override val runsRightAfter = Some(API.name)
+      } with SubComponent {
+    val dependency = new Dependency(global)
+    def newPhase(prev: Phase) = dependency.newPhase(prev)
+    def name = phaseName
+  }
+
+  /**
+   * Phase that walks the trees and constructs a representation of the public API.
+   *
+   * @note It extracts the API information after picklers to see the same symbol information
+   *       irrespective of whether we typecheck from source or unpickle previously compiled classes.
+   */
+  object apiExtractor extends {
+        val global: ZincCompiler.this.type = ZincCompiler.this
+        val phaseName = API.name
+        val runsAfter = List("typer")
+        override val runsBefore = List("erasure")
+        // TODO: Consider migrating to "uncurry" for `runsBefore`.
+        // TODO: Consider removing the system property to modify which phase is used for API extraction.
+        val runsRightAfter = Option(System.getProperty("sbt.api.phase")) orElse Some("pickler")
+      } with SubComponent {
+    val api = new API(global)
+    def newPhase(prev: Phase) = api.newPhase(prev)
+    def name = phaseName
+  }
+
+  override lazy val phaseDescriptors = {
+    phasesSet += sbtAnalyzer
+    if (callback.enabled()) {
+      phasesSet += sbtDependency
+      phasesSet += apiExtractor
+    }
+    this.computePhaseDescriptors
+  }
+
+  private final val fqnsToAssociatedFiles = perRunCaches.newMap[String, (AbstractFile, Boolean)]()
+
+  /**
+   * Returns the associated file of a fully qualified name and whether it's on the classpath.
+   * Note that the abstract file returned must exist.
+   */
+  def findAssociatedFile(fqn: String): Option[(AbstractFile, Boolean)] = {
+    def findOnPreviousCompilationProducts(name: String): Option[AbstractFile] = {
+      // This class file path is relative to the output jar/directory and computed from class name
+      val classFilePath = name.replace('.', '/') + ".class"
+
+      JarUtils.outputJar match {
+        case Some(outputJar) =>
+          if (!callback.classesInOutputJar().contains(classFilePath)) None
+          else {
+            /*
+             * Important implementation detail: `classInJar` has the format of `$JAR!$CLASS_REF`
+             * which is, of course, a path to a file that does not exist. This file path is
+             * interpreted especially by Zinc to decompose the format under straight-to-jar
+             * compilation. For this strategy to work, `PlainFile` must **not** check that
+             * this file does exist or not because, if it does, it will return `null` in
+             * `processExternalDependency` and the dependency will not be correctly registered.
+             * If scalac breaks this contract (the check for existence is done when creating
+             * a normal reflect file but not a plain file), Zinc will not work correctly.
+             */
+            Some(new PlainFile(JarUtils.classNameInJar(outputJar, classFilePath)))
+          }
+
+        case None => // The compiler outputs class files in a classes directory (the default)
+          // This lookup could be improved if a hint where to look is given.
+          if (classFilePath.contains("<")) None
+          else
+            outputDirs
+              .map(_.resolve(classFilePath))
+              .find(Files.exists(_))
+              .map(ZincCompat.plainNioFile(_))
+      }
+    }
+
+    def findOnClassPath(name: String): Option[AbstractFile] =
+      classPath.findClass(name).flatMap(_.binary.asInstanceOf[Option[AbstractFile]])
+
+    fqnsToAssociatedFiles.get(fqn).orElse {
+      val newResult = findOnPreviousCompilationProducts(fqn)
+        .map(f => (f, true))
+        .orElse(findOnClassPath(fqn).map(f => (f, false)))
+
+      newResult.foreach(res => fqnsToAssociatedFiles.put(fqn, res))
+      newResult
+    }
+  }
+
+  /**
+   * Replicate the behaviour of `fullName` with a few changes to the code to produce
+   * correct file-system compatible full names for non-local classes. It mimics the
+   * paths of the class files produced by genbcode.
+   *
+   * Changes compared to the normal version in the compiler:
+   *
+   * 1. It will use the encoded name instead of the normal n2. It will not skip the name of the package object class (required for the class file path).
+   *
+   * Note that using `javaBinaryName` is not useful for these symbols because we
+   * need the encoded names. Zinc keeps track of encoded names in both the binary
+   * names and the Zinc names.
+   *
+   * @param symbol The symbol for which we extract the full name.
+   * @param separator The separator that we will apply between every name.
+   * @param suffix The suffix to add at the end (in case it's a module).
+   * @param includePackageObjectClassNames Include package object class names or not.
+   * @return The full name.
+   */
+  override def fullName(
+      symbol: Symbol,
+      separator: Char,
+      suffix: CharSequence,
+      includePackageObjectClassNames: Boolean
+  ): String = {
+    def loop(sb: StringBuilder, size: Int, sym: Symbol): StringBuilder = {
+      val symName = sym.name
+      // Use of encoded to produce correct paths for names that have symbols
+      val encodedName = symName.encode
+      val nSize = encodedName.length - (if (symName.endsWith(nme.LOCAL_SUFFIX_STRING)) 1 else 0)
+      val sb1 =
+        if (sym.isRoot || sym.isRootPackage || sym == NoSymbol || sym.owner.isEffectiveRoot) {
+          val capacity = size + nSize
+          new StringBuilder(capacity)
+        } else {
+          val next = if (sym.owner.isPackageObjectClass) sym.owner else sym.effectiveOwner.enclClass
+          // Addition to normal `fullName` to produce correct names for nested non-local classes
+          val sep = if (sym.isNestedClass) nme.MODULE_SUFFIX_STRING else separator
+          loop(sb, size + nSize + 1, next)
+            .append(sep)
+        }
+      encodedName.appendTo(sb1, 0, nSize)
+    }
+    loop(sb = null, suffix.length(), symbol)
+      .append(suffix)
+      .toString
+  }
+
+  private[this] var callback0: AnalysisCallback = null
+
+  /** Returns the active analysis callback, set by [[set]] and cleared by [[clear]]. */
+  def callback: AnalysisCallback = callback0
+
+  final def set(callback: AnalysisCallback, dreporter: DelegatingReporter): Unit = {
+    this.callback0 = callback
+    reporter = dreporter
+  }
+
+  final def clear(): Unit = {
+    callback0 = null
+    superDropRun()
+    reporter = null
+    this match {
+      case c: java.io.Closeable => c.close()
+      case _                    =>
+    }
+  }
+
+  // Scala 2.10.x and later
+  private[xsbt] def logUnreportedWarnings(seq: Seq[(String, List[(Position, String)])]): Unit = {
+    for ((what, warnings) <- seq; (pos, msg) <- warnings)
+      yield callback.problem(what, DelegatingReporter.convert(pos), msg, Severity.Warn, false)
+    ()
+  }
+}
+
+import scala.reflect.internal.Positions
+final class ZincCompilerRangePos(settings: Settings, dreporter: DelegatingReporter, output: Output)
+    extends ZincCompiler(settings, dreporter, output)
+    with Positions
diff --git a/src/sbt-bridge/scala/tools/xsbt/ClassName.scala b/src/sbt-bridge/scala/tools/xsbt/ClassName.scala
new file mode 100644
index 0000000000..910c1f3893
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/ClassName.scala
@@ -0,0 +1,107 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import scala.tools.nsc.Global
+
+/**
+ * Utility methods for creating (source|binary) class names for a Symbol.
+ */
+trait ClassName extends Compat {
+  val global: Global
+  import global._
+
+  /**
+   * Creates a flat (binary) name for a class symbol `s`.
+   */
+  protected def flatname(s: Symbol, separator: Char) =
+    enteringPhase(currentRun.flattenPhase.next) { s fullName separator }
+
+  /**
+   * Create a (source) name for a class symbol `s`.
+   */
+  protected def className(s: Symbol): Name = pickledName(s)
+
+  /**
+   * Create a String (source) name for a class symbol `s`.
+   */
+  protected def classNameAsString(s: Symbol): String = pickledNameAsString(s)
+
+  /**
+   * Given a class symbol `cls`, construct a name representing this constructor.
+   * For a class:
+   *
+   *     a.b.Foo
+   *
+   * this is:
+   *
+   *     a;b;Foo;init;
+   *
+   * The prefix is important to avoid name hashing all constructors together
+   * (see #97), the weird format is necessary to avoid scalac or zinc trying to
+   * interpret this name (in particular we should not use '.' and we should not
+   * use '<init>'), we use ';' because it is one of the few characters that
+   * cannot appear in a valid JVM name.
+   */
+  protected def constructorName(cls: Symbol): Name =
+    newTermName(constructorNameAsString(cls))
+
+  protected def constructorNameAsString(cls: Symbol): String =
+    cls.fullName(';') ++ ";init;"
+
+  /**
+   * Mangle a JVM symbol name in a format better suited for internal uses by sbt.
+   */
+  protected def mangledName(s: Symbol): Name =
+    if (s.name == nme.CONSTRUCTOR)
+      constructorName(s.enclClass)
+    else
+      s.name
+
+  /**
+   * Create a (source) name for the class symbol `s` with a prefix determined by the class symbol `in`.
+   *
+   * If `s` represents a package object `pkg3`, then the returned name will be `pkg1.pkg2.pkg3.package`.
+   * If `s` represents a class `Foo` nested in package object `pkg3` then the returned name is `pkg1.pkg2.pk3.Foo`.
+   *
+   * Note that some objects with special access rights are encoded in names
+   * (like qualified privates `private[qualifier]`). In order to get the right
+   * original names, we need to use `unexpandedName`.
+   */
+  protected def classNameAsSeenIn(in: Symbol, s: Symbol): String =
+    enteringPhase(currentRun.picklerPhase.next) {
+      if (in.isRoot || in.isRootPackage || in == NoSymbol || in.isEffectiveRoot)
+        s.simpleName.toString
+      else if (in.isPackageObjectOrClass)
+        in.owner.fullName + "." + s.unexpandedName
+      else
+        in.fullName + "." + s.unexpandedName
+    }
+
+  private def pickledName(s: Symbol): Name =
+    enteringPhase(currentRun.picklerPhase.next) { s.fullNameAsName('.') }
+
+  private def pickledNameAsString(s: Symbol): String =
+    enteringPhase(currentRun.picklerPhase.next) { s.fullName }
+
+  protected def isTopLevelModule(sym: Symbol): Boolean =
+    enteringPhase(currentRun.picklerPhase.next) {
+      sym.isModuleClass && !sym.isNestedClass
+    }
+
+  protected def flatclassName(s: Symbol, sep: Char, dollarRequired: Boolean): String =
+    flatname(s, sep) + (if (dollarRequired) "$" else "")
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/Compat.scala b/src/sbt-bridge/scala/tools/xsbt/Compat.scala
new file mode 100644
index 0000000000..167d0b1fff
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/Compat.scala
@@ -0,0 +1,53 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.io.PrintWriter
+import xsbti.compile.Output
+import scala.tools.nsc.Global
+import scala.tools.nsc.Settings
+import scala.tools.nsc.interpreter.shell.ReplReporterImpl
+
+abstract class Compat {
+  val global: Global
+  import global._
+
+  /** If given tree contains object tree attachment calls func on tree from attachment. */
+  protected def processOriginalTreeAttachment(in: Tree)(func: Tree => Unit): Unit = {
+    import analyzer._
+    in.attachments.get[OriginalTreeAttachment].foreach { a =>
+      func(a.original)
+    }
+  }
+}
+object Compat {
+  // IR is renamed to Results
+  val Results = scala.tools.nsc.interpreter.Results
+
+  // IMain in 2.13 accepts ReplReporter
+  def replReporter(settings: Settings, writer: PrintWriter) =
+    new ReplReporterImpl(settings, writer)
+}
+
+/** Defines compatibility utils for [[ZincCompiler]]. */
+trait ZincGlobalCompat {
+  protected def superDropRun(): Unit = ()
+}
+
+private trait CachedCompilerCompat { self: CachedCompiler0 =>
+  def newCompiler(settings: Settings, reporter: DelegatingReporter, output: Output): ZincCompiler =
+    new ZincCompiler(settings, reporter, output)
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/CompilerBridge.scala b/src/sbt-bridge/scala/tools/xsbt/CompilerBridge.scala
new file mode 100644
index 0000000000..e75658604f
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/CompilerBridge.scala
@@ -0,0 +1,201 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import xsbti.{AnalysisCallback, AnalysisCallback2, Logger, Problem, Reporter, VirtualFile}
+import xsbti.compile._
+
+import scala.reflect.io.AbstractFile
+import scala.tools.nsc.{CompilerCommand, Settings}
+import Log.debug
+
+import java.io.File
+
+/**
+ * This is the entry point for the compiler bridge (implementation of CompilerInterface)
+ */
+final class CompilerBridge extends xsbti.compile.CompilerInterface2 {
+  override def run(
+      sources: Array[VirtualFile],
+      changes: DependencyChanges,
+      options: Array[String],
+      output: Output,
+      callback: AnalysisCallback,
+      delegate: Reporter,
+      progress: CompileProgress,
+      log: Logger
+  ): Unit = {
+    val cached = new CachedCompiler0(options, output, new WeakLog(log, delegate))
+    try {
+      cached.run(sources.toList, changes, callback, log, delegate, progress)
+    } finally {
+      cached.close()
+    }
+  }
+}
+
+class InterfaceCompileFailed(
+    val arguments: Array[String],
+    val problems: Array[Problem],
+    override val toString: String
+) extends xsbti.CompileFailed
+
+class InterfaceCompileCancelled(val arguments: Array[String], override val toString: String)
+    extends xsbti.CompileCancelled
+
+private final class WeakLog(private[this] var log: Logger, private[this] var delegate: Reporter) {
+  def apply(message: String): Unit = {
+    assert(log ne null, "Stale reference to logger")
+    log.error(Message(message))
+  }
+  def logger: Logger = log
+  def reporter: Reporter = delegate
+  def clear(): Unit = {
+    log = null
+    delegate = null
+  }
+}
+
+private final class CachedCompiler0(
+    args: Array[String],
+    output: Output,
+    initialLog: WeakLog
+) extends CachedCompilerCompat
+    with java.io.Closeable {
+
+  /////////////////////////////////////////////////////////////////////////////////////////////////
+  //////////////////////////////////// INITIALIZATION CODE ////////////////////////////////////////
+  /////////////////////////////////////////////////////////////////////////////////////////////////
+
+  val settings = new Settings(s => initialLog(s))
+  output match {
+    case multi: MultipleOutput =>
+      for (out <- multi.getOutputGroups)
+        settings.outputDirs
+          .add(
+            out.getSourceDirectoryAsPath.toAbsolutePath.toString,
+            out.getOutputDirectoryAsPath.toAbsolutePath.toString
+          )
+    case single: SingleOutput =>
+      val outputFilepath = single.getOutputDirectoryAsPath.toAbsolutePath
+      settings.outputDirs.setSingleOutput(outputFilepath.toString)
+    case x => throw new MatchError(x)
+  }
+
+  val command = new CompilerCommand(args.toList, settings)
+  private[this] val dreporter = DelegatingReporter(settings, initialLog.reporter)
+  try {
+    if (!noErrors(dreporter)) {
+      dreporter.printSummary()
+      handleErrors(dreporter, initialLog.logger)
+    }
+  } finally initialLog.clear()
+
+  /** Instance of the underlying Zinc compiler. */
+  val compiler: ZincCompiler = newCompiler(command.settings, dreporter, output)
+
+  /////////////////////////////////////////////////////////////////////////////////////////////////
+
+  def close(): Unit = {
+    compiler match {
+      case c: java.io.Closeable => c.close()
+      case _                    =>
+    }
+  }
+
+  def noErrors(dreporter: DelegatingReporter) = !dreporter.hasErrors && command.ok
+
+  def commandArguments(sources: Array[File]): Array[String] =
+    (command.settings.recreateArgs ++ sources.map(_.getAbsolutePath)).toArray[String]
+
+  import scala.tools.nsc.Properties.versionString
+  def infoOnCachedCompiler(compilerId: String): String =
+    s"[zinc] Running cached compiler $compilerId for Scala compiler $versionString"
+
+  def run(
+      sources: List[VirtualFile],
+      changes: DependencyChanges,
+      callback: AnalysisCallback,
+      log: Logger,
+      delegate: Reporter,
+      progress: CompileProgress
+  ): Unit = synchronized {
+    debug(log, infoOnCachedCompiler(hashCode().toLong.toHexString))
+    val dreporter = DelegatingReporter(settings, delegate)
+    try {
+      run(sources.sortBy(_.id).map(AbstractZincFile(_)), callback, log, dreporter, progress)
+    } finally {
+      dreporter.dropDelegate()
+    }
+  }
+
+  private def prettyPrintCompilationArguments(args: Array[String]) =
+    args.mkString("[zinc] The Scala compiler is invoked with:\n\t", "\n\t", "")
+
+  private val StopInfoError = "Compiler option supplied that disabled Zinc compilation."
+
+  private[this] def run(
+      sources: List[AbstractFile],
+      callback: AnalysisCallback,
+      log: Logger,
+      underlyingReporter: DelegatingReporter,
+      compileProgress: CompileProgress
+  ): Unit = {
+
+    lazy val callback2 =
+      try callback.asInstanceOf[AnalysisCallback2]
+      catch { case _: NoClassDefFoundError => null}
+
+    def callbackProblem(p: Problem) =
+      if (callback2 != null) callback2.problem2(p.category, p.position, p.message, p.severity, true, p.rendered, p.diagnosticCode, p.diagnosticRelatedInformation, p.actions)
+      else callback.problem(p.category, p.position, p.message, p.severity, true)
+
+    if (command.shouldStopWithInfo) {
+      underlyingReporter.echo(command.getInfoMessage(compiler))
+      throw new InterfaceCompileFailed(args, Array(), StopInfoError)
+    }
+
+    if (noErrors(underlyingReporter)) {
+      debug(log, prettyPrintCompilationArguments(args))
+      compiler.set(callback, underlyingReporter)
+      val run = new compiler.ZincRun(compileProgress)
+
+      run.compileFiles(sources)
+      underlyingReporter.problems.foreach(callbackProblem)
+    }
+
+    underlyingReporter.printSummary()
+    if (!noErrors(underlyingReporter))
+      handleErrors(underlyingReporter, log)
+
+    // the case where we cancelled compilation _after_ some compilation errors got reported
+    // will be handled by line above so errors still will be reported properly just potentially not
+    // all of them (because we cancelled the compilation)
+    if (underlyingReporter.cancelled)
+      handleCompilationCancellation(underlyingReporter, log)
+  }
+
+  def handleErrors(dreporter: DelegatingReporter, log: Logger): Nothing = {
+    debug(log, "Compilation failed (CompilerInterface)")
+    throw new InterfaceCompileFailed(args, dreporter.problems, "Compilation failed")
+  }
+
+  def handleCompilationCancellation(dreporter: DelegatingReporter, log: Logger): Nothing = {
+    assert(dreporter.cancelled, "We should get here only if when compilation got cancelled")
+    debug(log, "Compilation cancelled (CompilerInterface)")
+    throw new InterfaceCompileCancelled(args, "Compilation has been cancelled")
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/ConsoleBridge.scala b/src/sbt-bridge/scala/tools/xsbt/ConsoleBridge.scala
new file mode 100644
index 0000000000..5cfd632136
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/ConsoleBridge.scala
@@ -0,0 +1,109 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import xsbti.Logger
+import scala.tools.nsc.interpreter.IMain
+import scala.tools.nsc.interpreter.shell.{ ILoop, ShellConfig, ReplReporterImpl }
+import scala.tools.nsc.{ GenericRunnerCommand, Settings }
+
+class ConsoleBridge extends xsbti.compile.ConsoleInterface1 {
+  override def commandArguments(
+      args: Array[String],
+      bootClasspathString: String,
+      classpathString: String,
+      log: Logger
+  ): Array[String] =
+    MakeSettings.sync(args, bootClasspathString, classpathString, log).recreateArgs.toArray[String]
+
+  override def run(
+      args: Array[String],
+      bootClasspathString: String,
+      classpathString: String,
+      initialCommands: String,
+      cleanupCommands: String,
+      loader: ClassLoader,
+      bindNames: Array[String],
+      bindValues: Array[AnyRef],
+      log: Logger
+  ): Unit = {
+    lazy val interpreterSettings = MakeSettings.sync(args.toList, log)
+    val compilerSettings = MakeSettings.sync(args, bootClasspathString, classpathString, log)
+
+    log.info(Message("Starting scala interpreter..."))
+    log.info(Message(""))
+
+    val loop = new ILoop(ShellConfig(interpreterSettings)) {
+      override def createInterpreter(interpreterSettings: Settings) = {
+        if (loader ne null) {
+          val reporter = new ReplReporterImpl(interpreterSettings)
+          intp = new IMain(interpreterSettings, reporter) {
+            override protected def parentClassLoader =
+              if (loader eq null) super.parentClassLoader
+              else loader
+          }
+        } else
+          super.createInterpreter(interpreterSettings)
+
+        for ((id, value) <- bindNames zip bindValues) {
+          intp.beQuietDuring {
+            intp.bind(id, value.asInstanceOf[AnyRef].getClass.getName, value)
+            ()
+          }
+        }
+
+        if (!initialCommands.isEmpty)
+          intp.interpret(initialCommands)
+
+        ()
+      }
+
+      override def closeInterpreter(): Unit = {
+        if (!cleanupCommands.isEmpty)
+          intp.interpret(cleanupCommands)
+        super.closeInterpreter()
+      }
+    }
+
+    loop.run(compilerSettings)
+    ()
+  }
+}
+
+object MakeSettings {
+  def apply(args: List[String], log: Logger): Settings = {
+    val command = new GenericRunnerCommand(args, message => log.error(Message(message)))
+    if (command.ok)
+      command.settings
+    else
+      throw new InterfaceCompileFailed(Array(), Array(), command.usageMsg)
+  }
+
+  def sync(
+      args: Array[String],
+      bootClasspathString: String,
+      classpathString: String,
+      log: Logger
+  ): Settings = {
+    val compilerSettings = sync(args.toList, log)
+    if (!bootClasspathString.isEmpty)
+      compilerSettings.bootclasspath.value = bootClasspathString
+    compilerSettings.classpath.value = classpathString
+    compilerSettings
+  }
+
+  def sync(options: List[String], log: Logger): Settings = apply(options, log)
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/DelegatingReporter.scala b/src/sbt-bridge/scala/tools/xsbt/DelegatingReporter.scala
new file mode 100644
index 0000000000..62bf0fda6d
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/DelegatingReporter.scala
@@ -0,0 +1,354 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.io.File
+import java.{ util => ju }
+import ju.Optional
+
+import scala.jdk.CollectionConverters._
+import scala.reflect.internal.util.{ CodeAction, FakePos, NoPosition, Position }
+import scala.reflect.io.AbstractFile
+import scala.tools.nsc.Settings
+import scala.tools.nsc.reporters.FilteringReporter
+import xsbti.{
+  Action,
+  DiagnosticCode => XDiagnosticCode,
+  DiagnosticRelatedInformation => XDiagnosticRelatedInformation,
+  Problem => XProblem,
+  Position => XPosition,
+  Severity => XSeverity,
+  TextEdit,
+  WorkspaceEdit
+}
+
+/**
+ * This implements reporter/ concrete Problem data structure for
+ * the compiler bridge, in other words for each Scala versions
+ * that Zinc is capable of compiling.
+ *
+ * There's also sbt.util.InterfaceUtil, which is also used in
+ * Zinc in the Scala version Zinc uses.
+ */
+private object DelegatingReporter {
+  def apply(settings: Settings, delegate: xsbti.Reporter): DelegatingReporter =
+    new DelegatingReporter(settings, delegate)
+
+  class PositionImpl(
+      sourcePath0: Option[String],
+      sourceFile0: Option[File],
+      line0: Option[Int],
+      lineContent0: String,
+      offset0: Option[Int],
+      pointer0: Option[Int],
+      pointerSpace0: Option[String],
+      startOffset0: Option[Int],
+      endOffset0: Option[Int],
+      startLine0: Option[Int],
+      startColumn0: Option[Int],
+      endLine0: Option[Int],
+      endColumn0: Option[Int]
+  ) extends xsbti.Position {
+    val line = o2oi(line0)
+    val lineContent = lineContent0
+    val offset = o2oi(offset0)
+    val sourcePath = o2jo(sourcePath0)
+    val sourceFile = o2jo(sourceFile0)
+    val pointer = o2oi(pointer0)
+    val pointerSpace = o2jo(pointerSpace0)
+    override val startOffset = o2oi(startOffset0)
+    override val endOffset = o2oi(endOffset0)
+    override val startLine = o2oi(startLine0)
+    override val startColumn = o2oi(startColumn0)
+    override val endLine = o2oi(endLine0)
+    override val endColumn = o2oi(endColumn0)
+    override def toString =
+      (sourcePath0, line0) match {
+        case (Some(s), Some(l)) => s + ":" + l
+        case (Some(s), _)       => s + ":"
+        case _                  => ""
+      }
+  }
+
+  object PositionImpl {
+    def empty: PositionImpl =
+      new PositionImpl(None, None, None, "", None, None, None, None, None, None, None, None, None)
+  }
+
+  import java.lang.{ Integer => I }
+  private[xsbt] def o2oi(opt: Option[Int]): Optional[I] = {
+    opt match {
+      case Some(s) => Optional.ofNullable[I](s: I)
+      case None    => Optional.empty[I]
+    }
+  }
+
+  private[xsbt] def o2jo[A](o: Option[A]): Optional[A] = {
+    o match {
+      case Some(v) => Optional.ofNullable(v)
+      case None    => Optional.empty[A]()
+    }
+  }
+
+  private[xsbt] def l2jl[A](l: List[A]): ju.List[A] = {
+    val jl = new ju.ArrayList[A](l.size)
+    l.foreach(jl.add(_))
+    jl
+  }
+
+  private[xsbt] def jl2l[A](jl: ju.List[A]): List[A] = {
+    jl.asScala.toList
+  }
+
+  private[xsbt] def convert(dirtyPos: Position): xsbti.Position = {
+    def cleanPos(pos: Position) = {
+      Option(pos) match {
+        case None | Some(NoPosition) => None
+        case Some(_: FakePos)        => None
+        case _                       => Option(pos.finalPosition)
+      }
+    }
+
+    def makePosition(pos: Position): xsbti.Position = {
+      val src = pos.source
+      val sourcePath = src.file match {
+        case AbstractZincFile(virtualFile) => virtualFile.id
+        case af: AbstractFile              => af.path
+      }
+      val sourceFile = new File(src.file.path)
+      val line = pos.line
+      val lineContent = pos.lineContent.stripLineEnd
+      val offset = pos.point
+
+      // Same logic as Position#line
+      def lineOf(offset: Int) = src.offsetToLine(offset) + 1
+      def columnOf(offset: Int) = offset - src.lineToOffset(src.offsetToLine(offset))
+
+      val pointer = columnOf(offset)
+      val pointerSpace = lineContent.toList.take(pointer).map {
+        case '\t' => '\t'
+        case _    => ' '
+      }
+
+      val startOffset = if (pos.isRange) Some(pos.start) else None
+      val endOffset = if (pos.isRange) Some(pos.end) else None
+      val startLine = if (pos.isRange) Some(lineOf(pos.start)) else None
+      val startColumn = if (pos.isRange) Some(columnOf(pos.start)) else None
+      val endLine =
+        if (pos.isRange)
+          try {
+            Some(lineOf(pos.end))
+          } catch {
+            // work around for https://github.com/scala/bug/issues/11865 by falling back to start pos
+            case _: ArrayIndexOutOfBoundsException =>
+              startLine
+          }
+        else None
+      val endColumn =
+        if (pos.isRange)
+          try {
+            Some(columnOf(pos.end))
+          } catch {
+            // work around for https://github.com/scala/bug/issues/11865 by falling back to start pos
+            case _: ArrayIndexOutOfBoundsException =>
+              startColumn
+          }
+        else None
+
+      new PositionImpl(
+        Option(sourcePath),
+        Option(sourceFile),
+        Option(line),
+        lineContent,
+        Option(offset),
+        Option(pointer),
+        Option(pointerSpace.mkString),
+        startOffset,
+        endOffset,
+        startLine,
+        startColumn,
+        endLine,
+        endColumn
+      )
+    }
+
+    cleanPos(dirtyPos) match {
+      case None           => PositionImpl.empty
+      case Some(cleanPos) => makePosition(cleanPos)
+    }
+  }
+}
+
+// Copyright 2002-2009 LAMP/EPFL
+// Original author: Martin Odersky
+// Based on scala.tools.nsc.reporters.{AbstractReporter, ConsoleReporter}
+private final class DelegatingReporter(
+    val settings: Settings,
+    private[this] var delegate: xsbti.Reporter
+) extends FilteringReporter {
+  import DelegatingReporter._
+
+  private val Werror: Boolean = settings.fatalWarnings.value
+  private val noWarn: Boolean = settings.nowarn.value
+
+  def dropDelegate(): Unit = { delegate = ReporterSink }
+  def error(msg: String): Unit = error(FakePos("scalac"), msg)
+  def printSummary(): Unit = delegate.printSummary()
+
+  def problems = delegate.problems
+  override def hasErrors = delegate.hasErrors
+  override def hasWarnings = delegate.hasWarnings
+  override def comment(pos: Position, msg: String): Unit =
+    delegate.comment(DelegatingReporter.convert(pos), msg)
+  override def reset(): Unit = {
+    super.reset()
+    delegate.reset()
+  }
+
+  override def doReport(pos: Position, msg: String, rawSeverity: Severity, actions: List[CodeAction]): Unit = {
+    val skip = rawSeverity == WARNING && noWarn
+    if (!skip) {
+      val severity = if (Werror && rawSeverity == WARNING) ERROR else rawSeverity
+      val pos1 = DelegatingReporter.convert(pos)
+      delegate.log(new CompileProblem(
+        pos = pos1,
+        msg = msg,
+        sev = convert(severity),
+        rendered0 = None,
+        diagnosticCode0 = None,
+        diagnosticRelatedInformation0 = Nil,
+        actions0 = actions.map(convertAction),
+      ))
+    }
+  }
+
+  //protected def info0(pos: Position, msg: String, rawSeverity: Severity, force: Boolean): Unit = doReport(pos, msg, rawSeverity, Nil)
+
+  import xsbti.Severity.{ Info, Warn, Error }
+  private[this] def convert(sev: Severity): xsbti.Severity = sev match {
+    case INFO    => Info
+    case WARNING => Warn
+    case ERROR   => Error
+    case x       => throw new MatchError(x)
+  }
+
+  // Define our own problem because the bridge should not depend on sbt util-logging.
+  private final class CompileProblem(
+      pos: XPosition,
+      msg: String,
+      sev: XSeverity,
+      rendered0: Option[String],
+      diagnosticCode0: Option[XDiagnosticCode],
+      diagnosticRelatedInformation0: List[XDiagnosticRelatedInformation],
+      actions0: List[Action]
+  ) extends XProblem {
+    override val category = ""
+    override val position = pos
+    override val message = msg
+    override val severity = sev
+    override def rendered = o2jo(rendered0)
+    override def toString = s"[$severity] $pos: $message"
+    override def diagnosticCode: Optional[XDiagnosticCode] = o2jo(diagnosticCode0)
+    override def diagnosticRelatedInformation(): ju.List[XDiagnosticRelatedInformation] =
+      l2jl(diagnosticRelatedInformation0)
+    override def actions(): ju.List[Action] = l2jl(actions0)
+  }
+
+  private def convertAction(a: CodeAction): Action =
+    action(
+      title = a.title,
+      description = a.description,
+      edit = workspaceEdit(a.edits.map { edit =>
+        textEdit(DelegatingReporter.convert(edit.position), edit.newText)
+      }),
+    )
+
+  private def action(
+      title: String,
+      description: Option[String],
+      edit: WorkspaceEdit
+  ): Action =
+    new ConcreteAction(title, description, edit)
+
+  private def workspaceEdit(changes: List[TextEdit]): WorkspaceEdit =
+    new ConcreteWorkspaceEdit(changes)
+
+  private def textEdit(position: XPosition, newText: String): TextEdit =
+    new ConcreteTextEdit(position, newText)
+
+  private final class ConcreteAction(
+      title0: String,
+      description0: Option[String],
+      edit0: WorkspaceEdit
+  ) extends Action {
+    val title: String = title0
+    val edit: WorkspaceEdit = edit0
+    override def description(): Optional[String] =
+      o2jo(description0)
+    override def toString(): String =
+      s"Action($title0, $description0, $edit0)"
+    private def toTuple(a: Action) =
+      (
+        a.title,
+        a.description,
+        a.edit
+      )
+    override def hashCode: Int = toTuple(this).##
+    override def equals(o: Any): Boolean = o match {
+      case o: Action => toTuple(this) == toTuple(o)
+      case _         => false
+    }
+  }
+
+  private final class ConcreteWorkspaceEdit(changes0: List[TextEdit]) extends WorkspaceEdit {
+    override def changes(): ju.List[TextEdit] = l2jl(changes0)
+    override def toString(): String =
+      s"WorkspaceEdit($changes0)"
+    private def toTuple(w: WorkspaceEdit) = jl2l(w.changes)
+    override def hashCode: Int = toTuple(this).##
+    override def equals(o: Any): Boolean = o match {
+      case o: WorkspaceEdit => toTuple(this) == toTuple(o)
+      case _                => false
+    }
+  }
+
+  private final class ConcreteTextEdit(position0: XPosition, newText0: String) extends TextEdit {
+    val position: XPosition = position0
+    val newText: String = newText0
+    override def toString(): String =
+      s"TextEdit($position, $newText)"
+    private def toTuple(edit: TextEdit) =
+      (
+        edit.position,
+        edit.newText
+      )
+    override def hashCode: Int = toTuple(this).##
+    override def equals(o: Any): Boolean = o match {
+      case o: TextEdit => toTuple(this) == toTuple(o)
+      case _           => false
+    }
+  }
+}
+
+private object ReporterSink extends xsbti.Reporter {
+  def reset() = ()
+  def hasErrors() = false
+  def hasWarnings() = false
+  def printSummary() = ()
+  def problems() = Array.empty[xsbti.Problem]
+  def log(problem: xsbti.Problem) = ()
+  def comment(pos: xsbti.Position, msg: String) = ()
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/Dependency.scala b/src/sbt-bridge/scala/tools/xsbt/Dependency.scala
new file mode 100644
index 0000000000..1a17049c6b
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/Dependency.scala
@@ -0,0 +1,485 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.nio.file.Path
+import xsbti.VirtualFile
+import xsbti.api.DependencyContext
+import DependencyContext._
+
+import scala.tools.nsc.io.{ PlainFile, ZipArchive }
+import scala.tools.nsc.Phase
+
+import java.util.{ HashSet => JavaSet }
+import java.util.{ HashMap => JavaMap }
+
+object Dependency {
+  def name = "xsbt-dependency"
+}
+
+/**
+ * Extracts dependency information from each compilation unit.
+ *
+ * This phase detects all the dependencies both at the term and type level.
+ *
+ * When dependency symbol is processed, it is mapped back to either source file where
+ * it's defined in (if it's available in current compilation run) or classpath entry
+ * where it originates from. The Symbol -> Classfile mapping is implemented by
+ * LocateClassFile that we inherit from.
+ */
+final class Dependency(val global: CallbackGlobal) extends LocateClassFile with GlobalHelpers {
+  import global._
+
+  def newPhase(prev: Phase): Phase = new DependencyPhase(prev)
+  private class DependencyPhase(prev: Phase) extends GlobalPhase(prev) {
+    override def description = "Extracts dependency information"
+    def name = Dependency.name
+
+    override def run(): Unit = {
+      val start = System.currentTimeMillis
+      super.run()
+      callback.dependencyPhaseCompleted()
+      val stop = System.currentTimeMillis
+      debuglog("Dependency phase took : " + ((stop - start) / 1000.0) + " s")
+    }
+
+    // TODO In 2.13, shouldSkipThisPhaseForJava should be overridden instead of cancelled
+    // override def shouldSkipThisPhaseForJava = !global.callback.isPickleJava
+    override def cancelled(unit: CompilationUnit) = {
+      if (Thread.interrupted()) reporter.cancelled = true
+      reporter.cancelled || unit.isJava && !global.callback.isPickleJava
+    }
+
+    def apply(unit: CompilationUnit): Unit = {
+      if (!unit.isJava || global.callback.isPickleJava) {
+        // Process dependencies if name hashing is enabled, fail otherwise
+        val dependencyProcessor = new DependencyProcessor(unit)
+        val dependencyTraverser = new DependencyTraverser(dependencyProcessor)
+        // Traverse symbols in compilation unit and register all dependencies
+        dependencyTraverser.traverse(unit.body)
+      }
+    }
+  }
+
+  private class DependencyProcessor(unit: CompilationUnit) {
+    private def firstClassOrModuleClass(tree: Tree): Option[Symbol] = {
+      val maybeClassOrModule = tree find {
+        case ((_: ClassDef) | (_: ModuleDef)) => true
+        case _                                => false
+      }
+      maybeClassOrModule.map { classOrModule =>
+        val sym = classOrModule.symbol
+        if (sym.isModule) sym.moduleClass else sym
+      }
+    }
+
+    private val sourceFile: VirtualFile = unit.source.file match { case AbstractZincFile(vf) => vf case x => throw new MatchError(x) }
+    private val responsibleOfImports = firstClassOrModuleClass(unit.body)
+    private var orphanImportsReported = false
+
+    /*
+     * Registers top level import dependencies as coming from a first top level
+     * class/trait/object declared in the compilation unit. Otherwise, issue warning.
+     */
+    def processTopLevelImportDependency(dep: Symbol): Unit = {
+      if (!orphanImportsReported) {
+        responsibleOfImports match {
+          case Some(classOrModuleDef) =>
+            memberRef(ClassDependency(classOrModuleDef, dep))
+          case None =>
+            reporter.echo(
+              unit.position(0),
+              Feedback.OrphanTopLevelImports
+            ) // package-info.java & empty scala files
+            orphanImportsReported = true
+        }
+      }
+      ()
+    }
+
+    // Define processor reusing `processDependency` definition
+    val memberRef = processDependency(DependencyByMemberRef, false) _
+    val inheritance = processDependency(DependencyByInheritance, true) _
+    val localInheritance = processDependency(LocalDependencyByInheritance, true) _
+
+    @deprecated("Use processDependency that takes allowLocal.", "1.1.0")
+    def processDependency(context: DependencyContext)(dep: ClassDependency): Unit =
+      processDependency(context, true)(dep)
+
+    /*
+     * Handles dependency on given symbol by trying to figure out if represents a term
+     * that is coming from either source code (not necessarily compiled in this compilation
+     * run) or from class file and calls respective callback method.
+     */
+    def processDependency(context: DependencyContext, allowLocal: Boolean)(
+        dep: ClassDependency
+    ): Unit = {
+      val fromClassName = classNameAsString(dep.from)
+
+      def binaryDependency(file: Path, binaryClassName: String) = {
+        callback.binaryDependency(file, binaryClassName, fromClassName, sourceFile, context)
+      }
+      import scala.tools.nsc.io.AbstractFile
+      def processExternalDependency(binaryClassName: String, at: AbstractFile): Unit = {
+        at match {
+          case zipEntry: ZipArchive#Entry =>
+            // The dependency comes from a JAR
+            for {
+              zip <- zipEntry.underlyingSource
+            } {
+              // workaround for JDK9 and Scala 2.10/2.11, see https://github.com/sbt/sbt/pull/3701
+              val ignore = zip.file == null || (!zip.hasExtension("jar") && zip.isDirectory)
+              if (!ignore)
+                binaryDependency(zip.file.toPath, binaryClassName)
+            }
+          case pf: ZincCompat.PlainNioFile =>
+            // The dependency comes from a class file
+            binaryDependency(ZincCompat.unwrapPlainNioFile(pf), binaryClassName)
+          case pf: PlainFile =>
+            // The dependency comes from a class file
+            binaryDependency(pf.file.toPath, binaryClassName)
+          case _ =>
+          // On Scala 2.10 you get Internal error: <none> comes from unknown origin null
+          // if you uncomment the following:
+          // reporter.error(
+          //   NoPosition,
+          //   s"Internal error: ${binaryClassName} comes from unknown origin ${at} (${at.getClass})"
+          // )
+        }
+      }
+
+      val targetSymbol = dep.to
+      val onSource = targetSymbol.sourceFile
+      onSource match {
+        case AbstractZincFile(onSourceFile) =>
+          if (onSourceFile != sourceFile || allowLocal) {
+            // We cannot ignore dependencies coming from the same source file because
+            // the dependency info needs to propagate. See source-dependencies/trait-trait-211.
+            val onClassName = classNameAsString(dep.to)
+            callback.classDependency(onClassName, fromClassName, context)
+          } else ()
+        // This could match null or scala.reflect.io.FileZipArchive$LeakyEntry
+        case _ =>
+          val noByteCode = (
+            // Ignore packages right away as they don't map to a class file/jar
+            targetSymbol.hasFlag(scala.tools.nsc.symtab.Flags.PACKAGE) ||
+              // Seen in the wild: an Ident as the original of a TypeTree from a synthetic case accessor was symbol-less
+              targetSymbol == NoSymbol ||
+              // Also ignore magic symbols that don't have bytecode like Any/Nothing/Singleton/<byname>/<repeated>/...
+              isSyntheticCoreClass(targetSymbol)
+          )
+          if (!noByteCode) {
+            classFile(targetSymbol) match {
+              case Some((at, binaryClassName)) =>
+                // Associated file is set, so we know which classpath entry it came from
+                processExternalDependency(binaryClassName, at)
+              case None =>
+                /* If there is no associated file, it's likely the compiler didn't set it correctly.
+                 * This happens very rarely, see https://github.com/sbt/zinc/issues/559 as an example,
+                 * but when it does we must ensure the incremental compiler tries its best no to lose
+                 * any dependency. Therefore, we do a last-time effort to get the origin of the symbol
+                 * by inspecting the classpath manually.
+                 */
+                val fqn = fullName(targetSymbol, '.', targetSymbol.moduleSuffix, false)
+                global.findAssociatedFile(fqn) match {
+                  case Some((at, true)) =>
+                    processExternalDependency(fqn, at)
+                  case Some((_, false)) | None =>
+                    // Study the possibility of warning or adding this to the zinc profiler so that
+                    // if users reports errors, the lost dependencies are present in the zinc profiler
+                    debuglog(Feedback.noOriginFileForExternalSymbol(targetSymbol))
+                }
+            }
+          }
+      }
+    }
+  }
+
+  private case class ClassDependency(from: Symbol, to: Symbol)
+
+  private final class DependencyTraverser(processor: DependencyProcessor) extends Traverser {
+    // are we traversing an Import node at the moment?
+    private var inImportNode = false
+
+    // Define caches for dependencies that have already been processed
+    private val _memberRefCache = new JavaSet[ClassDependency]()
+    private val _inheritanceCache = new JavaSet[ClassDependency]()
+    private val _localInheritanceCache = new JavaSet[ClassDependency]()
+    private val _topLevelImportCache = new JavaSet[Symbol]()
+
+    private var _currentDependencySource: Symbol = _
+    private var _currentNonLocalClass: Symbol = _
+    private var _isLocalSource: Boolean = false
+
+    @inline def resolveNonLocalClass(from: Symbol): (Symbol, Boolean) = {
+      val fromClass = enclOrModuleClass(from)
+      if (fromClass == NoSymbol || fromClass.hasPackageFlag) (fromClass, false)
+      else {
+        val nonLocal = localToNonLocalClass.resolveNonLocal(fromClass)
+        (nonLocal, fromClass != nonLocal)
+      }
+    }
+
+    /**
+     * Resolves dependency source (that is, the closest non-local enclosing
+     * class from a given `currentOwner` set by the `Traverser`).
+     *
+     * This method modifies the value of `_currentDependencySource`,
+     * `_currentNonLocalClass` and `_isLocalSource` and it is not modeled
+     * as a case class for performance reasons.
+     *
+     * The used caching strategy works as follows:
+     * 1. Return previous non-local class if owners are referentially equal.
+     * 2. Otherwise, check if they resolve to the same non-local class.
+     *   1. If they do, overwrite `_isLocalSource` and return
+     *        `_currentNonLocalClass`.
+     *   2. Otherwise, overwrite all the pertinent fields to be consistent.
+     */
+    private def resolveDependencySource: Symbol = {
+      if (_currentDependencySource == null) {
+        // First time we access it, initialize it
+        _currentDependencySource = currentOwner
+        val (nonLocalClass, isLocal) = resolveNonLocalClass(currentOwner)
+        _currentNonLocalClass = nonLocalClass
+        _isLocalSource = isLocal
+        nonLocalClass
+      } else {
+        // Check if cached is equally referential
+        if (_currentDependencySource == currentOwner) _currentNonLocalClass
+        else {
+          // Check they resolve to the same nonLocalClass. If so, spare writes.
+          val (nonLocalClass, isLocal) = resolveNonLocalClass(currentOwner)
+          if (_currentNonLocalClass == nonLocalClass) {
+            // Resolution can be the same, but the origin affects `isLocal`
+            _isLocalSource = isLocal
+            _currentNonLocalClass
+          } else {
+            _currentDependencySource = _currentDependencySource
+            _currentNonLocalClass = nonLocalClass
+            _isLocalSource = isLocal
+            _currentNonLocalClass
+          }
+        }
+      }
+    }
+
+    /**
+     * Process a given ClassDependency and add it to the cache.
+     *
+     * This class dependency can be of three different types:
+     *   1. Member reference;
+     *   2. Local inheritance; or,
+     *   3. Inheritance.
+     */
+    private def addClassDependency(
+        cache: JavaSet[ClassDependency],
+        process: ClassDependency => Unit,
+        fromClass: Symbol,
+        dep: Symbol
+    ): Unit = {
+      assert(fromClass.isClass, Feedback.expectedClassSymbol(fromClass))
+      val depClass = enclOrModuleClass(dep)
+      val dependency = ClassDependency(fromClass, depClass)
+      if (
+        !cache.contains(dependency) &&
+        !depClass.isRefinementClass
+      ) {
+        process(dependency)
+        cache.add(dependency)
+        ()
+      }
+    }
+
+    def addTopLevelImportDependency(dep: global.Symbol): Unit = {
+      val depClass = enclOrModuleClass(dep)
+      if (!_topLevelImportCache.contains(depClass) && !dep.hasPackageFlag) {
+        processor.processTopLevelImportDependency(depClass)
+        _topLevelImportCache.add(depClass)
+        ()
+      }
+    }
+
+    private def addTreeDependency(tree: Tree): Unit = {
+      addDependency(tree.symbol)
+      val tpe = tree.tpe
+      if (!ignoredType(tpe)) {
+        addTypeDependencies(tpe)
+      }
+      ()
+    }
+
+    private def addDependency(dep: Symbol): Unit = {
+      val fromClass = resolveDependencySource
+      if (ignoredSymbol(fromClass) || fromClass.hasPackageFlag) {
+        if (inImportNode) addTopLevelImportDependency(dep)
+        else devWarning(Feedback.missingEnclosingClass(dep, currentOwner))
+      } else {
+        addClassDependency(_memberRefCache, processor.memberRef, fromClass, dep)
+      }
+    }
+
+    /** Define a type traverser to keep track of the type dependencies. */
+    object TypeDependencyTraverser extends TypeDependencyTraverser {
+      type Handler = Symbol => Unit
+      // Type dependencies are always added to member references
+      val memberRefHandler = processor.memberRef
+      def createHandler(fromClass: Symbol): Handler = { (dep: Symbol) =>
+        if (ignoredSymbol(fromClass) || fromClass.hasPackageFlag) {
+          if (inImportNode) addTopLevelImportDependency(dep)
+          else devWarning(Feedback.missingEnclosingClass(dep, currentOwner))
+        } else {
+          addClassDependency(_memberRefCache, memberRefHandler, fromClass, dep)
+        }
+      }
+
+      val cache = new JavaMap[Symbol, (Handler, JavaSet[Type])]()
+      private var handler: Handler = _
+      private var visitedOwner: Symbol = _
+      def setOwner(owner: Symbol) = {
+        if (visitedOwner != owner) {
+          cache.get(owner) match {
+            case null =>
+              val newVisited = new JavaSet[Type]()
+              handler = createHandler(owner)
+              cache.put(owner, handler -> newVisited)
+              visited = newVisited
+              visitedOwner = owner
+            case (h, ts) =>
+              visited = ts
+              handler = h
+          }
+        }
+      }
+
+      override def addDependency(symbol: global.Symbol) = handler(symbol)
+    }
+
+    def addTypeDependencies(tpe: Type): Unit = {
+      val fromClass = resolveDependencySource
+      TypeDependencyTraverser.setOwner(fromClass)
+      TypeDependencyTraverser.traverse(tpe)
+    }
+
+    private def addInheritanceDependency(dep: Symbol): Unit = {
+      val fromClass = resolveDependencySource
+      if (_isLocalSource) {
+        addClassDependency(_localInheritanceCache, processor.localInheritance, fromClass, dep)
+      } else {
+        addClassDependency(_inheritanceCache, processor.inheritance, fromClass, dep)
+      }
+    }
+
+    /*
+     * Some macros appear to contain themselves as original tree.
+     * We must check that we don't inspect the same tree over and over.
+     * See https://issues.scala-lang.org/browse/SI-8486
+     *     https://github.com/sbt/sbt/issues/1237
+     *     https://github.com/sbt/sbt/issues/1544
+     */
+    private val inspectedOriginalTrees = new JavaSet[Tree]()
+
+    override def traverse(tree: Tree): Unit = tree match {
+      case Import(expr, selectors) =>
+        inImportNode = true
+        traverse(expr)
+        selectors.foreach {
+          case ImportSelector(nme.WILDCARD, _, null, _) =>
+          // in case of wildcard import we do not rely on any particular name being defined
+          // on `expr`; all symbols that are being used will get caught through selections
+          case ImportSelector(name: Name, _, _, _) =>
+            def lookupImported(name: Name) = expr.symbol.info.member(name)
+            // importing a name means importing both a term and a type (if they exist)
+            val termSymbol = lookupImported(name.toTermName)
+            if (termSymbol.info != NoType) addDependency(termSymbol)
+            addDependency(lookupImported(name.toTypeName))
+        }
+        inImportNode = false
+      /*
+       * Idents are used in number of situations:
+       *  - to refer to local variable
+       *  - to refer to a top-level package (other packages are nested selections)
+       *  - to refer to a term defined in the same package as an enclosing class;
+       *    this looks fishy, see this thread:
+       *    https://groups.google.com/d/topic/scala-internals/Ms9WUAtokLo/discussion
+       */
+      case id: Ident => addTreeDependency(id)
+      case sel @ Select(qual, _) =>
+        traverse(qual); addTreeDependency(sel)
+      case sel @ SelectFromTypeTree(qual, _) =>
+        traverse(qual); addTreeDependency(sel)
+
+      case Template(parents, self, body) =>
+        // use typeSymbol to dealias type aliases -- we want to track the dependency on the real class in the alias's RHS
+        def flattenTypeToSymbols(tp: Type): List[Symbol] =
+          if (tp eq null) Nil
+          else
+            tp match {
+              // rt.typeSymbol is redundant if we list out all parents, TODO: what about rt.decls?
+              case rt: RefinedType => rt.parents.flatMap(flattenTypeToSymbols)
+              case _               => List(tp.typeSymbol)
+            }
+
+        val inheritanceTypes = parents.map(_.tpe).toSet
+        val inheritanceSymbols = inheritanceTypes.flatMap(flattenTypeToSymbols)
+
+        debuglog(
+          "Parent types for " + tree.symbol + " (self: " + self.tpt.tpe + "): " + inheritanceTypes + " with symbols " + inheritanceSymbols
+            .map(_.fullName)
+        )
+
+        inheritanceSymbols.foreach { symbol =>
+          addInheritanceDependency(symbol)
+          addDependency(symbol)
+        }
+
+        inheritanceTypes.foreach(addTypeDependencies)
+        addTypeDependencies(self.tpt.tpe)
+
+        traverseTrees(body)
+
+      case Literal(value) if value.tag == ClazzTag =>
+        addTypeDependencies(value.typeValue)
+
+      /* Original type trees have to be traversed because typer is very
+       * aggressive when expanding explicit user-defined types. For instance,
+       * `Foo#B` will be expanded to `C` and the dependency on `Foo` will be
+       * lost. This makes sure that we traverse all the original prefixes. */
+      case typeTree: TypeTree if !ignoredType(typeTree.tpe) =>
+        val original = typeTree.original
+        if (original != null && !inspectedOriginalTrees.contains(original)) {
+          traverse(original)
+          inspectedOriginalTrees.add(original)
+        }
+        addTypeDependencies(typeTree.tpe)
+
+      case m @ MacroExpansionOf(original) if inspectedOriginalTrees.add(original) =>
+        traverse(original)
+        super.traverse(m)
+
+      case l: Literal =>
+        processOriginalTreeAttachment(l)(traverse)
+        super.traverse(l)
+
+      case _: ClassDef | _: ModuleDef if !ignoredSymbol(tree.symbol) =>
+        // make sure we cache lookups for all classes declared in the compilation unit; the recorded information
+        // will be used in Analyzer phase
+        val sym = if (tree.symbol.isModule) tree.symbol.moduleClass else tree.symbol
+        localToNonLocalClass.resolveNonLocal(sym)
+        super.traverse(tree)
+      case other => super.traverse(other)
+    }
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/ExtractAPI.scala b/src/sbt-bridge/scala/tools/xsbt/ExtractAPI.scala
new file mode 100644
index 0000000000..4304321f01
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/ExtractAPI.scala
@@ -0,0 +1,856 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.util.{ Arrays, Comparator }
+import scala.tools.nsc.symtab.Flags
+import xsbti.VirtualFile
+import xsbti.api._
+
+import scala.annotation.tailrec
+import scala.tools.nsc.Global
+import scala.PartialFunction.cond
+
+/**
+ * Extracts full (including private members) API representation out of Symbols and Types.
+ *
+ * API for each class is extracted separately. Inner classes are represented as an empty (without members)
+ * member of the outer class and as a separate class with full API representation. For example:
+ *
+ * class A {
+ *   class B {
+ *     def foo: Int = 123
+ *   }
+ * }
+ *
+ * Is represented as:
+ *
+ * // className = A
+ * class A {
+ *   class B
+ * }
+ * // className = A.B
+ * class A.B {
+ *   def foo: Int
+ * }
+ *
+ * Each compilation unit should be processed by a fresh instance of this class.
+ *
+ * NOTE: This class extract *full* API representation. In most of other places in the incremental compiler,
+ * only non-private (accessible from other compilation units) members are relevant. Other parts of the
+ * incremental compiler filter out private definitions before processing API structures. Check SameAPI for
+ * an example.
+ *
+ */
+class ExtractAPI[GlobalType <: Global](
+    val global: GlobalType,
+    // Tracks the source file associated with the CompilationUnit currently being processed by the API phase.
+    // This is used when recording inheritance dependencies.
+    sourceFile: VirtualFile
+) extends Compat
+    with ClassName
+    with GlobalHelpers {
+
+  import global._
+
+  private def error(msg: String) = throw new RuntimeException(msg)
+
+  // this cache reduces duplicate work both here and when persisting
+  //   caches on other structures had minimal effect on time and cache size
+  //   (tried: Definition, Modifier, Path, Id, String)
+  private[this] val typeCache = perRunCaches.newMap[(Symbol, Type), xsbti.api.Type]()
+  // these caches are necessary for correctness
+  private[this] val structureCache = perRunCaches.newMap[Symbol, xsbti.api.Structure]()
+  private[this] val classLikeCache =
+    perRunCaches.newMap[(Symbol, Symbol), xsbti.api.ClassLikeDef]()
+  private[this] val pending = perRunCaches.newSet[xsbti.api.Lazy[_]]()
+
+  private[this] val emptyStringArray = Array.empty[String]
+
+  private[this] val allNonLocalClassSymbols = perRunCaches.newSet[Symbol]()
+  private[this] val allNonLocalClassesInSrc = perRunCaches.newSet[xsbti.api.ClassLike]()
+  private[this] val _mainClasses = perRunCaches.newSet[String]()
+
+  /**
+   * Implements a work-around for https://github.com/sbt/sbt/issues/823
+   *
+   * The strategy is to rename all type variables bound by existential type to stable
+   * names by assigning to each type variable a De Bruijn-like index. As a result, each
+   * type variable gets name of this shape:
+   *
+   *   "existential_${nestingLevel}_${i}"
+   *
+   * where `nestingLevel` indicates nesting level of existential types and `i` variable
+   * indicates position of type variable in given existential type.
+   *
+   * For example, let's assume we have the following classes declared:
+   *
+   *   class A[T]; class B[T,U]
+   *
+   * and we have type A[_] that is expanded by Scala compiler into
+   *
+   *   A[_$1] forSome { type _$1 }
+   *
+   * After applying our renaming strategy we get
+   *
+   *   A[existential_0_0] forSome { type existential_0_0 }
+   *
+   * Let's consider a bit more complicated example which shows how our strategy deals with
+   * nested existential types:
+   *
+   *   A[_ <: B[_, _]]
+   *
+   * which gets expanded into:
+   *
+   *   A[_$1] forSome {
+   *     type _$1 <: B[_$2, _$3] forSome { type _$2; type _$3 }
+   *   }
+   *
+   * After applying our renaming strategy we get
+   *
+   *   A[existential_0_0] forSome {
+   *     type existential_0_0 <: B[existential_1_0, existential_1_1] forSome {
+   *       type existential_1_0; type existential_1_1
+   *     }
+   *   }
+   *
+   * Note how the first index (nesting level) is bumped for both existential types.
+   *
+   * This way, all names of existential type variables depend only on the structure of
+   * existential types and are kept stable.
+   *
+   * Both examples presented above used placeholder syntax for existential types but our
+   * strategy is applied uniformly to all existential types no matter if they are written
+   * using placeholder syntax or explicitly.
+   */
+  private[this] object existentialRenamings {
+    private var nestingLevel: Int = 0
+    import scala.collection.mutable.Map
+    private val renameTo: Map[Symbol, String] = Map.empty
+
+    def leaveExistentialTypeVariables(typeVariables: Seq[Symbol]): Unit = {
+      nestingLevel -= 1
+      assert(nestingLevel >= 0, s"nestingLevel = $nestingLevel")
+      typeVariables.foreach(renameTo.remove)
+    }
+    def enterExistentialTypeVariables(typeVariables: Seq[Symbol]): Unit = {
+      nestingLevel += 1
+      typeVariables.zipWithIndex foreach {
+        case (tv, i) =>
+          val newName = "existential_" + nestingLevel + "_" + i
+          renameTo(tv) = newName
+      }
+    }
+    def renaming(symbol: Symbol): Option[String] = renameTo.get(symbol)
+  }
+
+  /**
+   * Construct a lazy instance from a by-name parameter that will null out references to once
+   * the value is forced and therefore references to thunk's classes will be garbage collected.
+   */
+  private def lzy[S <: AnyRef](s: => S): xsbti.api.Lazy[S] = {
+    val lazyImpl = xsbti.api.SafeLazy.apply(Message(s))
+    pending += lazyImpl
+    lazyImpl
+  }
+
+  /**
+   * Force all lazy structures.  This is necessary so that we see the symbols/types at this phase and
+   * so that we don't hold on to compiler objects and classes
+   */
+  @tailrec final def forceStructures(): Unit =
+    if (pending.isEmpty)
+      structureCache.clear()
+    else {
+      val toProcess = pending.toList
+      pending.clear()
+      toProcess foreach { _.get() }
+      forceStructures()
+    }
+
+  private def thisPath(sym: Symbol) = path(pathComponents(sym, Constants.thisPath :: Nil))
+  private def path(components: List[PathComponent]) =
+    xsbti.api.Path.of(components.toArray[PathComponent])
+  @tailrec
+  private def pathComponents(sym: Symbol, postfix: List[PathComponent]): List[PathComponent] = {
+    if (sym == NoSymbol || sym.isRoot || sym.isEmptyPackageClass || sym.isRootPackage) postfix
+    else pathComponents(sym.owner, xsbti.api.Id.of(simpleName(sym)) :: postfix)
+  }
+  private def types(in: Symbol, t: List[Type]): Array[xsbti.api.Type] =
+    t.toArray[Type].map(processType(in, _))
+  private def projectionType(in: Symbol, pre: Type, sym: Symbol) = {
+    if (pre == NoPrefix) {
+      if (sym.isLocalClass || sym.isRoot || sym.isRootPackage) Constants.emptyType
+      else if (sym.isTypeParameterOrSkolem || sym.isExistentiallyBound) reference(sym)
+      else {
+        // this appears to come from an existential type in an inherited member- not sure why isExistential is false here
+        /*println("Warning: Unknown prefixless type: " + sym + " in " + sym.owner + " in " + sym.enclClass)
+      println("\tFlags: " + sym.flags + ", istype: " + sym.isType + ", absT: " + sym.isAbstractType + ", alias: " + sym.isAliasType + ", nonclass: " + isNonClassType(sym))*/
+        reference(sym)
+      }
+    } else if (sym.isRoot || sym.isRootPackage) Constants.emptyType
+    else xsbti.api.Projection.of(processType(in, pre), simpleName(sym))
+  }
+  private def reference(sym: Symbol): xsbti.api.ParameterRef =
+    xsbti.api.ParameterRef.of(tparamID(sym))
+
+  // Constructing PrintWriters can cause lock contention in highly parallel code,
+  // it's constructor looks up the "line.separator" system property which locks
+  // on JDK 8.
+  //
+  // We can safely reuse a single instance, avoiding the lock contention and
+  // also reducing allocations a little.
+  private object ReusableTreePrinter {
+    import java.io._
+    private val buffer = new StringWriter()
+    private val printWriter = new PrintWriter(buffer)
+    private val treePrinter = newTreePrinter(printWriter)
+
+    /** More efficient version of trees.mkString(start, sep, end) */
+    def mkString(trees: List[Tree], start: String, sep: String, end: String): String = {
+      var rest: List[Tree] = trees
+      printWriter.append(start)
+      while (rest != Nil) {
+        treePrinter.printTree(rest.head)
+        rest = rest.tail
+        if (rest != Nil) {
+          printWriter.append(sep)
+        }
+      }
+      printWriter.append(end)
+      val result = getAndResetBuffer()
+      val benchmark = trees.mkString(start, sep, end)
+      assert(result == benchmark, List(result, benchmark).mkString("[", "|", "]"))
+      result
+    }
+    private def getAndResetBuffer(): String = {
+      printWriter.flush()
+      try buffer.getBuffer.toString
+      finally buffer.getBuffer.setLength(0)
+    }
+  }
+
+  // The compiler only pickles static annotations, so only include these in the API.
+  // This way, the API is not sensitive to whether we compiled from source or loaded from classfile.
+  // (When looking at the sources we see all annotations, but when loading from classes we only see the pickled (static) ones.)
+  private def mkAnnotations(in: Symbol, as: List[AnnotationInfo]): Array[xsbti.api.Annotation] = {
+    if (in == NoSymbol) ExtractAPI.emptyAnnotationArray
+    else
+      staticAnnotations(as) match {
+        case Nil => ExtractAPI.emptyAnnotationArray
+        case staticAs =>
+          staticAs.map { a =>
+            xsbti.api.Annotation.of(
+              processType(in, a.atp),
+              if (a.assocs.isEmpty)
+                Array(
+                  xsbti.api.AnnotationArgument
+                    .of("", ReusableTreePrinter.mkString(a.args, "(", ",", ")"))
+                ) // what else to do with a Tree?
+              else
+                a.assocs
+                  .map {
+                    case (name, value) =>
+                      xsbti.api.AnnotationArgument.of(name.toString, value.toString)
+                  }
+                  .toArray[xsbti.api.AnnotationArgument]
+            )
+          }.toArray
+      }
+  }
+
+  // HOT method, hand optimized to reduce allocations and needless creation of Names with calls to getterIn/setterIn
+  // on non-fields.
+  private def annotations(in: Symbol, s: Symbol): Array[xsbti.api.Annotation] = {
+    val saved = phase
+    phase = currentRun.typerPhase
+    try {
+      val base = if (s.hasFlag(Flags.ACCESSOR)) s.accessed else NoSymbol
+      val b = if (base == NoSymbol) s else base
+      // annotations from bean methods are not handled because:
+      //  a) they are recorded as normal source methods anyway
+      //  b) there is no way to distinguish them from user-defined methods
+      if (b.hasGetter) {
+        val annotations = collection.mutable.LinkedHashSet[xsbti.api.Annotation]()
+        def add(sym: Symbol) = if (sym != NoSymbol) {
+          val anns = mkAnnotations(in, sym.annotations)
+          var i = 0
+          while (i < anns.length) {
+            annotations += anns(i)
+            i += 1
+          }
+        }
+        add(b)
+        add(b.getterIn(b.enclClass))
+        add(b.setterIn(b.enclClass))
+        annotations.toArray
+      } else {
+        if (b.annotations.isEmpty) ExtractAPI.emptyAnnotationArray
+        else mkAnnotations(in, b.annotations)
+      }
+    } finally {
+      phase = saved
+    }
+  }
+
+  private def viewer(s: Symbol) = (if (s.isModule) s.moduleClass else s).thisType
+
+  private def defDef(in: Symbol, s: Symbol): xsbti.api.Def = {
+    @tailrec
+    def build(
+        t: Type,
+        typeParams: Array[xsbti.api.TypeParameter],
+        valueParameters: List[xsbti.api.ParameterList]
+    ): xsbti.api.Def = {
+      def parameterList(syms: List[Symbol]): xsbti.api.ParameterList = {
+        val isImplicitList = cond(syms) { case head :: _ => isImplicit(head) }
+        xsbti.api.ParameterList.of(syms.map(parameterS).toArray, isImplicitList)
+      }
+      t match {
+        case PolyType(typeParams0, base) =>
+          assert(typeParams.isEmpty, typeParams.toString)
+          assert(valueParameters.isEmpty, valueParameters.toString)
+          build(base, typeParameters(in, typeParams0), Nil)
+        case MethodType(params, resultType) =>
+          build(resultType, typeParams, parameterList(params) :: valueParameters)
+        case NullaryMethodType(resultType) =>
+          build(resultType, typeParams, valueParameters)
+        case returnType =>
+          val retType = processType(in, dropConst(returnType))
+          xsbti.api.Def.of(
+            simpleName(s),
+            getAccess(s),
+            getModifiers(s),
+            annotations(in, s),
+            typeParams,
+            valueParameters.reverse.toArray,
+            retType
+          )
+      }
+    }
+    def parameterS(s: Symbol): xsbti.api.MethodParameter = {
+      val tp: global.Type = s.info
+      makeParameter(simpleName(s), tp, tp.typeSymbol, s)
+    }
+
+    def makeParameter(
+        name: String,
+        tpe: Type,
+        ts: Symbol,
+        paramSym: Symbol
+    ): xsbti.api.MethodParameter = {
+      import xsbti.api.ParameterModifier._
+      val (t, special) =
+        if (ts == definitions.RepeatedParamClass) // || s == definitions.JavaRepeatedParamClass)
+          (tpe.typeArgs.head, Repeated)
+        else if (ts == definitions.ByNameParamClass)
+          (tpe.typeArgs.head, ByName)
+        else
+          (tpe, Plain)
+      xsbti.api.MethodParameter.of(name, processType(in, t), hasDefault(paramSym), special)
+    }
+    val t = viewer(in).memberInfo(s)
+    build(t, Array(), Nil)
+  }
+  private def hasDefault(s: Symbol) = s != NoSymbol && s.hasFlag(Flags.DEFAULTPARAM)
+  private def fieldDef[T](
+      in: Symbol,
+      s: Symbol,
+      keepConst: Boolean,
+      create: (
+          String,
+          xsbti.api.Access,
+          xsbti.api.Modifiers,
+          Array[xsbti.api.Annotation],
+          xsbti.api.Type
+      ) => T
+  ): T = {
+    val t = dropNullary(viewer(in).memberType(s))
+    val t2 = if (keepConst) t else dropConst(t)
+    create(simpleName(s), getAccess(s), getModifiers(s), annotations(in, s), processType(in, t2))
+  }
+  private def dropConst(t: Type): Type = t match {
+    case ConstantType(constant) => constant.tpe
+    case _                      => t
+  }
+  private def dropNullary(t: Type): Type = t match {
+    case NullaryMethodType(un) => un
+    case _                     => t
+  }
+
+  private def typeDef(in: Symbol, s: Symbol): xsbti.api.TypeMember = {
+    val (typeParams, tpe) =
+      viewer(in).memberInfo(s) match {
+        case PolyType(typeParams0, base) => (typeParameters(in, typeParams0), base)
+        case t                           => (Array[xsbti.api.TypeParameter](), t)
+      }
+    val name = simpleName(s)
+    val access = getAccess(s)
+    val modifiers = getModifiers(s)
+    val as = annotations(in, s)
+
+    if (s.isAliasType)
+      xsbti.api.TypeAlias.of(name, access, modifiers, as, typeParams, processType(in, tpe))
+    else if (s.isAbstractType) {
+      val bounds = tpe.bounds
+      xsbti.api.TypeDeclaration.of(
+        name,
+        access,
+        modifiers,
+        as,
+        typeParams,
+        processType(in, bounds.lo),
+        processType(in, bounds.hi)
+      )
+    } else
+      error("Unknown type member" + s)
+  }
+
+  private def structure(info: Type, s: Symbol): xsbti.api.Structure =
+    structureCache.getOrElseUpdate(s, mkStructure(info, s))
+  private def structureWithInherited(info: Type, s: Symbol): xsbti.api.Structure =
+    structureCache.getOrElseUpdate(s, mkStructureWithInherited(info, s))
+
+  private def removeConstructors(ds: List[Symbol]): List[Symbol] = ds filter { !_.isConstructor }
+
+  /**
+   * Create structure as-is, without embedding ancestors
+   *
+   * (for refinement types, and ClassInfoTypes encountered outside of a definition???).
+   */
+  private def mkStructure(info: Type, s: Symbol): xsbti.api.Structure = {
+    // We're not interested in the full linearization, so we can just use `parents`,
+    // which side steps issues with baseType when f-bounded existential types and refined types mix
+    // (and we get cyclic types which cause a stack overflow in showAPI).
+    val parentTypes = info.parents
+    val decls = info.decls.toList
+    val declsNoModuleCtor = if (s.isModuleClass) removeConstructors(decls) else decls
+    mkStructure(s, parentTypes, declsNoModuleCtor, Nil)
+  }
+
+  /**
+   * Track all ancestors and inherited members for a class's API.
+   *
+   * A class's hash does not include hashes for its parent classes -- only the symbolic names --
+   * so we must ensure changes propagate somehow.
+   *
+   * TODO: can we include hashes for parent classes instead? This seems a bit messy.
+   */
+  private def mkStructureWithInherited(info: Type, s: Symbol): xsbti.api.Structure = {
+    val ancestorTypes0 = linearizedAncestorTypes(info)
+    val ancestorTypes =
+      if (s.isDerivedValueClass) {
+        val underlying = s.derivedValueClassUnbox.tpe.finalResultType
+        // The underlying type of a value class should be part of the name hash
+        // of the value class (see the test `value-class-underlying`), this is accomplished
+        // by adding the underlying type to the list of parent types.
+        underlying :: ancestorTypes0
+      } else
+        ancestorTypes0
+    val decls = info.decls.toList
+    val declsNoModuleCtor = if (s.isModuleClass) removeConstructors(decls) else decls
+    val declSet = decls.toSet
+    val inherited =
+      info.nonPrivateMembers.toList.filterNot(declSet) // private members are not inherited
+    mkStructure(s, ancestorTypes, declsNoModuleCtor, inherited)
+  }
+
+  // Note that the ordering of classes in `baseClasses` is important.
+  // It would be easier to just say `baseTypeSeq.toList.tail`,
+  // but that does not take linearization into account.
+  def linearizedAncestorTypes(info: Type): List[Type] = info.baseClasses.tail.map(info.baseType)
+
+  private def mkStructure(
+      s: Symbol,
+      bases: List[Type],
+      declared: List[Symbol],
+      inherited: List[Symbol]
+  ): xsbti.api.Structure = {
+    xsbti.api.Structure.of(
+      lzy(types(s, bases)),
+      lzy(processDefinitions(s, declared)),
+      lzy(processDefinitions(s, inherited))
+    )
+  }
+  private def processDefinitions(in: Symbol, defs: List[Symbol]): Array[xsbti.api.ClassDefinition] =
+    sort(defs.toArray).flatMap((d: Symbol) => definition(in, d))
+  private[this] def sort(defs: Array[Symbol]): Array[Symbol] = {
+    Arrays.sort(defs, sortClasses)
+    defs
+  }
+
+  private def definition(in: Symbol, sym: Symbol): Option[xsbti.api.ClassDefinition] = {
+    def mkVar = Some(fieldDef(in, sym, keepConst = false, xsbti.api.Var.of(_, _, _, _, _)))
+    def mkVal = Some(fieldDef(in, sym, keepConst = true, xsbti.api.Val.of(_, _, _, _, _)))
+    if (isClass(sym))
+      if (ignoreClass(sym)) {
+        allNonLocalClassSymbols.+=(sym); None
+      } else Some(classLike(in, sym))
+    else if (sym.isNonClassType)
+      Some(typeDef(in, sym))
+    else if (sym.isVariable)
+      if (isSourceField(sym)) mkVar else None
+    else if (sym.isStable)
+      if (isSourceField(sym)) mkVal else None
+    else if (sym.isSourceMethod && !sym.isSetter)
+      if (sym.isGetter) mkVar else Some(defDef(in, sym))
+    else
+      None
+  }
+  private def ignoreClass(sym: Symbol): Boolean =
+    sym.isLocalClass || sym.isAnonymousClass || sym.fullName.endsWith(tpnme.LOCAL_CHILD.toString)
+
+  // This filters private[this] vals/vars that were not in the original source.
+  //  The getter will be used for processing instead.
+  private def isSourceField(sym: Symbol): Boolean = {
+    val getter = sym.getterIn(sym.enclClass)
+    // the check `getter eq sym` is a precaution against infinite recursion
+    // `isParamAccessor` does not exist in all supported versions of Scala, so the flag check is done directly
+    (getter == NoSymbol && !sym.hasFlag(Flags.PARAMACCESSOR)) || (getter eq sym)
+  }
+  private def getModifiers(s: Symbol): xsbti.api.Modifiers = {
+    import Flags._
+    val absOver = s.hasFlag(ABSOVERRIDE)
+    val abs = s.hasFlag(ABSTRACT) || s.hasFlag(DEFERRED) || absOver
+    val over = s.hasFlag(OVERRIDE) || absOver
+    new xsbti.api.Modifiers(
+      abs,
+      over,
+      s.isFinal,
+      s.hasFlag(SEALED),
+      isImplicit(s),
+      s.hasFlag(LAZY),
+      s.hasFlag(MACRO),
+      s.hasFlag(SUPERACCESSOR)
+    )
+  }
+
+  private def isImplicit(s: Symbol) = s.hasFlag(Flags.IMPLICIT)
+  private def getAccess(c: Symbol): xsbti.api.Access = {
+    if (c.isPublic) Constants.public
+    else if (c.isPrivateLocal) Constants.privateLocal
+    else if (c.isProtectedLocal) Constants.protectedLocal
+    else {
+      val within = c.privateWithin
+      val qualifier =
+        if (within == NoSymbol) Constants.unqualified
+        else xsbti.api.IdQualifier.of(within.fullName)
+      if (c.hasFlag(Flags.PROTECTED)) xsbti.api.Protected.of(qualifier)
+      else xsbti.api.Private.of(qualifier)
+    }
+  }
+
+  /**
+   * Replace all types that directly refer to the `forbidden` symbol by `NoType`.
+   * (a specialized version of substThisAndSym)
+   */
+  class SuppressSymbolRef(forbidden: Symbol) extends TypeMap {
+    def apply(tp: Type) =
+      if (tp.typeSymbolDirect == forbidden) NoType
+      else mapOver(tp)
+  }
+
+  private def processType(in: Symbol, t: Type): xsbti.api.Type =
+    typeCache.getOrElseUpdate((in, t), makeType(in, t))
+  private def makeType(in: Symbol, t: Type): xsbti.api.Type = {
+
+    val dealiased = t match {
+      case TypeRef(_, sym, _) if sym.isAliasType => t.dealias
+      case _                                     => t
+    }
+
+    dealiased match {
+      case NoPrefix             => Constants.emptyType
+      case ThisType(sym)        => xsbti.api.Singleton.of(thisPath(sym))
+      case SingleType(pre, sym) => projectionType(in, pre, sym)
+      case ConstantType(constant) =>
+        xsbti.api.Constant.of(processType(in, constant.tpe), constant.stringValue)
+
+      /* explaining the special-casing of references to refinement classes (https://support.typesafe.com/tickets/1882)
+       *
+       * goal: a representation of type references to refinement classes that's stable across compilation runs
+       *       (and thus insensitive to typing from source or unpickling from bytecode)
+       *
+       * problem: the current representation, which corresponds to the owner chain of the refinement:
+       *   1. is affected by pickling, so typing from source or using unpickled symbols give different results (because the unpickler "localizes" owners -- this could be fixed in the compiler)
+       *   2. can't distinguish multiple refinements in the same owner (this is a limitation of SBT's internal representation and cannot be fixed in the compiler)
+       *
+       * potential solutions:
+       *   - simply drop the reference: won't work as collapsing all refinement types will cause recompilation to be skipped when a refinement is changed to another refinement
+       *   - represent the symbol in the api: can't think of a stable way of referring to an anonymous symbol whose owner changes when pickled
+       *   + expand the reference to the corresponding refinement type: doing that recursively may not terminate, but we can deal with that by approximating recursive references
+       *     (all we care about is being sound for recompilation: recompile iff a dependency changes, and this will happen as long as we have one unrolling of the reference to the refinement)
+       */
+      case TypeRef(pre, sym, Nil) if sym.isRefinementClass =>
+        // Since we only care about detecting changes reliably, we unroll a reference to a refinement class once.
+        // Recursive references are simply replaced by NoType -- changes to the type will be seen in the first unrolling.
+        // The API need not be type correct, so this truncation is acceptable. Most of all, the API should be compact.
+        val unrolling = pre.memberInfo(sym) // this is a refinement type
+
+        // in case there are recursive references, suppress them -- does this ever happen?
+        // we don't have a test case for this, so warn and hope we'll get a contribution for it :-)
+        val withoutRecursiveRefs = new SuppressSymbolRef(sym).mapOver(unrolling)
+        if (unrolling ne withoutRecursiveRefs)
+          reporter.warning(
+            sym.pos,
+            "sbt-api: approximated refinement ref" + t + " (== " + unrolling + ") to " + withoutRecursiveRefs + "\nThis is currently untested, please report the code you were compiling."
+          )
+
+        structure(withoutRecursiveRefs, sym)
+      case tr @ TypeRef(pre, sym, args) =>
+        val base = projectionType(in, pre, sym)
+        if (args.isEmpty)
+          if (isRawType(tr))
+            processType(in, rawToExistential(tr))
+          else
+            base
+        else
+          xsbti.api.Parameterized.of(base, types(in, args))
+      case SuperType(thistpe: Type, supertpe: Type) =>
+        reporter.warning(
+          NoPosition,
+          "sbt-api: Super type (not implemented): this=" + thistpe + ", super=" + supertpe
+        )
+        Constants.emptyType
+      case at: AnnotatedType =>
+        at.annotations match {
+          case Nil => processType(in, at.underlying)
+          case annots =>
+            xsbti.api.Annotated.of(processType(in, at.underlying), mkAnnotations(in, annots))
+        }
+      case rt: CompoundType   => structure(rt, rt.typeSymbol)
+      case t: ExistentialType => makeExistentialType(in, t)
+      case NoType =>
+        Constants.emptyType // this can happen when there is an error that will be reported by a later phase
+      case PolyType(typeParams, resultType) =>
+        xsbti.api.Polymorphic.of(processType(in, resultType), typeParameters(in, typeParams))
+      case NullaryMethodType(_) =>
+        reporter.warning(
+          NoPosition,
+          "sbt-api: Unexpected nullary method type " + in + " in " + in.owner
+        )
+        Constants.emptyType
+      case MethodType(_, _) =>
+        reporter.echo(NoPosition, s"sbt-api: Unhandled method type $in in ${in.owner}")
+        Constants.emptyType
+      case _ =>
+        reporter.warning(NoPosition, "sbt-api: Unhandled type " + t.getClass + " : " + t)
+        Constants.emptyType
+    }
+  }
+  private def makeExistentialType(in: Symbol, t: ExistentialType): xsbti.api.Existential = {
+    val ExistentialType(typeVariables, qualified) = t
+    existentialRenamings.enterExistentialTypeVariables(typeVariables)
+    try {
+      val typeVariablesConverted = typeParameters(in, typeVariables)
+      val qualifiedConverted = processType(in, qualified)
+      xsbti.api.Existential.of(qualifiedConverted, typeVariablesConverted)
+    } finally {
+      existentialRenamings.leaveExistentialTypeVariables(typeVariables)
+    }
+  }
+  private def typeParameters(in: Symbol, s: Symbol): Array[xsbti.api.TypeParameter] =
+    typeParameters(in, s.typeParams)
+  private def typeParameters(in: Symbol, s: List[Symbol]): Array[xsbti.api.TypeParameter] =
+    s.map(typeParameter(in, _)).toArray[xsbti.api.TypeParameter]
+  private def typeParameter(in: Symbol, s: Symbol): xsbti.api.TypeParameter = {
+    val varianceInt = s.variance
+    import xsbti.api.Variance._
+    val annots = annotations(in, s)
+    val variance =
+      if (varianceInt < 0) Contravariant else if (varianceInt > 0) Covariant else Invariant
+    viewer(in).memberInfo(s) match {
+      case TypeBounds(low, high) =>
+        xsbti.api.TypeParameter.of(
+          tparamID(s),
+          annots,
+          typeParameters(in, s),
+          variance,
+          processType(in, low),
+          processType(in, high)
+        )
+      case PolyType(typeParams, base) =>
+        xsbti.api.TypeParameter.of(
+          tparamID(s),
+          annots,
+          typeParameters(in, typeParams),
+          variance,
+          processType(in, base.bounds.lo),
+          processType(in, base.bounds.hi)
+        )
+      case x => error("Unknown type parameter info: " + x.getClass)
+    }
+  }
+  private def tparamID(s: Symbol): String =
+    existentialRenamings.renaming(s) match {
+      case Some(rename) =>
+        debuglog(s"Renaming existential type variable ${s.fullName} to $rename")
+        rename
+      case None =>
+        s.fullName
+    }
+
+  /* Representation for the self type of a class symbol `s`, or `emptyType` for an *unascribed* self variable (or no self variable at all).
+     Only the self variable's explicitly ascribed type is relevant for incremental compilation. */
+  private def selfType(in: Symbol, s: Symbol): xsbti.api.Type =
+    // `sym.typeOfThis` is implemented as `sym.thisSym.info`, which ensures the *self* symbol is initialized (the type completer is run).
+    // We can safely avoid running the type completer for `thisSym` for *class* symbols where `thisSym == this`,
+    // as that invariant is established on completing the class symbol (`mkClassLike` calls `s.initialize` before calling us).
+    // Technically, we could even ignore a self type that's a supertype of the class's type,
+    // as it does not contribute any information relevant outside of the class definition.
+    if ((s.thisSym eq s) || (s.thisSym.tpeHK == s.tpeHK)) Constants.emptyType
+    else processType(in, s.typeOfThis)
+
+  def extractAllClassesOf(in: Symbol, c: Symbol): Unit = {
+    classLike(in, c)
+    ()
+  }
+
+  def allExtractedNonLocalClasses: Set[ClassLike] = {
+    forceStructures()
+    allNonLocalClassesInSrc.toSet
+  }
+
+  def allExtractedNonLocalSymbols: Set[Symbol] = allNonLocalClassSymbols.toSet
+
+  def mainClasses: Set[String] = {
+    forceStructures()
+    _mainClasses.toSet
+  }
+
+  private def classLike(in: Symbol, c: Symbol): ClassLikeDef =
+    classLikeCache.getOrElseUpdate((in, c), mkClassLike(in, c))
+  private def mkClassLike(in: Symbol, c: Symbol): ClassLikeDef = {
+    // Normalize to a class symbol, and initialize it.
+    // (An object -- aka module -- also has a term symbol,
+    //  but it's the module class that holds the info about its structure.)
+    val sym = (if (c.isModule) c.moduleClass else c).initialize
+    val defType =
+      if (sym.isTrait) DefinitionType.Trait
+      else if (sym.isModuleClass) {
+        if (sym.isPackageObjectClass) DefinitionType.PackageModule
+        else DefinitionType.Module
+      } else DefinitionType.ClassDef
+    val childrenOfSealedClass = sort(sym.sealedDescendants.toArray).map(c => processType(c, c.tpe))
+    val topLevel = sym.owner.isPackageClass
+    val anns = annotations(in, c)
+    val modifiers = getModifiers(c)
+    val acc = getAccess(c)
+    val name = classNameAsSeenIn(in, c)
+    val tParams = typeParameters(in, sym) // look at class symbol
+    val selfType = lzy(this.selfType(in, sym))
+    def constructClass(structure: xsbti.api.Lazy[Structure]): ClassLike = {
+      xsbti.api.ClassLike.of(
+        name,
+        acc,
+        modifiers,
+        anns,
+        defType,
+        selfType,
+        structure,
+        emptyStringArray,
+        childrenOfSealedClass,
+        topLevel,
+        tParams
+      ) // use original symbol (which is a term symbol when `c.isModule`) for `name` and other non-classy stuff
+    }
+    val info = viewer(in).memberInfo(sym)
+    val structure = lzy(structureWithInherited(info, sym))
+    val classWithMembers = constructClass(structure)
+
+    allNonLocalClassesInSrc += classWithMembers
+    allNonLocalClassSymbols += sym
+
+    if (sym.isStatic && defType == DefinitionType.Module && definitions.hasJavaMainMethod(sym)) {
+      _mainClasses += name
+    }
+
+    val classDef = xsbti.api.ClassLikeDef.of(
+      name,
+      acc,
+      modifiers,
+      anns,
+      tParams,
+      defType
+    ) // use original symbol (which is a term symbol when `c.isModule`) for `name` and other non-classy stuff
+    classDef
+  }
+
+  // TODO: could we restrict ourselves to classes, ignoring the term symbol for modules,
+  // since everything we need to track about a module is in the module's class (`moduleSym.moduleClass`)?
+  private[this] def isClass(s: Symbol) = s.isClass || s.isModule
+  // necessary to ensure a stable ordering of classes in the definitions list:
+  //  modules and classes come first and are sorted by name
+  // all other definitions come later and are not sorted
+  private[this] val sortClasses = new Comparator[Symbol] {
+    def compare(a: Symbol, b: Symbol) = {
+      val aIsClass = isClass(a)
+      val bIsClass = isClass(b)
+      if (aIsClass == bIsClass)
+        if (aIsClass)
+          if (a.isModule == b.isModule)
+            a.fullName.compareTo(b.fullName)
+          else if (a.isModule)
+            -1
+          else
+            1
+        else
+          0 // substantial performance hit if fullNames are compared here
+      else if (aIsClass)
+        -1
+      else
+        1
+    }
+  }
+  private object Constants {
+    val local = xsbti.api.ThisQualifier.of()
+    val public = xsbti.api.Public.of()
+    val privateLocal = xsbti.api.Private.of(local)
+    val protectedLocal = xsbti.api.Protected.of(local)
+    val unqualified = xsbti.api.Unqualified.of()
+    val emptyPath = xsbti.api.Path.of(Array())
+    val thisPath = xsbti.api.This.of()
+    val emptyType = xsbti.api.EmptyType.of()
+  }
+
+  private def simpleName(s: Symbol): String = {
+    val n = s.unexpandedName
+    val n2 = if (n == nme.CONSTRUCTOR) constructorNameAsString(s.enclClass) else n.decode.toString
+    n2.trim
+  }
+
+  private def staticAnnotations(annotations: List[AnnotationInfo]): List[AnnotationInfo] =
+    if (annotations == Nil) Nil
+    else {
+      // `isStub` for scala/bug#11679: annotations of inherited members may be absent from the compile time
+      // classpath so avoid calling `isNonBottomSubClass` on these stub symbols which would trigger an error.
+      //
+      // `initialize` for sbt/zinc#998: 2.13 identifies Java annotations by flags. Up to 2.13.6, this is done
+      // without forcing the info of `ann.atp.typeSymbol`, flags are missing it's still a `ClassfileLoader`.
+      annotations.filter(ann =>
+        !isStub(ann.atp.typeSymbol) && { ann.atp.typeSymbol.initialize; ann.isStatic }
+      )
+    }
+
+  private def isStub(sym: Symbol): Boolean = sym match {
+    case _: StubSymbol => true
+    case _             => false
+  }
+}
+
+object ExtractAPI {
+  private val emptyAnnotationArray = new Array[xsbti.api.Annotation](0)
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/ExtractUsedNames.scala b/src/sbt-bridge/scala/tools/xsbt/ExtractUsedNames.scala
new file mode 100644
index 0000000000..c2fa29d3a6
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/ExtractUsedNames.scala
@@ -0,0 +1,363 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.util.{ HashMap => JavaMap }
+import java.util.{ HashSet => JavaSet }
+import java.util.EnumSet
+
+import xsbti.UseScope
+
+/**
+ * Extracts simple names used in given compilation unit.
+ *
+ * Extracts simple (unqualified) names mentioned in given in non-definition position by collecting
+ * all symbols associated with non-definition trees and extracting names from all collected symbols.
+ * Also extract the names of the types of non-definition trees (see source-dependencies/types-in-used-names-*
+ * and source-dependencies/as-seen-from-* for examples where this is required).
+ *
+ * If given symbol is mentioned both in definition and in non-definition position (e.g. in member
+ * selection) then that symbol is collected. It means that names of symbols defined and used in the
+ * same compilation unit are extracted. We've considered not extracting names of those symbols
+ * as an optimization strategy. It turned out that this is not correct.  Check
+ * https://github.com/gkossakowski/sbt/issues/3 for an example of scenario where it matters.
+ *
+ * All extracted names are returned in _decoded_ form. This way we stay consistent with the rest
+ * of incremental compiler which works with names in decoded form.
+ *
+ * Names mentioned in Import nodes are handled properly but require some special logic for two
+ * reasons:
+ *
+ *   1. The `termSymbol` of Import nodes point to the symbol of the prefix it imports from
+ *      (not the actual members that we import, that are represented as names).
+ *   2. ImportSelector is not subtype of Tree therefore is not processed by `Tree.foreach`.
+ *
+ * Another type of tree nodes that requires special handling is TypeTree. TypeTree nodes
+ * has a little bit odd representation:
+ *
+ *   1. TypeTree.hasSymbol always returns false even when TypeTree.symbol
+ *      returns a symbol
+ *   2. The original tree from which given TypeTree was derived is stored
+ *      in TypeTree.original but Tree.forech doesn't walk into original
+ *      tree so we missed it
+ *
+ * The tree walking algorithm walks into TypeTree.original explicitly.
+ *
+ */
+class ExtractUsedNames[GlobalType <: CallbackGlobal](val global: GlobalType)
+    extends Compat
+    with ClassName
+    with GlobalHelpers {
+
+  import global._
+  import JavaUtils._
+
+  private final class NamesUsedInClass {
+    // Default names and other scopes are separated for performance reasons
+    val defaultNames: JavaSet[Name] = new JavaSet[global.Name]()
+    val scopedNames: JavaMap[Name, EnumSet[UseScope]] = new JavaMap[Name, EnumSet[UseScope]]()
+
+    // We have to leave with commas on ends
+    override def toString(): String = {
+      val builder = new StringBuilder(": ")
+      defaultNames.foreach { name =>
+        builder.append(name.decoded.trim)
+        val otherScopes = scopedNames.get(name)
+        if (otherScopes != null) {
+          builder.append(" in [")
+          otherScopes.foreach(scope => builder.append(scope.name()).append(", "))
+          builder.append("]")
+        }
+        builder.append(", ")
+      }
+      builder.toString()
+    }
+  }
+
+  private def DefaultScopes = EnumSet.of(UseScope.Default)
+  private def PatmatScopes = EnumSet.of(UseScope.PatMatTarget)
+
+  def extractAndReport(unit: CompilationUnit): Unit = {
+    val tree = unit.body
+    val traverser = new ExtractUsedNamesTraverser
+    traverser.traverse(tree)
+
+    val namesUsedAtTopLevel = traverser.namesUsedAtTopLevel
+    val defaultNamesTopLevel = namesUsedAtTopLevel.defaultNames
+    val scopedNamesTopLevel = namesUsedAtTopLevel.scopedNames
+
+    // Handle names used at top level that cannot be related to an owner
+    if (!defaultNamesTopLevel.isEmpty || !scopedNamesTopLevel.isEmpty) {
+      val responsible = firstClassOrModuleDef(tree)
+      responsible match {
+        case Some(classOrModuleDef) =>
+          val sym = classOrModuleDef.symbol
+          val firstClassSymbol = enclOrModuleClass(sym)
+          val firstClassName = className(firstClassSymbol)
+          val namesInFirstClass = traverser.usedNamesFromClass(firstClassName)
+          val scopedNamesInFirstClass = namesInFirstClass.scopedNames
+
+          namesInFirstClass.defaultNames.addAll(defaultNamesTopLevel)
+          scopedNamesTopLevel.foreach { (topLevelName, topLevelScopes) =>
+            val existingScopes = scopedNamesInFirstClass.get(topLevelName)
+            if (existingScopes == null)
+              scopedNamesInFirstClass.put(topLevelName, topLevelScopes)
+            else existingScopes.addAll(topLevelScopes)
+            ()
+          }
+
+        case None =>
+          reporter.echo(unit.position(0), Feedback.OrphanNames)
+      }
+    }
+
+    debuglog {
+      val msg = s"The ${unit.source} contains the following used names:\n"
+      val builder = new StringBuilder(msg)
+      traverser.usedNamesFromClasses.foreach { (name, usedNames) =>
+        builder
+          .append(name.toString.trim)
+          .append(": ")
+          .append(usedNames.toString())
+          .append("\n")
+        ()
+      }
+      builder.toString()
+    }
+
+    // Handle names circumscribed to classes
+    traverser.usedNamesFromClasses.foreach { (rawClassName, usedNames) =>
+      val className = rawClassName.toString.trim.intern()
+      usedNames.defaultNames.foreach { rawUsedName =>
+        val useName = rawUsedName.decoded.trim.intern()
+        val existingScopes = usedNames.scopedNames.get(rawUsedName)
+        val useScopes = {
+          if (existingScopes == null) DefaultScopes
+          else {
+            existingScopes.add(UseScope.Default)
+            existingScopes
+          }
+        }
+        callback.usedName(className, useName, useScopes)
+      }
+    }
+  }
+
+  private def firstClassOrModuleDef(tree: Tree): Option[Tree] = {
+    tree find {
+      case ((_: ClassDef) | (_: ModuleDef)) => true
+      case _                                => false
+    }
+  }
+
+  private class ExtractUsedNamesTraverser extends Traverser {
+
+    val usedNamesFromClasses = new JavaMap[Name, NamesUsedInClass]()
+    val namesUsedAtTopLevel = new NamesUsedInClass
+
+    override def traverse(tree: Tree): Unit = {
+      handleClassicTreeNode(tree)
+      processMacroExpansion(tree)(handleMacroExpansion)
+      super.traverse(tree)
+    }
+
+    val addSymbol: (JavaSet[Name], Symbol) => Unit = { (names: JavaSet[Name], symbol: Symbol) =>
+      // Synthetic names are no longer included. See https://github.com/sbt/sbt/issues/2537
+      if (!ignoredSymbol(symbol) && !isEmptyName(symbol.name)) {
+        names.add(mangledName(symbol))
+        ()
+      }
+    }
+
+    /** Returns mutable set with all names from given class used in current context */
+    def usedNamesFromClass(className: Name): NamesUsedInClass = {
+      val names = usedNamesFromClasses.get(className)
+      if (names == null) {
+        val newOne = new NamesUsedInClass
+        usedNamesFromClasses.put(className, newOne)
+        newOne
+      } else names
+    }
+
+    /*
+     * Some macros appear to contain themselves as original tree.
+     * We must check that we don't inspect the same tree over and over.
+     * See https://issues.scala-lang.org/browse/SI-8486
+     *     https://github.com/sbt/sbt/issues/1237
+     *     https://github.com/sbt/sbt/issues/1544
+     */
+    private val inspectedOriginalTrees = new JavaSet[Tree]()
+    private val inspectedTypeTrees = new JavaSet[Tree]()
+
+    private val handleMacroExpansion: Tree => Unit = { original =>
+      if (!inspectedOriginalTrees.contains(original)) {
+        inspectedOriginalTrees.add(original)
+        traverse(original)
+      }
+    }
+
+    private object PatMatDependencyTraverser extends TypeDependencyTraverser {
+      override def addDependency(symbol: global.Symbol): Unit = {
+        if (!ignoredSymbol(symbol) && symbol.isSealed) {
+          val name = mangledName(symbol)
+          if (!isEmptyName(name)) {
+            val existingScopes = _currentScopedNamesCache.get(name)
+            if (existingScopes == null)
+              _currentScopedNamesCache.put(name, PatmatScopes)
+            else existingScopes.add(UseScope.PatMatTarget)
+          }
+        }
+        ()
+      }
+    }
+
+    private object TypeDependencyTraverser extends TypeDependencyTraverser {
+      private val ownersCache = new JavaMap[Symbol, JavaSet[Type]]()
+      private var nameCache: JavaSet[Name] = _
+      private var ownerVisited: Symbol = _
+
+      def setCacheAndOwner(cache: JavaSet[Name], owner: Symbol): Unit = {
+        if (ownerVisited != owner) {
+          val ts = ownersCache.get(owner)
+
+          if (ts == null) {
+            val newVisited = new JavaSet[Type]()
+            visited = newVisited
+            ownersCache.put(owner, newVisited)
+          } else {
+            visited = ts
+          }
+
+          nameCache = cache
+          ownerVisited = owner
+        }
+      }
+
+      override def addDependency(symbol: global.Symbol): Unit =
+        addSymbol(nameCache, symbol)
+    }
+
+    private def handleClassicTreeNode(tree: Tree): Unit = tree match {
+      // Register names from pattern match target type in PatMatTarget scope
+      case ValDef(mods, _, tpt, _) if mods.isCase && mods.isSynthetic =>
+        updateCurrentOwner()
+        PatMatDependencyTraverser.traverse(tpt.tpe)
+      case _: DefTree | _: Template => ()
+      case Import(_, selectors: List[ImportSelector]) =>
+        val names = getNamesOfEnclosingScope
+        def usedNameInImportSelector(name: Name): Unit = {
+          if (!isEmptyName(name) && (name != nme.WILDCARD) && !names.contains(name)) {
+            names.add(name)
+            ()
+          }
+        }
+        selectors foreach { selector =>
+          usedNameInImportSelector(selector.name)
+          usedNameInImportSelector(selector.rename)
+        }
+      /* Original type trees have to be traversed because typer is very
+       * aggressive when expanding explicit user-defined types. For instance,
+       * `Foo#B` will be expanded to `C` and the dependency on `Foo` will be
+       * lost. This makes sure that we traverse all the original prefixes. */
+      case t: TypeTree if t.original != null =>
+        val original = t.original
+        if (!inspectedTypeTrees.contains(original)) {
+          inspectedTypeTrees.add(original)
+          original.foreach(traverse)
+        }
+
+      case t if t.hasSymbolField =>
+        val symbol = t.symbol
+        if (symbol != rootMirror.RootPackage) {
+          addSymbol(getNamesOfEnclosingScope, t.symbol)
+        }
+
+        val tpe = t.tpe
+        if (!ignoredType(tpe)) {
+          // Initialize _currentOwner if it's not
+          val cache = getNamesOfEnclosingScope
+          TypeDependencyTraverser.setCacheAndOwner(cache, _currentOwner)
+          TypeDependencyTraverser.traverse(tpe)
+        }
+      case l: Literal =>
+        processOriginalTreeAttachment(l)(traverse)
+      case _ =>
+    }
+
+    private var _currentOwner: Symbol = _
+    private var _currentNonLocalClass: Symbol = _
+    private var _currentNamesCache: JavaSet[Name] = _
+    private var _currentScopedNamesCache: JavaMap[Name, EnumSet[UseScope]] = _
+
+    @inline private def resolveNonLocal(from: Symbol): Symbol = {
+      val fromClass = enclOrModuleClass(from)
+      if (ignoredSymbol(fromClass) || fromClass.hasPackageFlag) NoSymbol
+      else localToNonLocalClass.resolveNonLocal(fromClass)
+    }
+
+    @inline private def namesInClass(nonLocalClass: Symbol): NamesUsedInClass = {
+      if (nonLocalClass == NoSymbol) namesUsedAtTopLevel
+      else usedNamesFromClass(ExtractUsedNames.this.className(nonLocalClass))
+    }
+
+    /**
+     * Updates caches for closest non-local class owner of a tree given
+     * `currentOwner`, defined and updated by `Traverser`.
+     *
+     * This method modifies the state associated with the names variable
+     * `_currentNamesCache` and `_currentScopedNamesCache`, which are composed
+     * by `_currentOwner` and and `_currentNonLocalClass`.
+     *
+     * * The used caching strategy works as follows:
+     * 1. Do nothing if owners are referentially equal.
+     * 2. Otherwise, check if they resolve to the same non-local class.
+     *   1. If they do, do nothing
+     *   2. Otherwise, overwrite all the pertinent fields to be consistent.
+     */
+    private def updateCurrentOwner(): Unit = {
+      if (_currentOwner == null) {
+        // Set the first state for the enclosing non-local class
+        _currentOwner = currentOwner
+        _currentNonLocalClass = resolveNonLocal(currentOwner)
+        val usedInClass = namesInClass(_currentNonLocalClass)
+        _currentNamesCache = usedInClass.defaultNames
+        _currentScopedNamesCache = usedInClass.scopedNames
+      } else if (_currentOwner != currentOwner) {
+        val nonLocalClass = resolveNonLocal(currentOwner)
+        if (_currentNonLocalClass != nonLocalClass) {
+          _currentOwner = currentOwner
+          _currentNonLocalClass = nonLocalClass
+          val usedInClass = namesInClass(_currentNonLocalClass)
+          _currentNamesCache = usedInClass.defaultNames
+          _currentScopedNamesCache = usedInClass.scopedNames
+        }
+      }
+    }
+
+    /**
+     * Return the names associated with the closest non-local class owner
+     * of a tree given `currentOwner`, defined and updated by `Traverser`.
+     *
+     * This method modifies the state associated with the names variable
+     * by calling `updateCurrentOwner()`.
+     */
+    @inline
+    private def getNamesOfEnclosingScope: JavaSet[Name] = {
+      updateCurrentOwner()
+      _currentNamesCache
+    }
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/GlobalHelpers.scala b/src/sbt-bridge/scala/tools/xsbt/GlobalHelpers.scala
new file mode 100644
index 0000000000..5c1a4eb5fc
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/GlobalHelpers.scala
@@ -0,0 +1,186 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import scala.tools.nsc.Global
+import java.util.HashSet
+
+trait GlobalHelpers { self: Compat =>
+  val global: Global
+  import global._
+
+  /** Return true if type shall be ignored, false otherwise. */
+  @inline def ignoredType(tpe: Type) = {
+    tpe == null ||
+    tpe == NoType ||
+    tpe.typeSymbol == EmptyPackageClass
+  }
+
+  /** Return true if symbol shall be ignored, false otherwise. */
+  @inline def ignoredSymbol(symbol: Symbol) = {
+    symbol == null ||
+    symbol == NoSymbol ||
+    symbol == EmptyPackageClass
+  }
+
+  /** Return true if name is empty, false otherwise. */
+  def isEmptyName(name: Name): Boolean = {
+    name match {
+      case null | nme.EMPTY | nme.EMPTY_PACKAGE_NAME | tpnme.EMPTY | tpnme.EMPTY_PACKAGE_NAME =>
+        true
+      case _ => false
+    }
+  }
+
+  private[xsbt] abstract class TypeDependencyTraverser extends TypeTraverser {
+    def addDependency(symbol: Symbol): Unit
+
+    /** Add type dependency ignoring packages and inheritance info from classes. */
+    @inline private def addTypeSymbolDependency(symbol: Symbol): Unit = {
+      addDependency(symbol)
+      if (!symbol.isClass) {
+        traverse(symbol.info)
+      }
+    }
+
+    /** Add type dependency *AND* traverse prefix iff is not a package. */
+    @inline private def addTypeDependency(tpe: Type): Unit = {
+      val symbol = tpe.typeSymbolDirect
+      if (!symbol.hasPackageFlag) {
+        addTypeSymbolDependency(symbol)
+        traverse(tpe.prefix)
+      }
+    }
+
+    // Define cache and populate it with known types at initialization time
+    protected var visited = new HashSet[Type]()
+
+    /** Clear the cache after every `traverse` invocation at the call-site. */
+    protected def reinitializeVisited(): Unit = visited.clear()
+
+    /**
+     * Traverse the type and its info to track all type dependencies.
+     *
+     * Note that tpe cannot be either `NoSymbol` or `null`.
+     * Check that you don't pass those types at the call-site.
+     */
+    override def traverse(tpe: Type): Unit = {
+      if ((tpe ne NoType) && !visited.contains(tpe)) {
+        visited.add(tpe)
+        tpe match {
+          case singleRef: SingleType =>
+            addTypeDependency(singleRef)
+
+          case typeRef: TypeRef =>
+            // Traverse materialized type arguments
+            typeRef.typeArguments.foreach(traverse)
+            addTypeDependency(typeRef)
+
+          case MethodType(_, _) =>
+            // Traverse the types of method parameters definitions
+            tpe.params.foreach(param => traverse(param.tpe))
+            // Traverse return type
+            traverse(tpe.resultType)
+
+          case PolyType(_, _) =>
+            // Traverse the symbols of poly types and their prefixes
+            tpe.typeParams.foreach { typeParam =>
+              addTypeSymbolDependency(typeParam)
+              val prefix = typeParam.info.prefix
+              if (!prefix.typeSymbolDirect.hasPackageFlag)
+                traverse(prefix)
+            }
+            // Traverse return type
+            traverse(tpe.resultType)
+
+          case TypeBounds(lo, hi) =>
+            // Ignore default types for lo and hi bounds
+            if (!(lo == definitions.NothingTpe)) traverse(lo)
+            if (!(hi == definitions.AnyTpe)) traverse(hi)
+
+          case RefinedType(parents, decls) =>
+            parents.foreach(traverse)
+            decls.iterator.foreach { decl =>
+              if (decl.isType) addTypeSymbolDependency(decl)
+              else addDependency(decl)
+            }
+
+          case ExistentialType(quantified, underlying) =>
+            quantified.foreach(quantified => traverse(quantified.tpe))
+            traverse(underlying)
+
+          case ThisType(_) | ConstantType(_) =>
+            traverse(tpe.underlying)
+
+          case _ =>
+            mapOver(tpe)
+            ()
+        }
+      }
+    }
+  }
+
+  /** Returns true if given tree contains macro attchment. In such case calls func on tree from attachment. */
+  def processMacroExpansion(in: Tree)(func: Tree => Unit): Boolean = {
+    import analyzer._ // this is where MEA lives in 2.11.x
+    // Hotspot
+    var seen = false
+    in.attachments.all.foreach {
+      case _ if seen =>
+      case macroAttachment: MacroExpansionAttachment =>
+        func(macroAttachment.expandee)
+        seen = true
+      case _ =>
+    }
+    seen
+  }
+
+  object MacroExpansionOf {
+    def unapply(tree: Tree): Option[Tree] = {
+      import analyzer._ // this is where MEA lives in 2.11.x
+      tree.attachments.all.collect {
+        case att: MacroExpansionAttachment => att.expandee
+      }.headOption
+    }
+  }
+
+  /** Return the enclosing class or the module class if it's a module. */
+  def enclOrModuleClass(s: Symbol): Symbol =
+    if (s.isModule) s.moduleClass else s.enclClass
+
+  /** Define common error messages for error reporting and assertions. */
+  object Feedback {
+    val OrphanTopLevelImports = noTopLevelMember("top level imports")
+    val OrphanNames = noTopLevelMember("names")
+
+    def noOriginFileForExternalSymbol(symbol: Symbol) =
+      s"The symbol $symbol comes from an unknown source or compiled source -- ignoring."
+    def expectedClassSymbol(culprit: Symbol): String =
+      s"The ${culprit.fullName} defined at ${culprit.fullLocationString} is not a class symbol."
+    def missingEnclosingClass(culprit: Symbol, owner: Symbol): String =
+      s"No enclosing class. Discarding dependency on $culprit (currentOwner = $owner)."
+    def noTopLevelMember(found: String) = s"""
+      |Found $found but no class, trait or object is defined in the compilation unit.
+      |The incremental compiler cannot record the dependency information in such case.
+      |Some errors like unused import referring to a non-existent class might not be reported.
+    """.stripMargin
+  }
+
+  final def isSyntheticCoreClass(sym: Symbol): Boolean = {
+    syntheticCoreClassSet.contains(sym)
+  }
+  private val syntheticCoreClassSet = definitions.syntheticCoreClasses.toSet[Symbol]
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleBridge.scala b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleBridge.scala
new file mode 100644
index 0000000000..7e033cf145
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleBridge.scala
@@ -0,0 +1,103 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.io.{ PrintWriter, StringWriter }
+import java.util.Optional
+
+import scala.tools.nsc.interpreter.IMain
+import scala.tools.nsc.{ GenericRunnerCommand, Settings }
+
+import xsbti.Logger
+
+import Compat._
+import InteractiveConsoleHelper._
+
+// See InteractiveConsoleBridgeFactory
+class InteractiveConsoleBridge(
+    args: Array[String],
+    bootClasspathString: String,
+    classpathString: String,
+    initialCommands: String,
+    cleanupCommands: String,
+    loader: Optional[ClassLoader],
+    bindNames: Array[String],
+    bindValues: Array[AnyRef],
+    log: Logger
+) extends xsbti.InteractiveConsoleInterface {
+
+  lazy val interpreterSettings: Settings = InteractiveMakeSettings.sync(args.toList, onError)
+
+  val useJavaCp = "-usejavacp" // we need rt.jar from JDK, so java classpath is required
+
+  val compilerSettings: Settings =
+    InteractiveMakeSettings.sync(args :+ useJavaCp, bootClasspathString, classpathString, onError)
+
+  val outWriter: StringWriter = new StringWriter
+  val poutWriter: PrintWriter = new PrintWriter(outWriter)
+
+  val interpreter: IMain =
+    new IMain(compilerSettings, replReporter(compilerSettings, new PrintWriter(outWriter)))
+
+  override def interpret(line: String, synthetic: Boolean): InteractiveConsoleResponse = {
+    clearBuffer()
+    val r = interpreter.interpret(line, synthetic)
+    InteractiveConsoleResponse(r, outWriter.toString)
+  }
+
+  def clearBuffer(): Unit = {
+    // errorWriter.getBuffer.setLength(0)
+    outWriter.getBuffer.setLength(0)
+  }
+
+  override def reset(): Unit = {
+    clearBuffer()
+    interpreter.reset()
+  }
+
+  override def close(): Unit = {
+    interpreter match {
+      case c: java.io.Closeable => c.close()
+      case _                    => ()
+    }
+  }
+
+  private def onError(str: String) = log error Message(str)
+}
+
+object InteractiveMakeSettings {
+  def apply(args: List[String], onError: String => Unit): Settings = {
+    val command = new GenericRunnerCommand(args, onError)
+    if (command.ok) command.settings
+    // TODO: Provide better exception
+    else throw new Exception(command.usageMsg)
+  }
+
+  def sync(
+      args: Array[String],
+      bootClasspathString: String,
+      classpathString: String,
+      onError: String => Unit
+  ): Settings = {
+    val compilerSettings = sync(args.toList, onError)
+    if (!bootClasspathString.isEmpty)
+      compilerSettings.bootclasspath.value = bootClasspathString
+    compilerSettings.classpath.value = classpathString
+    compilerSettings
+  }
+
+  def sync(options: List[String], onError: String => Unit): Settings = apply(options, onError)
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleFactoryBridge.scala b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleFactoryBridge.scala
new file mode 100644
index 0000000000..af5ee88bd3
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleFactoryBridge.scala
@@ -0,0 +1,44 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.util.Optional
+import xsbti.Logger
+
+class InteractiveConsoleBridgeFactory extends xsbti.InteractiveConsoleFactory {
+  def createConsole(
+      args: Array[String],
+      bootClasspathString: String,
+      classpathString: String,
+      initialCommands: String,
+      cleanupCommands: String,
+      loader: Optional[ClassLoader],
+      bindNames: Array[String],
+      bindValues: Array[AnyRef],
+      log: Logger
+  ): xsbti.InteractiveConsoleInterface =
+    new InteractiveConsoleBridge(
+      args,
+      bootClasspathString,
+      classpathString,
+      initialCommands,
+      cleanupCommands,
+      loader,
+      bindNames,
+      bindValues,
+      log
+    )
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleHelper.scala b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleHelper.scala
new file mode 100644
index 0000000000..159dc024c0
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleHelper.scala
@@ -0,0 +1,29 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import scala.language.implicitConversions
+import Compat._
+import xsbti.InteractiveConsoleResult
+
+object InteractiveConsoleHelper {
+  implicit def toConsoleResult(ir: Results.Result): InteractiveConsoleResult =
+    ir match {
+      case Results.Success    => InteractiveConsoleResult.Success
+      case Results.Incomplete => InteractiveConsoleResult.Incomplete
+      case Results.Error      => InteractiveConsoleResult.Error
+    }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleResponse.scala b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleResponse.scala
new file mode 100644
index 0000000000..bbb6288b01
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/InteractiveConsoleResponse.scala
@@ -0,0 +1,21 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import xsbti.InteractiveConsoleResult
+
+case class InteractiveConsoleResponse(result: InteractiveConsoleResult, output: String)
+    extends xsbti.InteractiveConsoleResponse
diff --git a/src/sbt-bridge/scala/tools/xsbt/JarUtils.scala b/src/sbt-bridge/scala/tools/xsbt/JarUtils.scala
new file mode 100644
index 0000000000..0a0253faf5
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/JarUtils.scala
@@ -0,0 +1,53 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.io.File
+import java.nio.file.Path
+
+/**
+ * This is a utility class that provides a set of functions that
+ * are used to implement straight to jar compilation.
+ *
+ * `sbt.internal.inc.JarUtils` is an object that has similar purpose and
+ * duplicates some of the code, as it is difficult to share it. Any change
+ * in the logic of this file must be applied to the other `JarUtils` too!
+ */
+final class JarUtils(outputDirs: Iterable[Path]) {
+  // This is an equivalent of asking if it runs on Windows where the separator is `\`
+  private val isSlashSeparator: Boolean = File.separatorChar == '/'
+
+  /**
+   * The jar file that is used as output for classes. If the output is
+   * not set to a single .jar file, value of this field is [[None]].
+   */
+  val outputJar: Option[Path] = {
+    outputDirs match {
+      case Seq(file) if file.toString.endsWith(".jar") => Some(file)
+      case _                                           => None
+    }
+  }
+
+  /**
+   * Creates an identifier for a class located inside a jar.
+   *
+   * It follows the format to encode inter-jar dependencies that
+   * is established in [[sbt.internal.inc.JarUtils.ClassInJar]].
+   */
+  def classNameInJar(jar: Path, classFilePath: String): String = {
+    s"$jar!${if (isSlashSeparator) classFilePath else classFilePath.replace('/', File.separatorChar)}"
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/JavaUtils.scala b/src/sbt-bridge/scala/tools/xsbt/JavaUtils.scala
new file mode 100644
index 0000000000..b71d126379
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/JavaUtils.scala
@@ -0,0 +1,39 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+private[xsbt] object JavaUtils {
+  implicit class JavaForEach[T](val iterable: java.lang.Iterable[T]) extends AnyVal {
+
+    @inline
+    def foreach[U](op: T => U): Unit = {
+      val iterator = iterable.iterator()
+      while (iterator.hasNext) op(iterator.next())
+    }
+  }
+
+  implicit class JavaMapForEach[K, V](val map: java.util.Map[K, V]) extends AnyVal {
+
+    @inline
+    def foreach[U](op: (K, V) => U): Unit = {
+      val iterator = map.keySet().iterator()
+      while (iterator.hasNext) {
+        val key = iterator.next()
+        op(key, map.get(key))
+      }
+    }
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/LocalToNonLocalClass.scala b/src/sbt-bridge/scala/tools/xsbt/LocalToNonLocalClass.scala
new file mode 100644
index 0000000000..a8a500703e
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/LocalToNonLocalClass.scala
@@ -0,0 +1,79 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import collection.mutable.Map
+
+/**
+ * A memoized lookup of an enclosing non local class.
+ *
+ * Let's consider an example of an owner chain:
+ *
+ *   pkg1 <- pkg2 <- class A <- object B <- class C <- def foo <- class Foo <- class Bar
+ *
+ * For an object, we work with its `moduleClass` so we can refer to everything as classes.
+ *
+ * Classes A, B, C are non local so they are mapped to themselves. Classes Foo and Bar are local because
+ * they are defined within method `foo`.
+ *
+ * Let's define non local class more precisely. A non local class is a class that is owned by either a package
+ * or another non local class. This gives rise to a recursive definition of a non local class that is used in the
+ * implementation of the mapping.
+ *
+ * Thanks to memoization, the amortized cost of a lookup is O(1). We amortize over lookups of all class symbols
+ * in the current compilation run.
+ *
+ * Additionally, you can query whether a given class is local. Check `isLocal`'s documentation.
+ */
+class LocalToNonLocalClass[G <: CallbackGlobal](val global: G) {
+  import global._
+  private val cache: Map[Symbol, Symbol] = perRunCaches.newMap()
+
+  def resolveNonLocal(s: Symbol): Symbol = {
+    assert(
+      phase.id <= sbtDependency.ownPhase.id,
+      s"Tried to resolve ${s.fullName} to a  non local classes but the resolution works up to sbtDependency phase. We're at ${phase.name}"
+    )
+    resolveCached(s)
+  }
+
+  /**
+   * Queries the cached information whether a class is a local class. If there's no cached information about
+   * the class None is returned.
+   *
+   * This method doesn't mutate the cache.
+   */
+  def isLocal(s: Symbol): Option[Boolean] = {
+    assert(s.isClass, s"The ${s.fullName} is not a class.")
+    cache.get(s).map(_ != s)
+  }
+
+  private def resolveCached(s: Symbol): Symbol = {
+    assert(s.isClass, s"The ${s.fullName} is not a class.")
+    cache.getOrElseUpdate(s, lookupNonLocal(s))
+  }
+
+  private def lookupNonLocal(s: Symbol): Symbol = {
+    if (s.owner.isPackageClass) s
+    else if (s.owner.isClass) {
+      val nonLocalForOwner = resolveCached(s.owner)
+      // the s is owned by a non local class so s is non local
+      if (nonLocalForOwner == s.owner) s
+      // otherwise the inner most non local class is the same as for its owner
+      else nonLocalForOwner
+    } else resolveCached(s.owner.enclClass)
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/LocateClassFile.scala b/src/sbt-bridge/scala/tools/xsbt/LocateClassFile.scala
new file mode 100644
index 0000000000..0edb4c4cd5
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/LocateClassFile.scala
@@ -0,0 +1,57 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import scala.reflect.io.NoAbstractFile
+import scala.tools.nsc.io.AbstractFile
+
+import java.io.File
+
+/**
+ * Contains utility methods for looking up class files corresponding to Symbols.
+ */
+abstract class LocateClassFile extends Compat with ClassName {
+  val global: CallbackGlobal
+  import global._
+
+  private[this] final val classSeparator = '.'
+  protected def classFile(sym: Symbol): Option[(AbstractFile, String)] =
+    // package can never have a corresponding class file; this test does not
+    // catch package objects (that do not have this flag set)
+    if (sym hasFlag scala.tools.nsc.symtab.Flags.PACKAGE) None
+    else {
+      val file = sym.associatedFile
+
+      if (file == NoAbstractFile) {
+        if (isTopLevelModule(sym)) {
+          val linked = sym.companionClass
+          if (linked == NoSymbol)
+            None
+          else
+            classFile(linked)
+        } else
+          None
+      } else {
+        Some((file, flatname(sym, classSeparator) + sym.moduleSuffix))
+      }
+    }
+
+  protected def fileForClass(outputDirectory: File, s: Symbol, separatorRequired: Boolean): File =
+    new File(outputDirectory, flatclassName(s, File.separatorChar, separatorRequired) + ".class")
+
+  protected def pathToClassFile(s: Symbol, separatorRequired: Boolean): String =
+    flatclassName(s, File.separatorChar, separatorRequired) + ".class"
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/Log.scala b/src/sbt-bridge/scala/tools/xsbt/Log.scala
new file mode 100644
index 0000000000..713849714c
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/Log.scala
@@ -0,0 +1,22 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+object Log {
+  def debug(log: xsbti.Logger, msg: => String) = log.debug(Message(msg))
+  def settingsError(log: xsbti.Logger): String => Unit =
+    s => log.error(Message(s))
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/Message.scala b/src/sbt-bridge/scala/tools/xsbt/Message.scala
new file mode 100644
index 0000000000..9b3a2088ea
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/Message.scala
@@ -0,0 +1,24 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.util.function.Supplier
+
+object Message {
+  def apply[T](s: => T): Supplier[T] = new Supplier[T] {
+    override def get(): T = s
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/ScaladocBridge.scala b/src/sbt-bridge/scala/tools/xsbt/ScaladocBridge.scala
new file mode 100644
index 0000000000..a17cd55b43
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/ScaladocBridge.scala
@@ -0,0 +1,87 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import xsbti.{ Logger, VirtualFile }
+import scala.reflect.io.AbstractFile
+import Log.debug
+import scala.tools.nsc.CompilerCommand
+
+class ScaladocBridge extends xsbti.compile.ScaladocInterface2 {
+  def run(sources: Array[VirtualFile], args: Array[String], log: Logger, delegate: xsbti.Reporter) =
+    (new Runner(sources, args, log, delegate)).run()
+}
+
+private class Runner(
+    sources: Array[VirtualFile],
+    args: Array[String],
+    log: Logger,
+    delegate: xsbti.Reporter
+) {
+  import scala.tools.nsc.{ doc, Global, reporters }
+  import reporters.Reporter
+  val docSettings: doc.Settings = new doc.Settings(Log.settingsError(log))
+  val fullArgs = args.toList ++ sources.map(_.toString)
+  val command = new CompilerCommand(fullArgs, docSettings)
+  val reporter = DelegatingReporter(docSettings, delegate)
+  def noErrors = !reporter.hasErrors && command.ok
+
+  def run(): Unit = {
+    debug(log, "Calling Scaladoc with arguments:\n\t" + fullArgs.mkString("\n\t"))
+    if (noErrors) {
+      import doc._ // 2.8 trunk and Beta1-RC4 have doc.DocFactory.  For other Scala versions, the next line creates forScope.DocFactory
+      val processor = new DocFactory(reporter, docSettings)
+      processor.document(command.files)
+    }
+    reporter.printSummary()
+    if (!noErrors)
+      throw new InterfaceCompileFailed(
+        args ++ sources.map(_.toString),
+        reporter.problems,
+        "Scaladoc generation failed"
+      )
+  }
+
+  object forScope {
+    class DocFactory(reporter: Reporter, docSettings: doc.Settings) {
+      object compiler extends Global(command.settings, reporter) {
+        // override def onlyPresentation = true
+        // override def forScaladoc = true
+
+        // 2.8 source compatibility
+        class DefaultDocDriver {
+          assert(false, "2.8 compatibility")
+          def process(units: Iterator[CompilationUnit]) = globalError("for 2.8 compatibility only")
+        }
+      }
+      def document(ignore: Seq[String]): Unit = {
+        import compiler._
+        val run = new Run
+        val wrappedFiles = sources.toList.map(AbstractZincFile(_))
+        val sortedSourceFiles: List[AbstractFile] =
+          wrappedFiles.sortWith(_.underlying.id < _.underlying.id)
+        run.compileFiles(sortedSourceFiles)
+        val generator = {
+          new DefaultDocDriver {
+            lazy val global: compiler.type = compiler
+            lazy val settings = docSettings
+          }
+        }
+        generator.process(run.units)
+      }
+    }
+  }
+}
diff --git a/src/sbt-bridge/scala/tools/xsbt/ZincCompat.scala b/src/sbt-bridge/scala/tools/xsbt/ZincCompat.scala
new file mode 100644
index 0000000000..625e79256f
--- /dev/null
+++ b/src/sbt-bridge/scala/tools/xsbt/ZincCompat.scala
@@ -0,0 +1,27 @@
+/*
+ * Zinc - The incremental compiler for Scala.
+ * Copyright Scala Center, Lightbend, and Mark Harrah
+ *
+ * Scala (https://www.scala-lang.org)
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.tools
+package xsbt
+
+import java.nio.file.Path
+
+import scala.reflect.io.AbstractFile
+
+object ZincCompat {
+  type PlainNioFile = scala.reflect.io.PlainNioFile
+
+  def plainNioFile(path: Path): AbstractFile = new PlainNioFile(path)
+  def unwrapPlainNioFile(pf: PlainNioFile): Path = pf.nioPath
+}
diff --git a/src/scaladoc/scala/tools/nsc/doc/base/CommentFactoryBase.scala b/src/scaladoc/scala/tools/nsc/doc/base/CommentFactoryBase.scala
index 09a1b7db98..2c2c689bfa 100644
--- a/src/scaladoc/scala/tools/nsc/doc/base/CommentFactoryBase.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/base/CommentFactoryBase.scala
@@ -16,10 +16,10 @@ package base
 
 import base.comment._
 import scala.annotation.{nowarn, tailrec}
-import scala.collection._
-import scala.util.matching.Regex
+import scala.collection.mutable, mutable.ListBuffer
 import scala.reflect.internal.util.Position
 import scala.tools.nsc.Reporting.WarningCategory
+import scala.util.matching.Regex.{quoteReplacement, Match}
 
 /** The comment parser transforms raw comment strings into `Comment` objects.
   * Call `parse` to run the parser. Note that the parser is stateless and
@@ -121,16 +121,16 @@ trait CommentFactoryBase { this: MemberLookupBase =>
   /** The body of a line, dropping the (optional) start star-marker,
     * one leading whitespace and all trailing whitespace. */
   private val CleanCommentLine =
-    new Regex("""(?:\s*\*\s?)?(.*)""")
+    raw"(?:\s*\*\s?)?(.*)".r
 
   /** Dangerous HTML tags that should be replaced by something safer,
     * such as wiki syntax, or that should be dropped. */
   private val DangerousTags =
-    new Regex("""<(/?(div|ol|ul|li|h[1-6]|p))( [^>]*)?/?>|<!--.*-->""")
+    raw"<(/?(div|ol|ul|li|h[1-6]|p))( [^>]*)?/?>|<!--.*-->".r
 
   /** Maps a dangerous HTML tag to a safe wiki replacement, or an empty string
     * if it cannot be salvaged. */
-  private def htmlReplacement(mtch: Regex.Match): String = mtch.group(1) match {
+  private def htmlReplacement(mtch: Match): String = mtch.group(1) match {
     case "p" | "div" => "\n\n"
     case "h1"  => "\n= "
     case "/h1" => " =\n"
@@ -147,10 +147,10 @@ trait CommentFactoryBase { this: MemberLookupBase =>
   /** Javadoc tags that should be replaced by something useful, such as wiki
     * syntax, or that should be dropped. */
   private val JavadocTags =
-    new Regex("""\{\@(code|docRoot|linkplain|link|literal|value)\p{Zs}*([^}]*)\}""")
+    raw"\{\@(code|docRoot|linkplain|link|literal|value)\p{Zs}*([^}]*)\}".r
 
   /** Maps a javadoc tag to a useful wiki replacement, or an empty string if it cannot be salvaged. */
-  private def javadocReplacement(mtch: Regex.Match): String = {
+  private def javadocReplacement(mtch: Match): String = {
     mtch.group(1) match {
       case "code" => "<code>" + mtch.group(2) + "</code>"
       case "docRoot"  => ""
@@ -164,30 +164,30 @@ trait CommentFactoryBase { this: MemberLookupBase =>
 
   /** Safe HTML tags that can be kept. */
   private val SafeTags =
-    new Regex("""((&\w+;)|(&#\d+;)|(</?(abbr|acronym|address|area|a|bdo|big|blockquote|br|button|b|caption|cite|code|col|colgroup|dd|del|dfn|em|fieldset|form|hr|img|input|ins|i|kbd|label|legend|link|map|object|optgroup|option|param|pre|q|samp|select|small|span|strong|sub|sup|table|tbody|td|textarea|tfoot|th|thead|tr|tt|var)( [^>]*)?/?>))""")
+    raw"((&\w+;)|(&#\d+;)|(</?(abbr|acronym|address|area|a|bdo|big|blockquote|br|button|b|caption|cite|code|col|colgroup|dd|del|dfn|em|fieldset|form|hr|img|input|ins|i|kbd|label|legend|link|map|object|optgroup|option|param|pre|q|samp|select|small|span|strong|sub|sup|table|tbody|td|textarea|tfoot|th|thead|tr|tt|var)( [^>]*)?/?>))".r
 
   private val safeTagMarker = '\u000E'  // control-N
 
   /** A Scaladoc tag not linked to a symbol and not followed by text */
   private val SingleTagRegex =
-    new Regex("""\s*@(\S+)\s*""")
+    raw"\s*@(\S+)\s*".r
 
   /** A Scaladoc tag not linked to a symbol. Returns the name of the tag, and the rest of the line. */
   private val SimpleTagRegex =
-    new Regex("""\s*@(\S+)\s+(.*)""")
+    raw"\s*@(\S+)\s+(.*)".r
 
   /** A Scaladoc tag linked to a symbol. Returns the name of the tag, the name
     * of the symbol, and the rest of the line. */
   private val SymbolTagRegex =
-    new Regex("""\s*@(param|tparam|throws|groupdesc|groupname|groupprio)\s+(\S*)\s*(.*)""")
+    raw"\s*@(param|tparam|throws|groupdesc|groupname|groupprio)\s+(\S*)\s*(.*)".r
 
   /** The start of a Scaladoc code block */
   private val CodeBlockStartRegex =
-    new Regex(s"""(.*?)((?:\\{\\{\\{)|(?:$safeTagMarker<pre(?: [^>]*)?>$safeTagMarker))(.*)""")
+    raw"(.*?)((?:\{\{\{)|(?:$safeTagMarker<pre(?: [^>]*)?>$safeTagMarker))(.*)".r
 
   /** The end of a Scaladoc code block */
   private val CodeBlockEndRegex =
-    new Regex(s"""(.*?)((?:\\}\\}\\})|(?:$safeTagMarker</pre>$safeTagMarker))(.*)""")
+    raw"(.*?)((?:\}\}\})|(?:$safeTagMarker</pre>$safeTagMarker))(.*)".r
 
   /** A key used for a tag map. The key is built from the name of the tag and
     * from the linked symbol if the tag has one.
@@ -221,7 +221,7 @@ trait CommentFactoryBase { this: MemberLookupBase =>
       val javadoclessComment = JavadocTags.replaceAllIn(safeComment, { javadocReplacement(_) })
       val markedTagComment =
         SafeTags.replaceAllIn(javadoclessComment, { mtch =>
-          java.util.regex.Matcher.quoteReplacement(s"$safeTagMarker${mtch.matched}$safeTagMarker")
+          quoteReplacement(s"$safeTagMarker${mtch.matched}$safeTagMarker")
         })
       markedTagComment.linesIterator.toList map cleanLine
     }
@@ -239,7 +239,7 @@ trait CommentFactoryBase { this: MemberLookupBase =>
       * @param inCodeBlock Whether the next line is part of a code block (in which no tags must be read). */
     def parse0 (
       docBody: StringBuilder,
-      tags: immutable.Map[TagKey, List[String]],
+      tags: Map[TagKey, List[String]],
       lastTagKey: Option[TagKey],
       remaining: List[String],
       inCodeBlock: Boolean
@@ -414,7 +414,7 @@ trait CommentFactoryBase { this: MemberLookupBase =>
         com
     }
 
-    parse0(new StringBuilder(comment.length), immutable.Map.empty, None, clean(comment), inCodeBlock = false)
+    parse0(new StringBuilder(comment.length), Map.empty, None, clean(comment), inCodeBlock = false)
 
   }
 
@@ -503,14 +503,14 @@ trait CommentFactoryBase { this: MemberLookupBase =>
       /** Consumes all list item blocks (possibly with nested lists) of the
         * same list and returns the list block. */
       def listLevel(indent: Int, style: String): Block = {
-        val lines = mutable.ListBuffer.empty[Block]
+        val lines = ListBuffer.empty[Block]
         var line: Option[Block] = listLine(indent, style)
         while (line.isDefined) {
           lines += line.get
           line = listLine(indent, style)
         }
         val constructor = listStyles(style)
-        constructor(lines)
+        constructor(lines.toList)
       }
 
       val indent = countWhitespace
diff --git a/src/scaladoc/scala/tools/nsc/doc/base/comment/Body.scala b/src/scaladoc/scala/tools/nsc/doc/base/comment/Body.scala
index 8cc691b7cb..5a4384812e 100644
--- a/src/scaladoc/scala/tools/nsc/doc/base/comment/Body.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/base/comment/Body.scala
@@ -15,7 +15,7 @@ package doc
 package base
 package comment
 
-import scala.collection._
+import scala.collection.immutable.SortedMap
 
 /** A body of text. A comment has a single body, which is composed of
   * at least one block. Inside every body is exactly one summary.
diff --git a/src/scaladoc/scala/tools/nsc/doc/base/comment/Comment.scala b/src/scaladoc/scala/tools/nsc/doc/base/comment/Comment.scala
index 9e8e3a77de..657a8b67a6 100644
--- a/src/scaladoc/scala/tools/nsc/doc/base/comment/Comment.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/base/comment/Comment.scala
@@ -15,7 +15,7 @@ package doc
 package base
 package comment
 
-import scala.collection._
+import scala.collection.mutable.ListBuffer
 
 /** A Scaladoc comment and all its tags.
   *
@@ -29,7 +29,7 @@ abstract class Comment {
   def body: Body
 
   private def closeHtmlTags(inline: Inline): Inline = {
-    val stack = mutable.ListBuffer.empty[HtmlTag]
+    val stack = ListBuffer.empty[HtmlTag]
     def scan(i: Inline): Unit = {
       i match {
         case Chain(list) =>
diff --git a/src/scaladoc/scala/tools/nsc/doc/doclet/Generator.scala b/src/scaladoc/scala/tools/nsc/doc/doclet/Generator.scala
index 566abe1de7..3e920268cd 100644
--- a/src/scaladoc/scala/tools/nsc/doc/doclet/Generator.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/doclet/Generator.scala
@@ -13,7 +13,7 @@
 package scala.tools.nsc.doc
 package doclet
 
-import scala.collection._
+import scala.collection.mutable
 
 /** Custom Scaladoc generators must implement the `Generator` class. A custom generator can be selected in Scaladoc
   * using the `-doc-generator` command line option.
diff --git a/src/scaladoc/scala/tools/nsc/doc/html/HtmlFactory.scala b/src/scaladoc/scala/tools/nsc/doc/html/HtmlFactory.scala
index 46f6f8dd9b..b9d64ee392 100644
--- a/src/scaladoc/scala/tools/nsc/doc/html/HtmlFactory.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/html/HtmlFactory.scala
@@ -17,7 +17,7 @@ package html
 import model._
 import java.io.{ File => JFile }
 import io.{ Streamable, Directory }
-import scala.collection._
+import scala.collection.mutable
 import page.diagram._
 import scala.reflect.internal.Reporter
 
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/CommentFactory.scala b/src/scaladoc/scala/tools/nsc/doc/model/CommentFactory.scala
index 9e7b69c977..94f9afd42f 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/CommentFactory.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/CommentFactory.scala
@@ -16,7 +16,7 @@ package model
 
 import base.comment._
 
-import scala.collection._
+import scala.collection.mutable
 import scala.reflect.internal.util.Position
 
 /** The comment parser transforms raw comment strings into `Comment` objects.
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/Entity.scala b/src/scaladoc/scala/tools/nsc/doc/model/Entity.scala
index f0beddf01f..6bc2b15a5e 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/Entity.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/Entity.scala
@@ -14,7 +14,6 @@ package scala.tools.nsc
 package doc
 package model
 
-import scala.collection._
 import base.comment._
 import diagram._
 
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/ModelFactory.scala b/src/scaladoc/scala/tools/nsc/doc/model/ModelFactory.scala
index 7f44270a71..7f999113c8 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/ModelFactory.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/ModelFactory.scala
@@ -18,13 +18,16 @@ package model
 import base.comment._
 import diagram._
 
-import scala.collection._
-import scala.util.matching.Regex
+import java.net.URI
+import java.nio.file.Paths
+
+import scala.collection.mutable, mutable.ListBuffer
+import scala.reflect.io._
 import scala.reflect.macros.internal.macroImpl
-import symtab.Flags
+import scala.util.matching.Regex.quoteReplacement
 
-import io._
-import model.{ RootPackage => RootPackageEntity }
+import model.{RootPackage => RootPackageEntity}
+import symtab.Flags
 
 /** This trait extracts all required information for documentation from compilation units */
 class ModelFactory(val global: Global, val settings: doc.Settings) {
@@ -156,7 +159,7 @@ class ModelFactory(val global: Global, val settings: doc.Settings) {
       }
     }
     def flags = {
-      val fgs = mutable.ListBuffer.empty[Paragraph]
+      val fgs = ListBuffer.empty[Paragraph]
       if (sym.isImplicit) fgs += Paragraph(Text("implicit"))
       if (sym.isSealed) fgs += Paragraph(Text("sealed"))
       if (!sym.isTrait && (sym hasFlag Flags.ABSTRACT)) fgs += Paragraph(Text("abstract"))
@@ -312,26 +315,31 @@ class ModelFactory(val global: Global, val settings: doc.Settings) {
     }
 
     def sourceUrl = {
-      def fixPath(s: String) = s.replaceAll("\\" + java.io.File.separator, "/")
-      val assumedSourceRoot  = fixPath(settings.sourcepath.value) stripSuffix "/"
 
       if (!settings.docsourceurl.isDefault)
-        inSource map { case (file, line) =>
-          val filePathExt = fixPath(file.path).replaceFirst("^" + assumedSourceRoot, "")
-          val (filePath, fileExt) = filePathExt.splitAt(filePathExt.indexOf(".", filePathExt.lastIndexOf("/")))
+        inSource.map { case (file, line) =>
+          // file path is relative to source root (-sourcepath)
+          val src = Paths.get(settings.sourcepath.value).toUri
+          val path = file.file.toPath.toUri
+          val filePathExt = src.relativize(path)
+          val rawPath: String = filePathExt.getRawPath
+          val (filePath, fileExt) =
+            rawPath.lastIndexOf('.') match {
+              case -1 => (rawPath, "")
+              case i  => rawPath.splitAt(i)
+            }
           val tplOwner = this.inTemplate.qualifiedName
           val tplName = this.name
-          val patches = new Regex("""€\{(FILE_PATH|FILE_EXT|FILE_PATH_EXT|FILE_LINE|TPL_OWNER|TPL_NAME)\}""")
           def substitute(name: String): String = name match {
-            case "FILE_PATH" => filePath
-            case "FILE_EXT" => fileExt
-            case "FILE_PATH_EXT" => filePathExt
-            case "FILE_LINE" => line.toString
-            case "TPL_OWNER" => tplOwner
-            case "TPL_NAME" => tplName
+            case FILE_PATH     => filePath
+            case FILE_EXT      => fileExt
+            case FILE_PATH_EXT => filePathExt.toString
+            case FILE_LINE     => line.toString
+            case TPL_OWNER     => tplOwner
+            case TPL_NAME      => tplName
           }
-          val patchedString = patches.replaceAllIn(settings.docsourceurl.value, m => java.util.regex.Matcher.quoteReplacement(substitute(m.group(1))) )
-          new java.net.URI(patchedString).toURL
+          val patchedString = tokens.replaceAllIn(settings.docsourceurl.value, m => quoteReplacement(substitute(m.group(1))) )
+          new URI(patchedString).toURL
         }
       else None
     }
@@ -343,7 +351,7 @@ class ModelFactory(val global: Global, val settings: doc.Settings) {
     /* Subclass cache */
     private lazy val subClassesCache = (
       if (sym == AnyRefClass || sym == AnyClass) null
-      else mutable.ListBuffer[DocTemplateEntity]()
+      else ListBuffer[DocTemplateEntity]()
     )
     def registerSubClass(sc: DocTemplateEntity): Unit = {
       if (subClassesCache != null)
@@ -352,10 +360,10 @@ class ModelFactory(val global: Global, val settings: doc.Settings) {
     def directSubClasses = if (subClassesCache == null) Nil else subClassesCache.toList
 
     /* Implicitly convertible class cache */
-    private var implicitlyConvertibleClassesCache: mutable.ListBuffer[(DocTemplateImpl, ImplicitConversionImpl)] = null
+    private var implicitlyConvertibleClassesCache: ListBuffer[(DocTemplateImpl, ImplicitConversionImpl)] = null
     def registerImplicitlyConvertibleClass(dtpl: DocTemplateImpl, conv: ImplicitConversionImpl): Unit = {
       if (implicitlyConvertibleClassesCache == null)
-        implicitlyConvertibleClassesCache = mutable.ListBuffer[(DocTemplateImpl, ImplicitConversionImpl)]()
+        implicitlyConvertibleClassesCache = ListBuffer[(DocTemplateImpl, ImplicitConversionImpl)]()
       implicitlyConvertibleClassesCache += ((dtpl, conv))
     }
 
@@ -1052,4 +1060,12 @@ object ModelFactory {
   val defaultGroupName = "Ungrouped"
   val defaultGroupDesc = None
   val defaultGroupPriority = 1000
+
+  val tokens = raw"€\{($FILE_PATH|$FILE_EXT|$FILE_PATH_EXT|$FILE_LINE|$TPL_OWNER|$TPL_NAME)\}".r
+  final val FILE_PATH     = "FILE_PATH"
+  final val FILE_EXT      = "FILE_EXT"
+  final val FILE_PATH_EXT = "FILE_PATH_EXT"
+  final val FILE_LINE     = "FILE_LINE"
+  final val TPL_OWNER     = "TPL_OWNER"
+  final val TPL_NAME      = "TPL_NAME"
 }
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala b/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala
index 32db85828b..b39d0ffcd8 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala
@@ -15,7 +15,6 @@ package doc
 package model
 
 import scala.annotation.nowarn
-import scala.collection._
 import scala.tools.nsc.Reporting.WarningCategory
 
 /**
@@ -440,7 +439,7 @@ trait ModelFactoryImplicitSupport {
                          inTpl: DocTemplateImpl): Map[MemberEntity, ImplicitMemberShadowing] = {
     assert(modelFinished, "cannot make shadowing table before model is finished")
 
-    val shadowingTable = mutable.Map[MemberEntity, ImplicitMemberShadowing]()
+    val shadowingTable = Map.newBuilder[MemberEntity, ImplicitMemberShadowing]
     val membersByName: Map[Name, List[MemberImpl]] = members.groupBy(_.sym.name)
     val convsByMember = convs.foldLeft(Map.empty[MemberImpl, ImplicitConversionImpl]){
       case (map, conv) => map ++ conv.memberImpls.map (_ -> conv)
@@ -471,12 +470,12 @@ trait ModelFactoryImplicitSupport {
             def ambiguatingMembers: List[MemberEntity] = ambiguous
           }
 
-          shadowingTable += (member -> shadowing)
+          shadowingTable.addOne(member -> shadowing)
         }
       }
     }
 
-    shadowingTable.toMap
+    shadowingTable.result()
   }
 
 
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryTypeSupport.scala b/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryTypeSupport.scala
index 040b62344e..5354fb4d17 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryTypeSupport.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/ModelFactoryTypeSupport.scala
@@ -17,7 +17,7 @@ package model
 import base._
 import diagram._
 import scala.annotation.nowarn
-import scala.collection._
+import scala.collection.{immutable, mutable}
 
 /** This trait extracts all required information for documentation from compilation units */
 trait ModelFactoryTypeSupport {
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/TreeEntity.scala b/src/scaladoc/scala/tools/nsc/doc/model/TreeEntity.scala
index 6fc2efe685..843dc2916d 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/TreeEntity.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/TreeEntity.scala
@@ -14,8 +14,7 @@ package scala.tools.nsc
 package doc
 package model
 
-import scala.collection._
-
+import scala.collection.immutable.SortedMap
 
 /** A fragment of code. */
 abstract class TreeEntity {
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/TreeFactory.scala b/src/scaladoc/scala/tools/nsc/doc/model/TreeFactory.scala
index 5f12113ab4..491f3fc3c0 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/TreeFactory.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/TreeFactory.scala
@@ -14,7 +14,7 @@ package scala.tools.nsc
 package doc
 package model
 
-import scala.collection._
+import scala.collection.immutable
 import scala.reflect.internal.util.{RangePosition, SourceFile}
 
 /** The goal of this trait is, using makeTree,
diff --git a/src/scaladoc/scala/tools/nsc/doc/model/TypeEntity.scala b/src/scaladoc/scala/tools/nsc/doc/model/TypeEntity.scala
index 4973426174..b640c24a4e 100644
--- a/src/scaladoc/scala/tools/nsc/doc/model/TypeEntity.scala
+++ b/src/scaladoc/scala/tools/nsc/doc/model/TypeEntity.scala
@@ -14,7 +14,7 @@ package scala.tools.nsc
 package doc
 package model
 
-import scala.collection._
+import scala.collection.immutable.SortedMap
 
 /** A type. Note that types and templates contain the same information only for the simplest types. For example, a type
   * defines how a template's type parameters are instantiated (as in `List[Cow]`), what the template's prefix is
diff --git a/src/testkit/scala/tools/testkit/ReflectUtil.scala b/src/testkit/scala/tools/testkit/ReflectUtil.scala
index 710e02141c..6a4f10c0cb 100644
--- a/src/testkit/scala/tools/testkit/ReflectUtil.scala
+++ b/src/testkit/scala/tools/testkit/ReflectUtil.scala
@@ -42,6 +42,14 @@ object ReflectUtil {
           f.setAccessible(true)
       }
 
+  def getFinalFieldAccessible[T: ClassTag](n: String): Field =
+    classTag[T]
+      .runtimeClass.getDeclaredField(n)
+      .tap { f =>
+        if ((f.getModifiers & Modifier.PUBLIC) == 0)
+          f.setAccessible(true)
+      }
+
   // finds method with exact name or name$suffix but not name$default$suffix
   def getMethodAccessible[A: ClassTag](name: String): Method =
     implicitly[ClassTag[A]]
diff --git a/test/files/jvm/interpreter.check b/test/files/jvm/interpreter.check
index 2e9430f729..a85c3530b4 100644
--- a/test/files/jvm/interpreter.check
+++ b/test/files/jvm/interpreter.check
@@ -88,7 +88,7 @@ class Bar
 
 scala> implicit def foo2bar(foo: Foo) = Bar(foo.n)
                     ^
-       warning: Implicit definition should have explicit type (inferred Bar)
+       warning: Implicit definition should have explicit type (inferred Bar) [quickfixable]
 warning: 1 feature warning; for details, enable `:setting -feature` or `:replay -feature`
 def foo2bar(foo: Foo): Bar
 
diff --git a/test/files/neg/auto-application.check b/test/files/neg/auto-application.check
index e059e417f1..c3e670f829 100644
--- a/test/files/neg/auto-application.check
+++ b/test/files/neg/auto-application.check
@@ -9,7 +9,7 @@ auto-application.scala:6: error: Int does not take parameters
                  ^
 auto-application.scala:9: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method meth,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   meth // warn, auto-application (of nilary methods) is deprecated
   ^
 1 warning
diff --git a/test/files/neg/checksensible.check b/test/files/neg/checksensible.check
index 6ffe561826..1de2afd494 100644
--- a/test/files/neg/checksensible.check
+++ b/test/files/neg/checksensible.check
@@ -1,4 +1,4 @@
-checksensible.scala:54: warning: symbol literal is deprecated; use Symbol("sym") instead
+checksensible.scala:54: warning: symbol literal is deprecated; use Symbol("sym") instead [quickfixable]
   (1 != 'sym)
         ^
 checksensible.scala:15: warning: comparing a fresh object using `eq` will always yield false
diff --git a/test/files/neg/deprecated-annots.check b/test/files/neg/deprecated-annots.check
new file mode 100644
index 0000000000..b85c663b19
--- /dev/null
+++ b/test/files/neg/deprecated-annots.check
@@ -0,0 +1,6 @@
+deprecated-annots.scala:9: error: @scala.annotation.elidable is ignored in Scala 3
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=D
+  @annotation.elidable(42)
+   ^
+1 error
diff --git a/test/files/neg/deprecated-annots.scala b/test/files/neg/deprecated-annots.scala
new file mode 100644
index 0000000000..609a02ffc3
--- /dev/null
+++ b/test/files/neg/deprecated-annots.scala
@@ -0,0 +1,11 @@
+
+// scalac: -Werror -Xlint -Xsource:3
+
+class C[@specialized A]
+
+class D {
+  def f[@specialized A](a: A): A = a
+
+  @annotation.elidable(42)
+  def g() = println("hello, world")
+}
diff --git a/test/files/neg/deprecated_widening.check b/test/files/neg/deprecated_widening.check
index 8161bd5f7d..48c3c6ed68 100644
--- a/test/files/neg/deprecated_widening.check
+++ b/test/files/neg/deprecated_widening.check
@@ -1,55 +1,55 @@
-deprecated_widening.scala:5: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:5: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
     val i_f: Float = i  // deprecated
                      ^
-deprecated_widening.scala:7: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:7: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
     val l_f: Float = l  // deprecated
                      ^
-deprecated_widening.scala:8: warning: Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead.
+deprecated_widening.scala:8: warning: Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead. [quickfixable]
     val l_d: Double = l // deprecated
                       ^
-deprecated_widening.scala:23: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:23: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   val truncatedPosFloat:Float = 16777217L  // deprecated
                                 ^
-deprecated_widening.scala:26: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:26: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   val truncatedNegFloat: Float = - 16777217L // deprecated
                                  ^
-deprecated_widening.scala:30: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:30: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   val truncatedPosFloatI:Float = 16777217  // deprecated
                                  ^
-deprecated_widening.scala:33: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:33: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   val truncatedNegFloatI: Float = - 16777217 // deprecated
                                   ^
-deprecated_widening.scala:37: warning: Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead.
+deprecated_widening.scala:37: warning: Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead. [quickfixable]
   val truncatedPosDouble:Double = 18014398509481985L // deprecated
                                   ^
-deprecated_widening.scala:40: warning: Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead.
+deprecated_widening.scala:40: warning: Widening conversion from Long to Double is deprecated because it loses precision. Write `.toDouble` instead. [quickfixable]
   val truncatedNegDouble: Double = - 18014398509481985L // deprecated
                                    ^
-deprecated_widening.scala:47: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:47: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def literals  = Set[Float](0x7fffffc0, 0x7ffffffd, 0x7ffffffe, 0x7fffffff)
                              ^
-deprecated_widening.scala:47: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:47: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def literals  = Set[Float](0x7fffffc0, 0x7ffffffd, 0x7ffffffe, 0x7fffffff)
                                          ^
-deprecated_widening.scala:47: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:47: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def literals  = Set[Float](0x7fffffc0, 0x7ffffffd, 0x7ffffffe, 0x7fffffff)
                                                      ^
-deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def longingly = Set[Float](0x7fffffc0L, 0x7ffffffdL, 0x7ffffffeL, 0x7fffffffL)
                              ^
-deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def longingly = Set[Float](0x7fffffc0L, 0x7ffffffdL, 0x7ffffffeL, 0x7fffffffL)
                                           ^
-deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def longingly = Set[Float](0x7fffffc0L, 0x7ffffffdL, 0x7ffffffeL, 0x7fffffffL)
                                                        ^
-deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:48: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def longingly = Set[Float](0x7fffffc0L, 0x7ffffffdL, 0x7ffffffeL, 0x7fffffffL)
                                                                     ^
-deprecated_widening.scala:50: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:50: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def `pick one` = Set[Float](0x1000003, 0x1000004, 0x1000005)
                               ^
-deprecated_widening.scala:50: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+deprecated_widening.scala:50: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   def `pick one` = Set[Float](0x1000003, 0x1000004, 0x1000005)
                                                     ^
 deprecated_widening.scala:12: warning: method int2float in object Int is deprecated (since 2.13.1): Implicit conversion from Int to Float is dangerous because it loses precision. Write `.toFloat` instead.
diff --git a/test/files/neg/dotless-targs-a.check b/test/files/neg/dotless-targs-a.check
index 96f95e7d08..6fa4bd3214 100644
--- a/test/files/neg/dotless-targs-a.check
+++ b/test/files/neg/dotless-targs-a.check
@@ -1,14 +1,14 @@
-dotless-targs-a.scala:4: error: type application is not allowed for infix operators
+dotless-targs-a.scala:4: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def fn2 = List apply[Int] 2
                  ^
-dotless-targs-a.scala:9: error: type application is not allowed for infix operators
+dotless-targs-a.scala:9: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def h1 = List apply[List[Int]] (List(1), List(2)) mapConserve[List[Any]] (x => x)
                 ^
-dotless-targs-a.scala:9: error: type application is not allowed for infix operators
+dotless-targs-a.scala:9: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def h1 = List apply[List[Int]] (List(1), List(2)) mapConserve[List[Any]] (x => x)
diff --git a/test/files/neg/dotless-targs-b.check b/test/files/neg/dotless-targs-b.check
index 4c97fce3ea..ca61b350cb 100644
--- a/test/files/neg/dotless-targs-b.check
+++ b/test/files/neg/dotless-targs-b.check
@@ -1,14 +1,14 @@
-dotless-targs-b.scala:4: error: type application is not allowed for infix operators
+dotless-targs-b.scala:4: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def fn2 = List apply[Int] 2
                  ^
-dotless-targs-b.scala:9: error: type application is not allowed for infix operators
+dotless-targs-b.scala:9: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def h1 = List apply[List[Int]] (List(1), List(2)) mapConserve[List[Any]] (x => x)
                 ^
-dotless-targs-b.scala:9: error: type application is not allowed for infix operators
+dotless-targs-b.scala:9: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def h1 = List apply[List[Int]] (List(1), List(2)) mapConserve[List[Any]] (x => x)
diff --git a/test/files/neg/dotless-targs-ranged-a.check b/test/files/neg/dotless-targs-ranged-a.check
index 496b2cfe8e..6620d7438e 100644
--- a/test/files/neg/dotless-targs-ranged-a.check
+++ b/test/files/neg/dotless-targs-ranged-a.check
@@ -1,16 +1,16 @@
-dotless-targs-ranged-a.scala:4: warning: type application is not allowed for infix operators
+dotless-targs-ranged-a.scala:4: warning: type application is not allowed for infix operators [quickfixable]
   def fn2 = List apply[Int] 2
                  ^
-dotless-targs-ranged-a.scala:9: warning: type application is not allowed for infix operators
+dotless-targs-ranged-a.scala:9: warning: type application is not allowed for infix operators [quickfixable]
   def h1 = List apply[List[Int]] (List(1), List(2)) mapConserve[List[Any]] (x => x)
                 ^
-dotless-targs-ranged-a.scala:9: warning: type application is not allowed for infix operators
+dotless-targs-ranged-a.scala:9: warning: type application is not allowed for infix operators [quickfixable]
   def h1 = List apply[List[Int]] (List(1), List(2)) mapConserve[List[Any]] (x => x)
                                                     ^
-dotless-targs-ranged-a.scala:13: warning: type application is not allowed for infix operators
+dotless-targs-ranged-a.scala:13: warning: type application is not allowed for infix operators [quickfixable]
   def eval = 1 ->[Int] 2
                ^
-dotless-targs-ranged-a.scala:14: warning: type application is not allowed for infix operators
+dotless-targs-ranged-a.scala:14: warning: type application is not allowed for infix operators [quickfixable]
   def evil = new A() op  [Int,   String     ]  42
                      ^
 dotless-targs-ranged-a.scala:9: warning: multiarg infix syntax looks like a tuple and will be deprecated
diff --git a/test/files/neg/for-comprehension-old.check b/test/files/neg/for-comprehension-old.check
index 3d8b1d2094..30a6878d21 100644
--- a/test/files/neg/for-comprehension-old.check
+++ b/test/files/neg/for-comprehension-old.check
@@ -1,25 +1,25 @@
-for-comprehension-old.scala:6: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-old.scala:6: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (val x <- 1 to 5 ; y = x) yield x+y       // fail
              ^
-for-comprehension-old.scala:7: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-old.scala:7: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (val x <- 1 to 5 ; val y = x) yield x+y   // fail
              ^
-for-comprehension-old.scala:11: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-old.scala:11: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (z <- 1 to 2 ; val x <- 1 to 5 ; y = x) yield x+y       // fail
                            ^
-for-comprehension-old.scala:12: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-old.scala:12: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (z <- 1 to 2 ; val x <- 1 to 5 ; val y = x) yield x+y   // fail
                            ^
-for-comprehension-old.scala:5: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val`
+for-comprehension-old.scala:5: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val` [quickfixable]
   for (x <- 1 to 5 ; val y = x) yield x+y       // fail
                            ^
-for-comprehension-old.scala:7: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val`
+for-comprehension-old.scala:7: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val` [quickfixable]
   for (val x <- 1 to 5 ; val y = x) yield x+y   // fail
                                ^
-for-comprehension-old.scala:10: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val`
+for-comprehension-old.scala:10: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val` [quickfixable]
   for (z <- 1 to 2 ; x <- 1 to 5 ; val y = x) yield x+y       // fail
                                          ^
-for-comprehension-old.scala:12: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val`
+for-comprehension-old.scala:12: warning: `val` keyword in for comprehension is deprecated: instead, bind the value without `val` [quickfixable]
   for (z <- 1 to 2 ; val x <- 1 to 5 ; val y = x) yield x+y   // fail
                                              ^
 4 warnings
diff --git a/test/files/neg/for-comprehension-val.check b/test/files/neg/for-comprehension-val.check
index d0c1e455ff..463efbba96 100644
--- a/test/files/neg/for-comprehension-val.check
+++ b/test/files/neg/for-comprehension-val.check
@@ -1,31 +1,31 @@
-for-comprehension-val.scala:6: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-val.scala:6: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (val x <- 1 to 5 ; y = x) yield x+y       // fail
              ^
-for-comprehension-val.scala:7: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-val.scala:7: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (val x <- 1 to 5 ; val y = x) yield x+y   // fail
              ^
-for-comprehension-val.scala:11: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-val.scala:11: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (z <- 1 to 2 ; val x <- 1 to 5 ; y = x) yield x+y       // fail
                            ^
-for-comprehension-val.scala:12: error: `val` keyword in for comprehension is unsupported: just remove `val`
+for-comprehension-val.scala:12: error: `val` keyword in for comprehension is unsupported: just remove `val` [quickfixable]
   for (z <- 1 to 2 ; val x <- 1 to 5 ; val y = x) yield x+y   // fail
                            ^
-for-comprehension-val.scala:5: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val`
+for-comprehension-val.scala:5: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val` [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   for (x <- 1 to 5 ; val y = x) yield x+y       // fail
                            ^
-for-comprehension-val.scala:7: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val`
+for-comprehension-val.scala:7: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val` [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   for (val x <- 1 to 5 ; val y = x) yield x+y   // fail
                                ^
-for-comprehension-val.scala:10: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val`
+for-comprehension-val.scala:10: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val` [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   for (z <- 1 to 2 ; x <- 1 to 5 ; val y = x) yield x+y       // fail
                                          ^
-for-comprehension-val.scala:12: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val`
+for-comprehension-val.scala:12: error: `val` keyword in for comprehension is unsupported: instead, bind the value without `val` [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   for (z <- 1 to 2 ; val x <- 1 to 5 ; val y = x) yield x+y   // fail
diff --git a/test/files/neg/implicits.check b/test/files/neg/implicits.check
index 6bcdf6c812..a91387c2f8 100644
--- a/test/files/neg/implicits.check
+++ b/test/files/neg/implicits.check
@@ -16,10 +16,10 @@ implicits.scala:47: error: type mismatch;
 implicits.scala:59: error: could not find implicit value for parameter x: Nothing
   foo {
       ^
-implicits.scala:34: warning: Implicit definition should have explicit type (inferred T)
+implicits.scala:34: warning: Implicit definition should have explicit type (inferred T) [quickfixable]
   implicit def select[T](t: HSome[T,_]) = t.head
                ^
-implicits.scala:35: warning: Implicit definition should have explicit type (inferred L)
+implicits.scala:35: warning: Implicit definition should have explicit type (inferred L) [quickfixable]
   implicit def selectTail[L](t: HSome[_,L]) = t.tail
                ^
 2 warnings
diff --git a/test/files/neg/lint-int-div-to-float.check b/test/files/neg/lint-int-div-to-float.check
index 462a51ced0..83f69ca9ab 100644
--- a/test/files/neg/lint-int-div-to-float.check
+++ b/test/files/neg/lint-int-div-to-float.check
@@ -1,16 +1,16 @@
-lint-int-div-to-float.scala:6: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`.
+lint-int-div-to-float.scala:6: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`. [quickfixable]
   def w1: Double = f / 2
                      ^
-lint-int-div-to-float.scala:7: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`.
+lint-int-div-to-float.scala:7: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`. [quickfixable]
   def w2: Double = (f / 2) * 3
                       ^
-lint-int-div-to-float.scala:8: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`.
+lint-int-div-to-float.scala:8: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`. [quickfixable]
   def w3: Double = -(f / 2)
                        ^
-lint-int-div-to-float.scala:9: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`.
+lint-int-div-to-float.scala:9: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`. [quickfixable]
   def w4: Double = (new C).f / (new C).f * 3
                              ^
-lint-int-div-to-float.scala:10: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`.
+lint-int-div-to-float.scala:10: warning: integral division is implicitly converted (widened) to floating point. Add an explicit `.toDouble`. [quickfixable]
   def w5: Double = f - f.abs / 2
                              ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/literals.check b/test/files/neg/literals.check
index a9e8299c75..2f9e809bf4 100644
--- a/test/files/neg/literals.check
+++ b/test/files/neg/literals.check
@@ -49,10 +49,10 @@ literals.scala:26: warning: Decimal integer literals should not have a leading z
 literals.scala:28: warning: Decimal integer literals should not have a leading zero. (Octal syntax is obsolete.)
   def zeroOfNine: Int    = 09            // line 28: no leading zero
                            ^
-literals.scala:50: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead
+literals.scala:50: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead [quickfixable]
   def bad = 1l
              ^
-literals.scala:52: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead
+literals.scala:52: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead [quickfixable]
   def worse = 123l
                  ^
 8 warnings
diff --git a/test/files/neg/macro-deprecate-idents.check b/test/files/neg/macro-deprecate-idents.check
index 340e6d8459..e800f2ffba 100644
--- a/test/files/neg/macro-deprecate-idents.check
+++ b/test/files/neg/macro-deprecate-idents.check
@@ -64,7 +64,7 @@ macro-deprecate-idents.scala:47: error: '{' expected but '}' found.
 macro-deprecate-idents.scala:54: error: ')' expected but '}' found.
 }
 ^
-macro-deprecate-idents.scala:57: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `<error>`'s return type
+macro-deprecate-idents.scala:57: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `<error>`'s return type [quickfixable]
   def macro = 2
                ^
 1 warning
diff --git a/test/files/neg/names-defaults-neg.check b/test/files/neg/names-defaults-neg.check
index b6c663a417..af887de0ae 100644
--- a/test/files/neg/names-defaults-neg.check
+++ b/test/files/neg/names-defaults-neg.check
@@ -127,10 +127,10 @@ names-defaults-neg.scala:147: error: parameter 'a' is already specified at param
 names-defaults-neg.scala:148: error: missing parameter type for expanded function ((<x$4: error>) => b = x$4)
   val taf4: (Int, String) => Unit = testAnnFun(_, b = _)
                                                       ^
-names-defaults-neg.scala:103: warning: symbol literal is deprecated; use Symbol("foo") instead
+names-defaults-neg.scala:103: warning: symbol literal is deprecated; use Symbol("foo") instead [quickfixable]
   def deprNam6(@deprecatedName('foo) deprNam6Arg: String) = 0
                                ^
-names-defaults-neg.scala:105: warning: symbol literal is deprecated; use Symbol("bar") instead
+names-defaults-neg.scala:105: warning: symbol literal is deprecated; use Symbol("bar") instead [quickfixable]
   def deprNam7(@deprecatedName('bar, "2.12.0") deprNam7Arg: String) = 0
                                ^
 names-defaults-neg.scala:95: warning: the parameter name y is deprecated: use b instead
diff --git a/test/files/neg/nullary-override-3a.check b/test/files/neg/nullary-override-3a.check
index 5b5e246bdf..bda1008b04 100644
--- a/test/files/neg/nullary-override-3a.check
+++ b/test/files/neg/nullary-override-3a.check
@@ -1,13 +1,25 @@
 nullary-override-3a.scala:4: error: method with a single empty parameter list overrides method without any parameter list
-def x: Int (defined in class A)
+def x: Int (defined in class A) [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=B
 class B extends A { override def x(): Int = 4 }
                                  ^
 nullary-override-3a.scala:16: error: method with a single empty parameter list overrides method without any parameter list
-def x: String (defined in trait T1)
+def x: String (defined in trait T1) [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Mix12b
 class Mix12b extends T1 with T2 { override def x() = "12b" }
                                                ^
+nullary-override-3a.scala:18: error: method without a parameter list overrides a method with a single empty one
+def x(): String (defined in trait T2) [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Mix21a
+class Mix21a extends T2 with T1 { override def x   = "21a" }
+                                               ^
 nullary-override-3a.scala:19: error: method with a single empty parameter list overrides method without any parameter list
-def x: String (defined in trait T1)
+def x: String (defined in trait T1) [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Mix21b
 class Mix21b extends T2 with T1 { override def x() = "21b" }
                                                ^
-3 errors
+4 errors
diff --git a/test/files/neg/nullary-override-3b.check b/test/files/neg/nullary-override-3b.check
index 7c4fd1b736..3877313510 100644
--- a/test/files/neg/nullary-override-3b.check
+++ b/test/files/neg/nullary-override-3b.check
@@ -1,9 +1,13 @@
 nullary-override-3b.scala:6: error: method without a parameter list overrides a method with a single empty one
-def x(): Int (defined in class P)
+def x(): Int (defined in class P) [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Q
 class Q extends P { override def x: Int = 4 }
                                  ^
 nullary-override-3b.scala:11: error: method without a parameter list overrides a method with a single empty one
-def x(): String (defined in trait T2)
+def x(): String (defined in trait T2) [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Mix12a
 class Mix12a extends T1 with T2 { override def x   = "12a" }
                                                ^
 2 errors
diff --git a/test/files/neg/nullary-override.check b/test/files/neg/nullary-override.check
index 93e82b74e0..1158dd272e 100644
--- a/test/files/neg/nullary-override.check
+++ b/test/files/neg/nullary-override.check
@@ -1,18 +1,21 @@
-nullary-override.scala:4: warning: method with a single empty parameter list overrides method without any parameter list
+nullary-override.scala:4: warning: method with a single empty parameter list overrides method without any parameter list [quickfixable]
 class B extends A { override def x(): Int = 4 }
                                  ^
-nullary-override.scala:15: warning: method without a parameter list overrides a method with a single empty one
+nullary-override.scala:15: warning: method without a parameter list overrides a method with a single empty one [quickfixable]
 class Q extends P { override def x: Int = 4 }
                                  ^
-nullary-override.scala:36: warning: method without a parameter list overrides a method with a single empty one
+nullary-override.scala:36: warning: method without a parameter list overrides a method with a single empty one [quickfixable]
 class Mix12a extends T1 with T2 { override def x   = "12a" }
                                                ^
-nullary-override.scala:37: warning: method with a single empty parameter list overrides method without any parameter list
+nullary-override.scala:37: warning: method with a single empty parameter list overrides method without any parameter list [quickfixable]
 class Mix12b extends T1 with T2 { override def x() = "12b" }
                                                ^
-nullary-override.scala:40: warning: method with a single empty parameter list overrides method without any parameter list
+nullary-override.scala:39: warning: method without a parameter list overrides a method with a single empty one [quickfixable]
+class Mix21a extends T2 with T1 { override def x   = "21a" }
+                                               ^
+nullary-override.scala:40: warning: method with a single empty parameter list overrides method without any parameter list [quickfixable]
 class Mix21b extends T2 with T1 { override def x() = "21b" }
                                                ^
 error: No warnings can be incurred under -Werror.
-5 warnings
+6 warnings
 1 error
diff --git a/test/files/neg/override-final-implicit.check b/test/files/neg/override-final-implicit.check
index d5e5460787..a849d1cae0 100644
--- a/test/files/neg/override-final-implicit.check
+++ b/test/files/neg/override-final-implicit.check
@@ -1,4 +1,4 @@
-override-final-implicit.scala:6: warning: Implicit definition should have explicit type (inferred Test.this.FooExtender)
+override-final-implicit.scala:6: warning: Implicit definition should have explicit type (inferred Test.this.FooExtender) [quickfixable]
   override implicit def FooExtender(foo: String) = super.FooExtender(foo)
                         ^
 override-final-implicit.scala:6: error: cannot override final member:
diff --git a/test/files/neg/parens-for-params.check b/test/files/neg/parens-for-params.check
index 71c8ab8562..58ea0a5d89 100644
--- a/test/files/neg/parens-for-params.check
+++ b/test/files/neg/parens-for-params.check
@@ -1,5 +1,5 @@
 parens-for-params.scala:5: error: parentheses are required around the parameter of a lambda
-Use '-Wconf:msg=lambda-parens:s' to silence this warning.
+Use '-Wconf:msg=lambda-parens:s' to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
     x: Int => x * 2
diff --git a/test/files/neg/prefix-unary-nilary-deprecation.check b/test/files/neg/prefix-unary-nilary-deprecation.check
index ed5ecc0a17..7f511fa86f 100644
--- a/test/files/neg/prefix-unary-nilary-deprecation.check
+++ b/test/files/neg/prefix-unary-nilary-deprecation.check
@@ -1,12 +1,12 @@
-prefix-unary-nilary-deprecation.scala:4: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_~ : Foo = this`
+prefix-unary-nilary-deprecation.scala:4: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_~ : Foo = this` [quickfixable]
   def unary_~() : Foo = this
       ^
-prefix-unary-nilary-deprecation.scala:5: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_-(implicit pos: Long) = this`
+prefix-unary-nilary-deprecation.scala:5: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_-(implicit pos: Long) = this` [quickfixable]
   def unary_-()(implicit pos: Long) = this
       ^
 prefix-unary-nilary-deprecation.scala:12: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method unary_~,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   val f2 = ~f
            ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/prefix-unary-nilary-removal.check b/test/files/neg/prefix-unary-nilary-removal.check
index 673eec56da..64c21b2f35 100644
--- a/test/files/neg/prefix-unary-nilary-removal.check
+++ b/test/files/neg/prefix-unary-nilary-removal.check
@@ -1,12 +1,12 @@
-prefix-unary-nilary-removal.scala:4: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_~ : Foo = this`
+prefix-unary-nilary-removal.scala:4: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_~ : Foo = this` [quickfixable]
   def unary_~() : Foo = this
       ^
-prefix-unary-nilary-removal.scala:5: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_-(implicit pos: Long) = this`
+prefix-unary-nilary-removal.scala:5: warning: unary prefix operator definition with empty parameter list is deprecated: instead, remove () to declare as `def unary_-(implicit pos: Long) = this` [quickfixable]
   def unary_-()(implicit pos: Long) = this
       ^
 prefix-unary-nilary-removal.scala:12: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method unary_~,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   val f2 = ~f
            ^
 prefix-unary-nilary-removal.scala:5: warning: parameter pos in method unary_- is never used
diff --git a/test/files/neg/private-implicit-class.check b/test/files/neg/private-implicit-class.check
index 1578f91023..29dfb141fc 100644
--- a/test/files/neg/private-implicit-class.check
+++ b/test/files/neg/private-implicit-class.check
@@ -1,7 +1,7 @@
 private-implicit-class.scala:6: error: method BarExtender in class ImplicitsPrivate cannot be accessed as a member of ImplicitsPrivate from class TestPrivate
   override implicit def BarExtender(bar: Int) = super.BarExtender(bar) // error
                                                       ^
-private-implicit-class.scala:6: warning: Implicit definition should have explicit type
+private-implicit-class.scala:6: warning: Implicit definition should have explicit type [quickfixable]
   override implicit def BarExtender(bar: Int) = super.BarExtender(bar) // error
                         ^
 1 warning
diff --git a/test/files/neg/procedure-deprecation.check b/test/files/neg/procedure-deprecation.check
index 613e859517..9953124cf8 100644
--- a/test/files/neg/procedure-deprecation.check
+++ b/test/files/neg/procedure-deprecation.check
@@ -1,16 +1,16 @@
-procedure-deprecation.scala:4: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `bar`'s return type
+procedure-deprecation.scala:4: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `bar`'s return type [quickfixable]
   def bar {}
           ^
-procedure-deprecation.scala:5: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `baz`'s return type
+procedure-deprecation.scala:5: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `baz`'s return type [quickfixable]
   def baz
          ^
-procedure-deprecation.scala:6: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `boo`'s return type
+procedure-deprecation.scala:6: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `boo`'s return type [quickfixable]
   def boo(i: Int, l: Long)
                           ^
-procedure-deprecation.scala:7: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `boz`'s return type
+procedure-deprecation.scala:7: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `boz`'s return type [quickfixable]
   def boz(i: Int, l: Long) {}
                            ^
-procedure-deprecation.scala:8: warning: procedure syntax is deprecated for constructors: add `=`, as in method definition
+procedure-deprecation.scala:8: warning: procedure syntax is deprecated for constructors: add `=`, as in method definition [quickfixable]
   def this(i: Int) { this() } // Don't complain here! or maybe do complain
                   ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/procedure-removal.check b/test/files/neg/procedure-removal.check
index c0c10e2530..f8d6f30f3f 100644
--- a/test/files/neg/procedure-removal.check
+++ b/test/files/neg/procedure-removal.check
@@ -1,25 +1,25 @@
-procedure-removal.scala:4: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `bar`'s return type
+procedure-removal.scala:4: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `bar`'s return type [quickfixable]
   def bar {}
           ^
-procedure-removal.scala:5: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `baz`'s return type
+procedure-removal.scala:5: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `baz`'s return type [quickfixable]
   def baz
          ^
-procedure-removal.scala:6: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `boo`'s return type
+procedure-removal.scala:6: warning: procedure syntax is deprecated: instead, add `: Unit` to explicitly declare `boo`'s return type [quickfixable]
   def boo(i: Int, l: Long)
                           ^
-procedure-removal.scala:7: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `boz`'s return type
+procedure-removal.scala:7: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `boz`'s return type [quickfixable]
   def boz(i: Int, l: Long) {}
                            ^
-procedure-removal.scala:8: warning: procedure syntax is deprecated for constructors: add `=`, as in method definition
+procedure-removal.scala:8: warning: procedure syntax is deprecated for constructors: add `=`, as in method definition [quickfixable]
   def this(i: Int) { this() } // Don't complain here! Just slap them with an error.
                   ^
-procedure-removal.scala:4: warning: side-effecting nullary methods are discouraged: suggest defining as `def bar()` instead
+procedure-removal.scala:4: warning: side-effecting nullary methods are discouraged: suggest defining as `def bar()` instead [quickfixable]
   def bar {}
       ^
-procedure-removal.scala:5: warning: side-effecting nullary methods are discouraged: suggest defining as `def baz()` instead
+procedure-removal.scala:5: warning: side-effecting nullary methods are discouraged: suggest defining as `def baz()` instead [quickfixable]
   def baz
       ^
-procedure-removal.scala:9: warning: side-effecting nullary methods are discouraged: suggest defining as `def foz()` instead
+procedure-removal.scala:9: warning: side-effecting nullary methods are discouraged: suggest defining as `def foz()` instead [quickfixable]
   def foz: Unit               // Don't complain here!
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/qmark-deprecated.check b/test/files/neg/qmark-deprecated.check
index 930dcd9e73..81053d1968 100644
--- a/test/files/neg/qmark-deprecated.check
+++ b/test/files/neg/qmark-deprecated.check
@@ -1,25 +1,25 @@
-qmark-deprecated.scala:4: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:4: error: using `?` as a type name requires backticks. [quickfixable]
 class Foo[?] // error
           ^
-qmark-deprecated.scala:6: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:6: error: using `?` as a type name requires backticks. [quickfixable]
 class Bar[M[?] <: List[?]] // error on the definition
             ^
-qmark-deprecated.scala:10: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:10: error: using `?` as a type name requires backticks. [quickfixable]
   class ? { val x = 1 } // error
         ^
-qmark-deprecated.scala:16: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:16: error: using `?` as a type name requires backticks. [quickfixable]
   trait ? // error
         ^
-qmark-deprecated.scala:22: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:22: error: using `?` as a type name requires backticks. [quickfixable]
   type ? = Int // error
        ^
-qmark-deprecated.scala:33: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:33: error: using `?` as a type name requires backticks. [quickfixable]
   def bar1[?] = {} // error
            ^
-qmark-deprecated.scala:35: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:35: error: using `?` as a type name requires backticks. [quickfixable]
   def bar3[M[?]] = {} // error
              ^
-qmark-deprecated.scala:38: error: using `?` as a type name requires backticks.
+qmark-deprecated.scala:38: error: using `?` as a type name requires backticks. [quickfixable]
   type A[?] = Int // error
          ^
 8 errors
diff --git a/test/files/neg/quickfix-silent.check b/test/files/neg/quickfix-silent.check
new file mode 100644
index 0000000000..7f8eb238c1
--- /dev/null
+++ b/test/files/neg/quickfix-silent.check
@@ -0,0 +1,11 @@
+quickfix-silent.scala:4: warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `f`'s return type
+  def f { println }
+        ^
+quickfix-silent.scala:4: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method println,
+or remove the empty argument list from its definition (Java-defined methods are exempt).
+In Scala 3, an unapplied method like this will be eta-expanded into a function.
+  def f { println }
+          ^
+error: No warnings can be incurred under -Werror.
+2 warnings
+1 error
diff --git a/test/files/neg/quickfix-silent.scala b/test/files/neg/quickfix-silent.scala
new file mode 100644
index 0000000000..99bdc0e50a
--- /dev/null
+++ b/test/files/neg/quickfix-silent.scala
@@ -0,0 +1,5 @@
+// scalac: -deprecation -Werror -quickfix:silent
+
+class C {
+  def f { println }
+}
diff --git a/test/files/neg/scala3-keywords.check b/test/files/neg/scala3-keywords.check
index 7f3a215550..9bc981ad86 100644
--- a/test/files/neg/scala3-keywords.check
+++ b/test/files/neg/scala3-keywords.check
@@ -1,19 +1,19 @@
-scala3-keywords.scala:15: warning: Wrap `enum` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+scala3-keywords.scala:15: warning: Wrap `enum` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
   val enum: Int = 1 // error
       ^
-scala3-keywords.scala:16: warning: Wrap `export` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+scala3-keywords.scala:16: warning: Wrap `export` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
   val export: Int = 1 // error
       ^
-scala3-keywords.scala:17: warning: Wrap `given` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+scala3-keywords.scala:17: warning: Wrap `given` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
   val given: Int = 1 // error
       ^
-scala3-keywords.scala:18: warning: Wrap `given` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+scala3-keywords.scala:18: warning: Wrap `given` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
   def foo(given: Int) = {} // error
           ^
-scala3-keywords.scala:19: warning: Wrap `export` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+scala3-keywords.scala:19: warning: Wrap `export` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
   def bla[export <: Int] = {} // error
           ^
-scala3-keywords.scala:21: warning: Wrap `enum` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+scala3-keywords.scala:21: warning: Wrap `enum` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
 class enum // error
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/sip23-no-unit-type.check b/test/files/neg/sip23-no-unit-type.check
index 1ffd825ed6..01fba8b543 100644
--- a/test/files/neg/sip23-no-unit-type.check
+++ b/test/files/neg/sip23-no-unit-type.check
@@ -1,16 +1,16 @@
-sip23-no-unit-type.scala:6: error: Illegal literal type (), use Unit instead
+sip23-no-unit-type.scala:6: error: Illegal literal type (), use Unit instead [quickfixable]
     case _: ()      => "err"
             ^
-sip23-no-unit-type.scala:7: error: Illegal literal type (), use Unit instead
+sip23-no-unit-type.scala:7: error: Illegal literal type (), use Unit instead [quickfixable]
     case _: ().type => "err"
             ^
 sip23-no-unit-type.scala:7: error: '=>' expected but '.' found.
     case _: ().type => "err"
               ^
-sip23-no-unit-type.scala:10: error: Illegal literal type (), use Unit instead
+sip23-no-unit-type.scala:10: error: Illegal literal type (), use Unit instead [quickfixable]
   val younit: () = ()
               ^
-sip23-no-unit-type.scala:11: error: Illegal literal type (), use Unit instead
+sip23-no-unit-type.scala:11: error: Illegal literal type (), use Unit instead [quickfixable]
   val unit: ().type = ()
             ^
 sip23-no-unit-type.scala:11: error: '=' expected but '.' found.
diff --git a/test/files/neg/symbol-literal-deprecation.check b/test/files/neg/symbol-literal-deprecation.check
index b7d3b90a3e..caa9184460 100644
--- a/test/files/neg/symbol-literal-deprecation.check
+++ b/test/files/neg/symbol-literal-deprecation.check
@@ -1,4 +1,4 @@
-symbol-literal-deprecation.scala:4: warning: symbol literal is deprecated; use Symbol("TestSymbol") instead
+symbol-literal-deprecation.scala:4: warning: symbol literal is deprecated; use Symbol("TestSymbol") instead [quickfixable]
   val foo = 'TestSymbol
             ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t10678.check b/test/files/neg/t10678.check
index 6f06f1b04f..15a3db3012 100644
--- a/test/files/neg/t10678.check
+++ b/test/files/neg/t10678.check
@@ -4,7 +4,7 @@ class C <: T {
 t10678.scala:11: error: ';' expected but '<:' found.
 object O <: T {
          ^
-t10678.scala:6: warning: Using `<:` for `extends` is deprecated
+t10678.scala:6: warning: Using `<:` for `extends` is deprecated [quickfixable]
 trait U <: T
         ^
 1 warning
diff --git a/test/files/neg/t11921-alias.check b/test/files/neg/t11921-alias.check
index af9e3b4cbf..62cb30931f 100644
--- a/test/files/neg/t11921-alias.check
+++ b/test/files/neg/t11921-alias.check
@@ -2,7 +2,7 @@ t11921-alias.scala:18: error: reference to TT is ambiguous;
 it is both defined in the enclosing object O and inherited in the enclosing class D as type TT (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.TT`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=t2.O.D.n.x
       def n(x: TT) = x // ambiguous
@@ -11,7 +11,7 @@ t11921-alias.scala:38: error: reference to c is ambiguous;
 it is both defined in the enclosing class B and inherited in the enclosing anonymous class as value c (defined in class A)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.c`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=t4.B.a
       def n = c // ambiguous
@@ -20,7 +20,7 @@ t11921-alias.scala:57: error: reference to name is ambiguous;
 it is both defined in the enclosing method m and inherited in the enclosing anonymous class as value name (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.name`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=t6.Test.m
       println(name)
@@ -29,7 +29,7 @@ t11921-alias.scala:67: error: reference to name is ambiguous;
 it is both defined in the enclosing method m and inherited in the enclosing anonymous class as value name (defined in class A, inherited through parent class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.name`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=t7.Test.m
       println(name)
diff --git a/test/files/neg/t11921.check b/test/files/neg/t11921.check
index ea76301577..e66a402a1e 100644
--- a/test/files/neg/t11921.check
+++ b/test/files/neg/t11921.check
@@ -7,7 +7,7 @@ t11921.scala:6: error: reference to coll is ambiguous;
 it is both defined in the enclosing method lazyMap and inherited in the enclosing anonymous class as method coll (defined in trait Iterable)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.coll`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=C.lazyMap
       def iterator = coll.iterator.map(f)    // coll is ambiguous
diff --git a/test/files/neg/t11921b.check b/test/files/neg/t11921b.check
index f9905b57d7..0a073ee5c3 100644
--- a/test/files/neg/t11921b.check
+++ b/test/files/neg/t11921b.check
@@ -1,11 +1,17 @@
 t11921b.scala:135: error: could not find implicit value for parameter i: Int
     def u = t // doesn't compile in Scala 2 (maybe there's a ticket for that)
             ^
+t11921b.scala:151: error: package object inheritance is deprecated (https://github.com/scala/scala-dev/issues/441);
+drop the `extends` clause or use a regular object instead
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
+package object pt12850 extends t12850 {
+                       ^
 t11921b.scala:11: error: reference to x is ambiguous;
 it is both defined in the enclosing object Test and inherited in the enclosing class D as value x (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.x`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test1.Test.D
       println(x)  // error
@@ -14,7 +20,7 @@ t11921b.scala:15: error: reference to x is ambiguous;
 it is both defined in the enclosing object Test and inherited in the enclosing anonymous class as value x (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.x`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test1.Test.f
         println(x)  // error
@@ -23,7 +29,7 @@ t11921b.scala:26: error: reference to y is ambiguous;
 it is both defined in the enclosing method c and inherited in the enclosing anonymous class as value y (defined in class D)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.y`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test2.c
       println(y)  // error
@@ -32,7 +38,7 @@ t11921b.scala:38: error: reference to y is ambiguous;
 it is both defined in the enclosing method c and inherited in the enclosing class E as value y (defined in class D)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `E.this.y`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test3.c.E.F
         println(y)  // error
@@ -41,7 +47,7 @@ t11921b.scala:65: error: reference to global is ambiguous;
 it is both defined in the enclosing package <empty> and inherited in the enclosing object D as value global (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.global`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=D
   println(global)    // error
@@ -50,7 +56,7 @@ t11921b.scala:75: error: reference to x is ambiguous;
 it is both defined in the enclosing object Uhu and inherited in the enclosing class C as value x (defined in class A, inherited through parent class B)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `C.this.x`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test5.Uhu.C.Inner.t
         def t = x // ambiguous, message mentions parent B
@@ -59,7 +65,7 @@ t11921b.scala:89: error: reference to a is ambiguous;
 it is both defined in the enclosing class C and inherited in the enclosing trait J as method a (defined in trait I)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.a`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test6.C.J.t
       val t = a // error
@@ -68,9 +74,9 @@ t11921b.scala:136: error: reference to lo is ambiguous;
 it is both defined in the enclosing object test10 and inherited in the enclosing class C as value lo (defined in class P)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.lo`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=test10.C.v
     def v = t(lo) // error
               ^
-9 errors
+10 errors
diff --git a/test/files/neg/t11921b.scala b/test/files/neg/t11921b.scala
index 887b728069..bf397ffcfa 100644
--- a/test/files/neg/t11921b.scala
+++ b/test/files/neg/t11921b.scala
@@ -143,3 +143,19 @@ package scala {
     def t = new Option[String] {} // OK, competing scala.Option is not defined in the same compilation unit
   }
 }
+
+trait t12850 {
+  def pm(x: Int) = 1
+  def pm(x: String) = 2
+}
+package object pt12850 extends t12850 {
+  def t = pm(1) // no error
+}
+
+trait t12850b {
+  def pm(x: Int) = 1
+  def pm(x: String) = 2
+  object O extends t12850b {
+    def t = pm(1) // no error
+  }
+}
diff --git a/test/files/neg/t11962.check b/test/files/neg/t11962.check
index 85e81a7d6b..034f6c24a7 100644
--- a/test/files/neg/t11962.check
+++ b/test/files/neg/t11962.check
@@ -1,7 +1,7 @@
-t11962.scala:3: warning: side-effecting nullary methods are discouraged: suggest defining as `def f()` instead
+t11962.scala:3: warning: side-effecting nullary methods are discouraged: suggest defining as `def f()` instead [quickfixable]
   def f = println()
       ^
-t11962.scala:7: warning: side-effecting nullary methods are discouraged: suggest defining as `def f()` instead
+t11962.scala:7: warning: side-effecting nullary methods are discouraged: suggest defining as `def f()` instead [quickfixable]
   override def f = super.f
                ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t12728.check b/test/files/neg/t12728.check
index 482707b620..c664b4ea4d 100644
--- a/test/files/neg/t12728.check
+++ b/test/files/neg/t12728.check
@@ -22,97 +22,97 @@ t12728.scala:16: warning: dubious usage of method isInstanceOf with unit value
 t12728.scala:17: warning: dubious usage of method toString with unit value
   println(u.toString)
             ^
-t12728.scala:20: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:20: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.isNaN)
           ^
 t12728.scala:20: warning: dubious usage of method isNaN with integer value
   println(i.isNaN)
             ^
-t12728.scala:21: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:21: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.isInfinity)
           ^
 t12728.scala:21: warning: dubious usage of method isInfinity with integer value
   println(i.isInfinity)
             ^
-t12728.scala:22: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:22: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.isInfinite)
           ^
 t12728.scala:22: warning: dubious usage of method isInfinite with integer value
   println(i.isInfinite)
             ^
-t12728.scala:23: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:23: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.isFinite)
           ^
 t12728.scala:23: warning: dubious usage of method isFinite with integer value
   println(i.isFinite)
             ^
-t12728.scala:24: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:24: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.isPosInfinity)
           ^
 t12728.scala:24: warning: dubious usage of method isPosInfinity with integer value
   println(i.isPosInfinity)
             ^
-t12728.scala:25: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:25: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.isNegInfinity)
           ^
 t12728.scala:25: warning: dubious usage of method isNegInfinity with integer value
   println(i.isNegInfinity)
             ^
-t12728.scala:27: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:27: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.ceil)
           ^
 t12728.scala:27: warning: dubious usage of method ceil with integer value
   println(i.ceil)
             ^
-t12728.scala:28: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:28: warning: Widening conversion from Int to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(i.floor)
           ^
 t12728.scala:28: warning: dubious usage of method floor with integer value
   println(i.floor)
             ^
-t12728.scala:30: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:30: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.isNaN)
           ^
 t12728.scala:30: warning: dubious usage of method isNaN with integer value
   println(l.isNaN)
             ^
-t12728.scala:31: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:31: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.isInfinity)
           ^
 t12728.scala:31: warning: dubious usage of method isInfinity with integer value
   println(l.isInfinity)
             ^
-t12728.scala:32: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:32: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.isInfinite)
           ^
 t12728.scala:32: warning: dubious usage of method isInfinite with integer value
   println(l.isInfinite)
             ^
-t12728.scala:33: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:33: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.isFinite)
           ^
 t12728.scala:33: warning: dubious usage of method isFinite with integer value
   println(l.isFinite)
             ^
-t12728.scala:34: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:34: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.isPosInfinity)
           ^
 t12728.scala:34: warning: dubious usage of method isPosInfinity with integer value
   println(l.isPosInfinity)
             ^
-t12728.scala:35: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:35: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.isNegInfinity)
           ^
 t12728.scala:35: warning: dubious usage of method isNegInfinity with integer value
   println(l.isNegInfinity)
             ^
-t12728.scala:37: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:37: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.ceil)
           ^
 t12728.scala:37: warning: dubious usage of method ceil with integer value
   println(l.ceil)
             ^
-t12728.scala:38: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead.
+t12728.scala:38: warning: Widening conversion from Long to Float is deprecated because it loses precision. Write `.toFloat` instead. [quickfixable]
   println(l.floor)
           ^
 t12728.scala:38: warning: dubious usage of method floor with integer value
diff --git a/test/files/neg/t12798-migration.check b/test/files/neg/t12798-migration.check
index 62d41315bc..2a6082db31 100644
--- a/test/files/neg/t12798-migration.check
+++ b/test/files/neg/t12798-migration.check
@@ -3,27 +3,27 @@ Note that assignments in argument position are no longer allowed since Scala 2.1
 To express the assignment expression, wrap it in brackets, e.g., `{ z = ... }`.
     f(42, z = 27)
             ^
-t12798-migration.scala:25: warning: unary prefix operator definition with empty parameter list is unsupported: instead, remove () to declare as `def unary_- = -42`
+t12798-migration.scala:25: warning: unary prefix operator definition with empty parameter list is unsupported: instead, remove () to declare as `def unary_- = -42` [quickfixable]
   def unary_-() = -42
       ^
 t12798-migration.scala:28: warning: package object inheritance is deprecated (https://github.com/scala/scala-dev/issues/441);
 drop the `extends` clause or use a regular object instead
 package object tester extends Runnable {
                       ^
-t12798-migration.scala:33: warning: procedure syntax is deprecated for constructors: add `=`, as in method definition
+t12798-migration.scala:33: warning: procedure syntax is deprecated for constructors: add `=`, as in method definition [quickfixable]
   def this(s: String) { this() }
                      ^
-t12798-migration.scala:34: warning: procedure syntax is unsupported: instead, add `: Unit =` to explicitly declare `f`'s return type
+t12798-migration.scala:34: warning: procedure syntax is unsupported: instead, add `: Unit =` to explicitly declare `f`'s return type [quickfixable]
   def f() { println() }
           ^
-t12798-migration.scala:35: warning: procedure syntax is unsupported: instead, add `: Unit` to explicitly declare `g`'s return type
+t12798-migration.scala:35: warning: procedure syntax is unsupported: instead, add `: Unit` to explicitly declare `g`'s return type [quickfixable]
   def g()
          ^
 t12798-migration.scala:39: warning: parentheses are required around the parameter of a lambda
-Use '-Wconf:msg=lambda-parens:s' to silence this warning.
+Use '-Wconf:msg=lambda-parens:s' to silence this warning. [quickfixable]
   def f = List(42).map { x: Int => x + 1 }
                           ^
-t12798-migration.scala:43: warning: type application is not allowed for infix operators
+t12798-migration.scala:43: warning: type application is not allowed for infix operators [quickfixable]
   def f = List(42) map [Int] (_ + 1)
                    ^
 t12798-migration.scala:46: warning: Top-level wildcard is not allowed
@@ -41,7 +41,7 @@ t12798-migration.scala:18: warning: Unicode escapes in raw interpolations are ig
 t12798-migration.scala:50: warning: constructor modifiers are assumed by synthetic `copy` method
 case class `case mods propagate` private (s: String)
            ^
-t12798-migration.scala:60: warning: under -Xsource:3, inferred Option[Int] instead of Some[Int]
+t12798-migration.scala:60: warning: under -Xsource:3, inferred Option[Int] instead of Some[Int] [quickfixable]
   override def f = Some(27)
                ^
 t12798-migration.scala:50: warning: constructor modifiers are assumed by synthetic `apply` method
diff --git a/test/files/neg/t12798.check b/test/files/neg/t12798.check
index f1429d511a..a4a6241814 100644
--- a/test/files/neg/t12798.check
+++ b/test/files/neg/t12798.check
@@ -3,7 +3,7 @@ Note that assignments in argument position are no longer allowed since Scala 2.1
 To express the assignment expression, wrap it in brackets, e.g., `{ z = ... }`.
     f(42, z = 27)
             ^
-t12798.scala:25: error: unary prefix operator definition with empty parameter list is unsupported: instead, remove () to declare as `def unary_- = -42`
+t12798.scala:25: error: unary prefix operator definition with empty parameter list is unsupported: instead, remove () to declare as `def unary_- = -42` [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def unary_-() = -42
@@ -14,28 +14,28 @@ Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
 package object tester extends Runnable {
                       ^
-t12798.scala:33: error: procedure syntax is deprecated for constructors: add `=`, as in method definition
+t12798.scala:33: error: procedure syntax is deprecated for constructors: add `=`, as in method definition [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def this(s: String) { this() }
                      ^
-t12798.scala:34: error: procedure syntax is unsupported: instead, add `: Unit =` to explicitly declare `f`'s return type
+t12798.scala:34: error: procedure syntax is unsupported: instead, add `: Unit =` to explicitly declare `f`'s return type [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def f() { println() }
           ^
-t12798.scala:35: error: procedure syntax is unsupported: instead, add `: Unit` to explicitly declare `g`'s return type
+t12798.scala:35: error: procedure syntax is unsupported: instead, add `: Unit` to explicitly declare `g`'s return type [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def g()
          ^
 t12798.scala:39: error: parentheses are required around the parameter of a lambda
-Use '-Wconf:msg=lambda-parens:s' to silence this warning.
+Use '-Wconf:msg=lambda-parens:s' to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def f = List(42).map { x: Int => x + 1 }
                           ^
-t12798.scala:43: error: type application is not allowed for infix operators
+t12798.scala:43: error: type application is not allowed for infix operators [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration
   def f = List(42) map [Int] (_ + 1)
@@ -65,7 +65,7 @@ Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=case mods propagate
 case class `case mods propagate` private (s: String)
            ^
-t12798.scala:60: error: under -Xsource:3, inferred Option[Int] instead of Some[Int]
+t12798.scala:60: error: under -Xsource:3, inferred Option[Int] instead of Some[Int] [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Child.f
   override def f = Some(27)
diff --git a/test/files/neg/t12815.check b/test/files/neg/t12815.check
index 0e725ec528..962b8c862d 100644
--- a/test/files/neg/t12815.check
+++ b/test/files/neg/t12815.check
@@ -1,7 +1,7 @@
-t12815.scala:22: warning: method with a single empty parameter list overrides method without any parameter list
+t12815.scala:22: warning: method with a single empty parameter list overrides method without any parameter list [quickfixable]
   def e(): Int = 1 // warn
       ^
-t12815.scala:23: warning: method without a parameter list overrides a method with a single empty one
+t12815.scala:23: warning: method without a parameter list overrides a method with a single empty one [quickfixable]
   def f: Int = 1   // warn
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t12816.check b/test/files/neg/t12816.check
index c2ce345cb1..e33d1dec43 100644
--- a/test/files/neg/t12816.check
+++ b/test/files/neg/t12816.check
@@ -8,7 +8,7 @@ t12816.scala:29: error: reference to c is ambiguous;
 it is both defined in the enclosing package p and inherited in the enclosing trait RR as method c (defined in trait T)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.c`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=p.RR.m3
     def m3 = c // warn
@@ -17,7 +17,7 @@ t12816.scala:33: error: reference to Z is ambiguous;
 it is both defined in the enclosing package p and inherited in the enclosing trait RR as trait Z (defined in trait T)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.Z`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=p.RR.n3
     def n3: Z // warn
diff --git a/test/files/neg/t12816b.check b/test/files/neg/t12816b.check
index 8504e32195..606f2c5790 100644
--- a/test/files/neg/t12816b.check
+++ b/test/files/neg/t12816b.check
@@ -8,7 +8,7 @@ B.scala:19: error: reference to c is ambiguous;
 it is both defined in the enclosing package p and inherited in the enclosing trait RR as method c (defined in trait T)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.c`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=p.RR.m3
     def m3 = c // warn
@@ -17,7 +17,7 @@ B.scala:23: error: reference to Z is ambiguous;
 it is both defined in the enclosing package p and inherited in the enclosing trait RR as trait Z (defined in trait T)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.Z`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=p.RR.n3
     def n3: Z // warn
diff --git a/test/files/neg/t12851b.check b/test/files/neg/t12851b.check
new file mode 100644
index 0000000000..27f1289f3f
--- /dev/null
+++ b/test/files/neg/t12851b.check
@@ -0,0 +1,9 @@
+C_2.scala:2: warning: method (method f in trait T2) with a single empty parameter list overrides method without any parameter list
+class C extends T1 with T2
+      ^
+C_2.scala:2: warning: method (method g in trait T2) without a parameter list overrides a method with a single empty one
+class C extends T1 with T2
+      ^
+error: No warnings can be incurred under -Werror.
+2 warnings
+1 error
diff --git a/test/files/neg/t12851b/C_2.scala b/test/files/neg/t12851b/C_2.scala
new file mode 100644
index 0000000000..c6d4b70f29
--- /dev/null
+++ b/test/files/neg/t12851b/C_2.scala
@@ -0,0 +1,2 @@
+// scalac: -Werror
+class C extends T1 with T2
diff --git a/test/files/neg/t12851b/T_1.scala b/test/files/neg/t12851b/T_1.scala
new file mode 100644
index 0000000000..e43a11ab2e
--- /dev/null
+++ b/test/files/neg/t12851b/T_1.scala
@@ -0,0 +1,11 @@
+
+trait T1 {
+  def f: Int
+  def g(): Int
+  def v(): Int
+}
+trait T2 {
+  def f() = 42
+  def g = 42
+  val v = 42
+}
diff --git a/test/files/neg/t2206.check b/test/files/neg/t2206.check
index 9aca6ff9f5..426e0a336f 100644
--- a/test/files/neg/t2206.check
+++ b/test/files/neg/t2206.check
@@ -2,7 +2,7 @@ t2206.scala:10: error: value f is not a member of o.A
  Note: implicit method ax is not applicable here because it comes after the application point and it lacks an explicit result type.
   a.f()
     ^
-t2206.scala:13: warning: Implicit definition should have explicit type (inferred o.AX)
+t2206.scala:13: warning: Implicit definition should have explicit type (inferred o.AX) [quickfixable]
       implicit def ax(a: A) = new AX
                    ^
 1 warning
diff --git a/test/files/neg/t2421b.check b/test/files/neg/t2421b.check
index 644395fc6a..a5f8e8b120 100644
--- a/test/files/neg/t2421b.check
+++ b/test/files/neg/t2421b.check
@@ -1,7 +1,7 @@
 t2421b.scala:12: error: could not find implicit value for parameter aa: Test.F[Test.A]
   f
   ^
-t2421b.scala:10: warning: Implicit definition should have explicit type (inferred Test.F[X])
+t2421b.scala:10: warning: Implicit definition should have explicit type (inferred Test.F[X]) [quickfixable]
   implicit def b[X <: B] = new F[X]()
                ^
 1 warning
diff --git a/test/files/neg/t3006.check b/test/files/neg/t3006.check
index e2358b0f0d..283864fc77 100644
--- a/test/files/neg/t3006.check
+++ b/test/files/neg/t3006.check
@@ -3,7 +3,7 @@ t3006.scala:8: error: type mismatch;
  required: Int
   println(A(3) + "H")
                  ^
-t3006.scala:6: warning: Implicit definition should have explicit type (inferred Test.Foo)
+t3006.scala:6: warning: Implicit definition should have explicit type (inferred Test.Foo) [quickfixable]
   implicit def aToFoo(x: A) = new Foo(x);
                ^
 1 warning
diff --git a/test/files/neg/t3346i.check b/test/files/neg/t3346i.check
index dafa0b861e..619bf2a386 100644
--- a/test/files/neg/t3346i.check
+++ b/test/files/neg/t3346i.check
@@ -4,19 +4,19 @@ t3346i.scala:28: error: value a is not a member of Test.A[T]
 t3346i.scala:29: error: value a is not a member of Test.A[Nothing]
   (new A[Nothing]).a
                    ^
-t3346i.scala:16: warning: Implicit definition should have explicit type (inferred Implicit1[T])
+t3346i.scala:16: warning: Implicit definition should have explicit type (inferred Implicit1[T]) [quickfixable]
   implicit def implicit1[T <: Intermediate[_, _]](implicit b: Implicit2[T])                = new Implicit1[T](b)
                ^
-t3346i.scala:18: warning: Implicit definition should have explicit type (inferred Implicit2[T])
+t3346i.scala:18: warning: Implicit definition should have explicit type (inferred Implicit2[T]) [quickfixable]
   implicit def implicit2alt1[T <: Intermediate[_ <: String, _]](implicit c: Implicit3[T])  = new Implicit2[T](c)
                ^
-t3346i.scala:19: warning: Implicit definition should have explicit type (inferred Implicit2[T])
+t3346i.scala:19: warning: Implicit definition should have explicit type (inferred Implicit2[T]) [quickfixable]
   implicit def implicit2alt2[T <: Intermediate[_ <: Double, _]](implicit c: Implicit3[T])  = new Implicit2[T](c)
                ^
-t3346i.scala:21: warning: Implicit definition should have explicit type (inferred Implicit3[T])
+t3346i.scala:21: warning: Implicit definition should have explicit type (inferred Implicit3[T]) [quickfixable]
   implicit def implicit3alt1[T <: Intermediate[_, _ <: Int]]                               = new Implicit3[T]()
                ^
-t3346i.scala:22: warning: Implicit definition should have explicit type (inferred Implicit3[T])
+t3346i.scala:22: warning: Implicit definition should have explicit type (inferred Implicit3[T]) [quickfixable]
   implicit def implicit3alt2[T <: Intermediate[_ <: Double, _ <: AnyRef],X]                = new Implicit3[T]()
                ^
 5 warnings
diff --git a/test/files/neg/t4271.check b/test/files/neg/t4271.check
index f4f3c9438a..c24ac9de11 100644
--- a/test/files/neg/t4271.check
+++ b/test/files/neg/t4271.check
@@ -9,22 +9,22 @@ t4271.scala:11: error: value -> is not a member of Int
 did you mean >>?
   3 -> 5
     ^
-t4271.scala:3: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type)
+t4271.scala:3: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type) [quickfixable]
   implicit def Ensuring[A](x: A) = Donotuseme
                ^
-t4271.scala:4: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type)
+t4271.scala:4: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type) [quickfixable]
   implicit def doubleWrapper(x: Int) = Donotuseme
                ^
-t4271.scala:5: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type)
+t4271.scala:5: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type) [quickfixable]
   implicit def floatWrapper(x: Int) = Donotuseme
                ^
-t4271.scala:6: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type)
+t4271.scala:6: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type) [quickfixable]
   implicit def intWrapper(x: Int) = Donotuseme
                ^
-t4271.scala:7: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type)
+t4271.scala:7: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type) [quickfixable]
   implicit def longWrapper(x: Int) = Donotuseme
                ^
-t4271.scala:8: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type)
+t4271.scala:8: warning: Implicit definition should have explicit type (inferred foo.Donotuseme.type) [quickfixable]
   implicit def ArrowAssoc[A](x: A) = Donotuseme
                ^
 6 warnings
diff --git a/test/files/neg/t4457_1.check b/test/files/neg/t4457_1.check
index 4d65bc39c1..6dc6b6f3ad 100644
--- a/test/files/neg/t4457_1.check
+++ b/test/files/neg/t4457_1.check
@@ -4,19 +4,19 @@ and  method aFunc in object ImplicitConvAmbiguity2 of type [A](a: ImplicitConvAm
 match argument types (Float)
     val x = aFunc(4F)
             ^
-t4457_1.scala:11: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NE[Float])
+t4457_1.scala:11: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NE[Float]) [quickfixable]
   implicit def conv1(i: Float) = new NE[Float]
                ^
-t4457_1.scala:12: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.TooManyListenersException])
+t4457_1.scala:12: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.TooManyListenersException]) [quickfixable]
   implicit def conv3(op: AA[java.util.TooManyListenersException]) = new N[java.util.TooManyListenersException]
                ^
-t4457_1.scala:13: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[Float])
+t4457_1.scala:13: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[Float]) [quickfixable]
   implicit def conv4(op: AA[Float]) = new N[Float]
                ^
-t4457_1.scala:14: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NZ[Float])
+t4457_1.scala:14: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NZ[Float]) [quickfixable]
   implicit def conv7(i: Float) = new NZ[Float]
                ^
-t4457_1.scala:15: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.GregorianCalendar])
+t4457_1.scala:15: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.GregorianCalendar]) [quickfixable]
   implicit def conv5(e: BB[java.util.GregorianCalendar]) = new N[java.util.GregorianCalendar]
                ^
 5 warnings
diff --git a/test/files/neg/t4457_2.check b/test/files/neg/t4457_2.check
index d0be6d48ef..0a6532dffb 100644
--- a/test/files/neg/t4457_2.check
+++ b/test/files/neg/t4457_2.check
@@ -10,19 +10,19 @@ and  method aFunc in object ImplicitConvAmbiguity2 of type [A](a: ImplicitConvAm
 match argument types (Float)
     bFunc(aFunc(4F))
           ^
-t4457_2.scala:11: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NE[Float])
+t4457_2.scala:11: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NE[Float]) [quickfixable]
   implicit def conv1(i: Float) = new NE[Float]
                ^
-t4457_2.scala:12: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.TooManyListenersException])
+t4457_2.scala:12: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.TooManyListenersException]) [quickfixable]
   implicit def conv3(op: AA[java.util.TooManyListenersException]) = new N[java.util.TooManyListenersException]
                ^
-t4457_2.scala:13: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[Float])
+t4457_2.scala:13: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[Float]) [quickfixable]
   implicit def conv4(op: AA[Float]) = new N[Float]
                ^
-t4457_2.scala:14: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NZ[Float])
+t4457_2.scala:14: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.NZ[Float]) [quickfixable]
   implicit def conv7(i: Float) = new NZ[Float]
                ^
-t4457_2.scala:15: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.GregorianCalendar])
+t4457_2.scala:15: warning: Implicit definition should have explicit type (inferred ImplicitConvAmbiguity2.N[java.util.GregorianCalendar]) [quickfixable]
   implicit def conv5(e: BB[java.util.GregorianCalendar]) = new N[java.util.GregorianCalendar]
                ^
 5 warnings
diff --git a/test/files/neg/t4568.check b/test/files/neg/t4568.check
index 604948e41b..ecc3c46a03 100644
--- a/test/files/neg/t4568.check
+++ b/test/files/neg/t4568.check
@@ -1,7 +1,7 @@
 t4568.scala:8: error: recursive method isSubListOf needs result type
         case h :: t => y.contains(h) && (t.isSubListOf(y.drop(y.indexOf(h) + 1)))
                                            ^
-t4568.scala:2: warning: Implicit definition should have explicit type (inferred SubList.SubListable[A])
+t4568.scala:2: warning: Implicit definition should have explicit type (inferred SubList.SubListable[A]) [quickfixable]
   implicit def sublistable[A](x: List[A]) = new SubListable(x)
                ^
 1 warning
diff --git a/test/files/neg/t4851.check b/test/files/neg/t4851.check
index 1a4ffa6466..d61c1b6d14 100644
--- a/test/files/neg/t4851.check
+++ b/test/files/neg/t4851.check
@@ -13,19 +13,19 @@ S.scala:5: warning: adaptation of an empty argument list by inserting () is depr
 S.scala:6: warning: adapted the argument list to the expected 5-tuple: add additional parens instead
         signature: J(x: Object): J
   given arguments: 1, 2, 3, 4, 5
- after adaptation: new J((1, 2, 3, 4, 5): (Int, Int, Int, Int, Int))
+ after adaptation: new J((1, 2, 3, 4, 5): (Int, Int, Int, Int, Int)) [quickfixable]
   val x3 = new J(1, 2, 3, 4, 5)
            ^
 S.scala:8: warning: adapted the argument list to the expected 3-tuple: add additional parens instead
         signature: Some.apply[A](value: A): Some[A]
   given arguments: 1, 2, 3
- after adaptation: Some((1, 2, 3): (Int, Int, Int))
+ after adaptation: Some((1, 2, 3): (Int, Int, Int)) [quickfixable]
   val y1 = Some(1, 2, 3)
                ^
 S.scala:9: warning: adapted the argument list to the expected 3-tuple: add additional parens instead
         signature: Some(value: A): Some[A]
   given arguments: 1, 2, 3
- after adaptation: new Some((1, 2, 3): (Int, Int, Int))
+ after adaptation: new Some((1, 2, 3): (Int, Int, Int)) [quickfixable]
   val y2 = new Some(1, 2, 3)
            ^
 S.scala:11: warning: adaptation of an empty argument list by inserting () is deprecated: this is unlikely to be what you want
@@ -43,7 +43,7 @@ S.scala:12: warning: adaptation of an empty argument list by inserting () is dep
 S.scala:16: warning: adapted the argument list to the expected 3-tuple: add additional parens instead
         signature: Test.anyId(a: Any): Any
   given arguments: 1, 2, 3
- after adaptation: Test.anyId((1, 2, 3): (Int, Int, Int))
+ after adaptation: Test.anyId((1, 2, 3): (Int, Int, Int)) [quickfixable]
   val w1 = anyId(1, 2 ,3)
                 ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t4889.check b/test/files/neg/t4889.check
index e643dd1ffc..b5c38dc11b 100644
--- a/test/files/neg/t4889.check
+++ b/test/files/neg/t4889.check
@@ -1,7 +1,7 @@
 t4889.scala:19: error: could not find implicit value for parameter ma1: t4889.MatrixAdder[Int,[S]t4889.SparseMatrix[S]]
   m1.foo
      ^
-t4889.scala:14: warning: Implicit definition should have explicit type (inferred t4889.MatrixAdder[S,R])
+t4889.scala:14: warning: Implicit definition should have explicit type (inferred t4889.MatrixAdder[S,R]) [quickfixable]
   implicit def adderImplicit[S, R[s] <: Matrix[s, R]] = new MatrixAdder[S, R] {
                ^
 1 warning
diff --git a/test/files/neg/t5265a.check b/test/files/neg/t5265a.check
index f788868ec4..3018c51638 100644
--- a/test/files/neg/t5265a.check
+++ b/test/files/neg/t5265a.check
@@ -1,16 +1,16 @@
-t5265a.scala:7: warning: Implicit definition should have explicit type (inferred T[String])
+t5265a.scala:7: warning: Implicit definition should have explicit type (inferred T[String]) [quickfixable]
   implicit val tsMissing = new T[String] {}   // warn val in trait
                ^
-t5265a.scala:20: warning: Implicit definition should have explicit type (inferred T[String])
+t5265a.scala:20: warning: Implicit definition should have explicit type (inferred T[String]) [quickfixable]
   implicit val tsChild = new T[String] {}     // warn because inferred from RHS
                ^
-t5265a.scala:22: warning: Implicit definition should have explicit type (inferred Int)
+t5265a.scala:22: warning: Implicit definition should have explicit type (inferred Int) [quickfixable]
   implicit private[this] val pChild = 42      // also warn
                              ^
-t5265a.scala:27: warning: Implicit definition should have explicit type (inferred Int)
+t5265a.scala:27: warning: Implicit definition should have explicit type (inferred Int) [quickfixable]
   implicit private[this] val y = 42           // also warn
                              ^
-t5265a.scala:25: warning: Implicit definition should have explicit type (inferred T[String])
+t5265a.scala:25: warning: Implicit definition should have explicit type (inferred T[String]) [quickfixable]
   implicit val tsD = new T[String] {}         // warn val in class
                ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t5265b.check b/test/files/neg/t5265b.check
index 60dddb4ead..985f15935c 100644
--- a/test/files/neg/t5265b.check
+++ b/test/files/neg/t5265b.check
@@ -1,9 +1,9 @@
-t5265b.scala:7: error: Implicit definition must have explicit type (inferred T[String])
+t5265b.scala:7: error: Implicit definition must have explicit type (inferred T[String]) [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Missing.tsMissing
   implicit val tsMissing = new T[String] {}   // warn val in trait
                ^
-t5265b.scala:20: error: under -Xsource:3, inferred T[String]
+t5265b.scala:20: error: under -Xsource:3, inferred T[String] [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=Child.tsChild
   implicit val tsChild = new T[String] {}     // nowarn because inferred from overridden
diff --git a/test/files/neg/t5429.check b/test/files/neg/t5429.check
index bdd094a8fc..c312b46229 100644
--- a/test/files/neg/t5429.check
+++ b/test/files/neg/t5429.check
@@ -115,7 +115,7 @@ t5429.scala:73: error: stable, immutable value required to override:
 lazy val lazyvalue: Any (defined in class A0)
   override def lazyvalue = 2  // fail
                ^
-t5429.scala:75: warning: method without a parameter list overrides a method with a single empty one
+t5429.scala:75: warning: method without a parameter list overrides a method with a single empty one [quickfixable]
   override def emptyArg = 10  // override
                ^
 t5429.scala:76: error: method oneArg overrides nothing.
diff --git a/test/files/neg/t5606.check b/test/files/neg/t5606.check
index 6297ea6f0d..0d80bad04f 100644
--- a/test/files/neg/t5606.check
+++ b/test/files/neg/t5606.check
@@ -1,7 +1,7 @@
-t5606.scala:5: error: using `?` as a type name requires backticks.
+t5606.scala:5: error: using `?` as a type name requires backticks. [quickfixable]
 case class CaseTest_?[?](someData: String)
                       ^
-t5606.scala:23: error: using `?` as a type name requires backticks.
+t5606.scala:23: error: using `?` as a type name requires backticks. [quickfixable]
   def regress_?[F[?]]   = 2
                   ^
 t5606.scala:3: error: Top-level wildcard is not allowed
diff --git a/test/files/neg/t5715.check b/test/files/neg/t5715.check
index e2eaeb099a..5c6d40a1a9 100644
--- a/test/files/neg/t5715.check
+++ b/test/files/neg/t5715.check
@@ -1,4 +1,4 @@
-t5715.scala:19: warning: Wrap `then` in backticks to use it as an identifier, it will become a keyword in Scala 3.
+t5715.scala:19: warning: Wrap `then` in backticks to use it as an identifier, it will become a keyword in Scala 3. [quickfixable]
   object then                         // keyword
          ^
 t5715.scala:12: warning: class then in package example is deprecated (since 0.1): that was then
diff --git a/test/files/neg/t5728.check b/test/files/neg/t5728.check
index 72a0c02730..ac95d8e548 100644
--- a/test/files/neg/t5728.check
+++ b/test/files/neg/t5728.check
@@ -1,7 +1,7 @@
 t5728.scala:3: error: implicit classes must accept exactly one primary constructor parameter
   implicit class Foo
                  ^
-t5728.scala:5: warning: Implicit definition should have explicit type (inferred Test.Foo)
+t5728.scala:5: warning: Implicit definition should have explicit type (inferred Test.Foo) [quickfixable]
   implicit def Foo = new Foo
                ^
 1 warning
diff --git a/test/files/neg/t6436.check b/test/files/neg/t6436.check
index 2d74aa8c2a..b47959aca3 100644
--- a/test/files/neg/t6436.check
+++ b/test/files/neg/t6436.check
@@ -7,10 +7,10 @@ Note that implicit conversions are not applicable because they are ambiguous:
  are possible conversion functions from StringContext to ?{def q: ?}
   println(q"a")
           ^
-t6436.scala:2: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing})
+t6436.scala:2: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing}) [quickfixable]
   implicit def foo1(ctx: StringContext) = new { def q = ??? }
                ^
-t6436.scala:3: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing})
+t6436.scala:3: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing}) [quickfixable]
   implicit def foo2(ctx: StringContext) = new { def q = ??? }
                ^
 2 warnings
diff --git a/test/files/neg/t6436b.check b/test/files/neg/t6436b.check
index 8e33d7bb13..b325db5027 100644
--- a/test/files/neg/t6436b.check
+++ b/test/files/neg/t6436b.check
@@ -7,10 +7,10 @@ Note that implicit conversions are not applicable because they are ambiguous:
  are possible conversion functions from StringContext to ?{def q: ?}
   println(StringContext("a").q())
                        ^
-t6436b.scala:2: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing})
+t6436b.scala:2: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing}) [quickfixable]
   implicit def foo1(ctx: StringContext) = new { def q = ??? }
                ^
-t6436b.scala:3: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing})
+t6436b.scala:3: warning: Implicit definition should have explicit type (inferred AnyRef{def q: Nothing}) [quickfixable]
   implicit def foo2(ctx: StringContext) = new { def q = ??? }
                ^
 2 warnings
diff --git a/test/files/neg/t6567.check b/test/files/neg/t6567.check
index 552f4cbd48..c648ea7c67 100644
--- a/test/files/neg/t6567.check
+++ b/test/files/neg/t6567.check
@@ -1,4 +1,4 @@
-t6567.scala:8: warning: Implicit definition should have explicit type (inferred B)
+t6567.scala:8: warning: Implicit definition should have explicit type (inferred B) [quickfixable]
   implicit def a2b(a: A) = new B
                ^
 t6567.scala:10: warning: Suspicious application of an implicit view (Test.this.a2b) in the argument to Option.apply.
diff --git a/test/files/neg/t6667.check b/test/files/neg/t6667.check
index dfcad24c46..cfc38701fc 100644
--- a/test/files/neg/t6667.check
+++ b/test/files/neg/t6667.check
@@ -10,7 +10,7 @@ t6667.scala:9: error: ambiguous implicit values:
  match expected type C
   implicitly[C]       // ambiguity reported, rather than falling back to C.companion
             ^
-t6667.scala:3: warning: Implicit definition should have explicit type (inferred C)
+t6667.scala:3: warning: Implicit definition should have explicit type (inferred C) [quickfixable]
   implicit def companion = new C
                ^
 1 warning
diff --git a/test/files/neg/t692.check b/test/files/neg/t692.check
index 42e2a1b8f2..db773fb936 100644
--- a/test/files/neg/t692.check
+++ b/test/files/neg/t692.check
@@ -16,7 +16,7 @@ t692.scala:14: error: class Foo takes type parameters
 t692.scala:19: error: class Foo takes type parameters
   class Bar[A <: Foo](implicit tpeA : Type[A]) extends Foo;
                  ^
-t692.scala:11: warning: Implicit definition should have explicit type (inferred test3.this.FooType)
+t692.scala:11: warning: Implicit definition should have explicit type (inferred test3.this.FooType) [quickfixable]
   implicit def typeOfFoo = FooType();
                ^
 1 warning
diff --git a/test/files/neg/t712.check b/test/files/neg/t712.check
index 606e41f04d..c8931d9701 100644
--- a/test/files/neg/t712.check
+++ b/test/files/neg/t712.check
@@ -1,10 +1,10 @@
 t712.scala:10: error: overloaded method coerce needs result type
   implicit def coerce(p : ParentImpl) = p.self;
                                           ^
-t712.scala:3: warning: Implicit definition should have explicit type (inferred A.this.Node)
+t712.scala:3: warning: Implicit definition should have explicit type (inferred A.this.Node) [quickfixable]
   implicit def coerce(n : NodeImpl) = n.self;
                ^
-t712.scala:10: warning: Implicit definition should have explicit type
+t712.scala:10: warning: Implicit definition should have explicit type [quickfixable]
   implicit def coerce(p : ParentImpl) = p.self;
                ^
 2 warnings
diff --git a/test/files/neg/t7131.check b/test/files/neg/t7131.check
index 2c8a35025c..af8a5ce744 100644
--- a/test/files/neg/t7131.check
+++ b/test/files/neg/t7131.check
@@ -4,10 +4,10 @@ t7131.scala:21: error: type mismatch;
  Note: implicit method convertToSimpleMappable is not applicable here because it comes after the application point and it lacks an explicit result type.
         x.value.map(f)
                    ^
-t7131.scala:28: warning: Implicit definition should have explicit type (inferred ObservableValue.TraversableMappable[T,Container])
+t7131.scala:28: warning: Implicit definition should have explicit type (inferred ObservableValue.TraversableMappable[T,Container]) [quickfixable]
   implicit def convertToTraversableMappable[T, Container[X] <: Traversable[X]](x: ObservableValue[Container[T]]) =
                ^
-t7131.scala:43: warning: Implicit definition should have explicit type (inferred ObservableValue.NestedMappable[T,Container])
+t7131.scala:43: warning: Implicit definition should have explicit type (inferred ObservableValue.NestedMappable[T,Container]) [quickfixable]
   implicit def convertToSimpleMappable[T, Container[X] <: ObservableValue.HasMap[X, Container]](x: ObservableValue[Container[T]]) =
                ^
 2 warnings
diff --git a/test/files/neg/t7187-3.check b/test/files/neg/t7187-3.check
index ba739c5589..cd6125f0e9 100644
--- a/test/files/neg/t7187-3.check
+++ b/test/files/neg/t7187-3.check
@@ -13,12 +13,14 @@ t7187-3.scala:16: error: type mismatch;
  required: SamZero
   val t2Sam: SamZero = m2         // error, nilary methods don't eta-expand to SAM types
                        ^
-t7187-3.scala:27: error: Methods without a parameter list and by-name params can not be converted to functions as `m _`, write a function literal `() => m` instead
-  val t7 = m1 _ // error: eta-expanding a nullary method
-           ^
 t7187-3.scala:14: warning: An unapplied 0-arity method was eta-expanded (due to the expected type () => Any), rather than applied to `()`.
 Write m2() to invoke method m2, or change the expected type.
   val t2: () => Any  = m2   // eta-expanded with lint warning
                        ^
+t7187-3.scala:27: error: Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, write a function literal `() => m` instead [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=EtaExpand214.t7
+  val t7 = m1 _ // error: eta-expanding a nullary method
+           ^
 1 warning
 4 errors
diff --git a/test/files/neg/t7187-deprecation.check b/test/files/neg/t7187-deprecation.check
index ae8772e435..5b93c40b1c 100644
--- a/test/files/neg/t7187-deprecation.check
+++ b/test/files/neg/t7187-deprecation.check
@@ -13,17 +13,19 @@ t7187-deprecation.scala:20: error: type mismatch;
  required: SamZero
   val t2Sam: SamZero = m2         // error, nilary methods don't eta-expand to SAM types
                        ^
-t7187-deprecation.scala:31: error: Methods without a parameter list and by-name params can not be converted to functions as `m _`, write a function literal `() => m` instead
-  val t7 = m1 _ // error: eta-expanding a nullary method
-           ^
 t7187-deprecation.scala:24: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method m2,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   val t5 = m2 // warn: apply, ()-insertion
            ^
+t7187-deprecation.scala:31: error: Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, write a function literal `() => m` instead [quickfixable]
+Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
+Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=EtaExpand214.t7
+  val t7 = m1 _ // error: eta-expanding a nullary method
+           ^
 t7187-deprecation.scala:40: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method boom,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   a.boom // warning: apply, ()-insertion
     ^
 2 warnings
diff --git a/test/files/neg/t7187.check b/test/files/neg/t7187.check
index 696b7bbbaa..aa6ea7a2f2 100644
--- a/test/files/neg/t7187.check
+++ b/test/files/neg/t7187.check
@@ -28,13 +28,13 @@ Write foo() to invoke method foo, or change the expected type.
                        ^
 t7187.scala:13: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method foo,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   val t1c: () => Any = { val t = foo; t } // `()`-insertion because no expected type
                                  ^
-t7187.scala:21: warning: Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, write a function literal `() => m` instead
+t7187.scala:21: warning: Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, write a function literal `() => m` instead [quickfixable]
   val t2c: () => Any = bar _ // warning: eta-expanding a nullary method
                        ^
-t7187.scala:22: warning: Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, write a function literal `() => m` instead
+t7187.scala:22: warning: Methods without a parameter list and by-name params can no longer be converted to functions as `m _`, write a function literal `() => m` instead [quickfixable]
   val t2d: Any       = bar _ // warning: eta-expanding a nullary method
                        ^
 t7187.scala:26: warning: An unapplied 0-arity method was eta-expanded (due to the expected type () => Any), rather than applied to `()`.
diff --git a/test/files/neg/t7212.check b/test/files/neg/t7212.check
index 719dcd3e86..c1dada6f9e 100644
--- a/test/files/neg/t7212.check
+++ b/test/files/neg/t7212.check
@@ -13,13 +13,13 @@ t7212.scala:21: error: type mismatch;
  required: String
   val s: String = w.f
                     ^
-t7212.scala:5: warning: under -Xsource:3, inferred Object instead of String
+t7212.scala:5: warning: under -Xsource:3, inferred Object instead of String [quickfixable]
 class K extends T { def f = "" }
                         ^
-t7212.scala:11: warning: under -Xsource:3, inferred Object instead of String
+t7212.scala:11: warning: under -Xsource:3, inferred Object instead of String [quickfixable]
 class F extends T { val f = "" }
                         ^
-t7212.scala:17: warning: under -Xsource:3, inferred Object instead of String
+t7212.scala:17: warning: under -Xsource:3, inferred Object instead of String [quickfixable]
 trait V extends T { var f = "" }
                         ^
 3 warnings
diff --git a/test/files/neg/t729.check b/test/files/neg/t729.check
index 7680b2fdfa..6662f4bfc1 100644
--- a/test/files/neg/t729.check
+++ b/test/files/neg/t729.check
@@ -3,10 +3,10 @@ t729.scala:20: error: type mismatch;
  required: ScalaParserAutoEdit.this.NodeImpl(in trait ScalaParserAutoEdit)
       val yyy : NodeImpl = link.from;
                                 ^
-t729.scala:3: warning: Implicit definition should have explicit type (inferred Parser.this.Node)
+t729.scala:3: warning: Implicit definition should have explicit type (inferred Parser.this.Node) [quickfixable]
   implicit def coerce(n : NodeImpl) = n.self;
                ^
-t729.scala:14: warning: Implicit definition should have explicit type (inferred ScalaParserAutoEdit.this.Node)
+t729.scala:14: warning: Implicit definition should have explicit type (inferred ScalaParserAutoEdit.this.Node) [quickfixable]
   implicit def coerce(node : NodeImpl) = node.self;
                ^
 2 warnings
diff --git a/test/files/neg/t8015-ffb.check b/test/files/neg/t8015-ffb.check
index 306d7b6fbb..bacba62541 100644
--- a/test/files/neg/t8015-ffb.check
+++ b/test/files/neg/t8015-ffb.check
@@ -1,4 +1,4 @@
-t8015-ffb.scala:12: warning: side-effecting nullary methods are discouraged: suggest defining as `def w()` instead
+t8015-ffb.scala:12: warning: side-effecting nullary methods are discouraged: suggest defining as `def w()` instead [quickfixable]
   def w = { x\u000c() }       // ^L is colored blue on this screen, hardly visible
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t8035-removed.check b/test/files/neg/t8035-removed.check
index 42916a1090..0769b2bce3 100644
--- a/test/files/neg/t8035-removed.check
+++ b/test/files/neg/t8035-removed.check
@@ -19,7 +19,7 @@ t8035-removed.scala:4: warning: a type was inferred to be `AnyVal`; this may ind
 t8035-removed.scala:14: warning: adapted the argument list to the expected 2-tuple: add additional parens instead
         signature: List.::[B >: A](elem: B): List[B]
   given arguments: 42, 27
- after adaptation: List.::((42, 27): (Int, Int))
+ after adaptation: List.::((42, 27): (Int, Int)) [quickfixable]
   Nil.::(42, 27)      // yeswarn
         ^
 2 warnings
diff --git a/test/files/neg/t8322.check b/test/files/neg/t8322.check
index bc56230cd3..65a7a9298d 100644
--- a/test/files/neg/t8322.check
+++ b/test/files/neg/t8322.check
@@ -13,10 +13,10 @@ t8322.scala:19: error: type mismatch;
  required: scala.util.Either[?,?]
   Right(0).right.flatMap(_ => new String())
                               ^
-t8322.scala:15: warning: Implicit definition should have explicit type (inferred Writes[Seq[E]])
+t8322.scala:15: warning: Implicit definition should have explicit type (inferred Writes[Seq[E]]) [quickfixable]
   implicit def rw[E] = Writes[Seq[E]] { _ => "" }
                ^
-t8322.scala:17: warning: Implicit definition should have explicit type
+t8322.scala:17: warning: Implicit definition should have explicit type [quickfixable]
   implicit def wr[E] = jw(implicitly, implicitly)
                ^
 2 warnings
diff --git a/test/files/neg/t8417.check b/test/files/neg/t8417.check
index 396543dc47..8589c15dd4 100644
--- a/test/files/neg/t8417.check
+++ b/test/files/neg/t8417.check
@@ -1,13 +1,13 @@
 t8417.scala:7: warning: adapted the argument list to the expected 2-tuple: add additional parens instead
         signature: T.f(x: Any)(y: Any): String
   given arguments: "hello", "world"
- after adaptation: T.f(("hello", "world"): (String, String))
+ after adaptation: T.f(("hello", "world"): (String, String)) [quickfixable]
   def g = f("hello", "world")("holy", "moly")
            ^
 t8417.scala:7: warning: adapted the argument list to the expected 2-tuple: add additional parens instead
         signature: T.f(x: Any)(y: Any): String
   given arguments: "holy", "moly"
- after adaptation: T.f(("holy", "moly"): (String, String))
+ after adaptation: T.f(("holy", "moly"): (String, String)) [quickfixable]
   def g = f("hello", "world")("holy", "moly")
                              ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t8525.check b/test/files/neg/t8525.check
index 667cccc696..cb9756115b 100644
--- a/test/files/neg/t8525.check
+++ b/test/files/neg/t8525.check
@@ -1,13 +1,13 @@
 t8525.scala:9: warning: adapted the argument list to the expected 2-tuple: add additional parens instead
         signature: X.f(p: (Int, Int)): Int
   given arguments: 3, 4
- after adaptation: X.f((3, 4): (Int, Int))
+ after adaptation: X.f((3, 4): (Int, Int)) [quickfixable]
   def g = f(3, 4)       // adapted
            ^
 t8525.scala:11: warning: private[this] value name in class X shadows mutable name inherited from class Named. Changes to name will not be visible within class X; you may want to give them distinct names.
   override def toString = name // shadowing mutable var name
                           ^
-t8525.scala:10: warning: side-effecting nullary methods are discouraged: suggest defining as `def u()` instead
+t8525.scala:10: warning: side-effecting nullary methods are discouraged: suggest defining as `def u()` instead [quickfixable]
   def u: Unit = ()      // unitarian universalist
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t8610-arg.check b/test/files/neg/t8610-arg.check
index cfc1cf9e6c..50ae41a338 100644
--- a/test/files/neg/t8610-arg.check
+++ b/test/files/neg/t8610-arg.check
@@ -1,4 +1,4 @@
-t8610-arg.scala:10: warning: side-effecting nullary methods are discouraged: suggest defining as `def u()` instead
+t8610-arg.scala:10: warning: side-effecting nullary methods are discouraged: suggest defining as `def u()` instead [quickfixable]
   def u: Unit = ()      // unitarian universalist
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/t8610.check b/test/files/neg/t8610.check
index e640853b67..92aeda9690 100644
--- a/test/files/neg/t8610.check
+++ b/test/files/neg/t8610.check
@@ -4,13 +4,13 @@ t8610.scala:7: warning: possible missing interpolator: detected interpolated ide
 t8610.scala:9: warning: adapted the argument list to the expected 2-tuple: add additional parens instead
         signature: X.f(p: (Int, Int)): Int
   given arguments: 3, 4
- after adaptation: X.f((3, 4): (Int, Int))
+ after adaptation: X.f((3, 4): (Int, Int)) [quickfixable]
   def g = f(3, 4)       // adapted
            ^
 t8610.scala:11: warning: private[this] value name in class X shadows mutable name inherited from class Named. Changes to name will not be visible within class X; you may want to give them distinct names.
   override def toString = name // shadowing mutable var name
                           ^
-t8610.scala:10: warning: side-effecting nullary methods are discouraged: suggest defining as `def u()` instead
+t8610.scala:10: warning: side-effecting nullary methods are discouraged: suggest defining as `def u()` instead [quickfixable]
   def u: Unit = ()      // unitarian universalist
       ^
 error: No warnings can be incurred under -Werror.
diff --git a/test/files/neg/unicode-arrows-deprecation.check b/test/files/neg/unicode-arrows-deprecation.check
index 41ddafeb98..e01ae3a915 100644
--- a/test/files/neg/unicode-arrows-deprecation.check
+++ b/test/files/neg/unicode-arrows-deprecation.check
@@ -1,10 +1,10 @@
-unicode-arrows-deprecation.scala:4: warning: The unicode arrow `⇒` is deprecated, use `=>` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.
+unicode-arrows-deprecation.scala:4: warning: The unicode arrow `⇒` is deprecated, use `=>` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code. [quickfixable]
   val a: Int ⇒ Int = x ⇒ x
              ^
-unicode-arrows-deprecation.scala:4: warning: The unicode arrow `⇒` is deprecated, use `=>` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.
+unicode-arrows-deprecation.scala:4: warning: The unicode arrow `⇒` is deprecated, use `=>` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code. [quickfixable]
   val a: Int ⇒ Int = x ⇒ x
                        ^
-unicode-arrows-deprecation.scala:6: warning: The unicode arrow `←` is deprecated, use `<-` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.
+unicode-arrows-deprecation.scala:6: warning: The unicode arrow `←` is deprecated, use `<-` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code. [quickfixable]
   val b = for { x ← (1 to 10) } yield x
                   ^
 unicode-arrows-deprecation.scala:8: warning: method → in class ArrowAssoc is deprecated (since 2.13.0): Use `->` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.
diff --git a/test/files/neg/using-source3.check b/test/files/neg/using-source3.check
index 7d015f5a2d..5940a51cdc 100644
--- a/test/files/neg/using-source3.check
+++ b/test/files/neg/using-source3.check
@@ -2,7 +2,7 @@ using-source3.scala:14: error: reference to f is ambiguous;
 it is both defined in the enclosing class D and inherited in the enclosing class E as method f (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.f`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=D.E.g
     def g = f
diff --git a/test/files/neg/using-source3b.check b/test/files/neg/using-source3b.check
index 58e48a6ff3..115116ca9d 100644
--- a/test/files/neg/using-source3b.check
+++ b/test/files/neg/using-source3b.check
@@ -2,7 +2,7 @@ using-source3b.scala:13: error: reference to f is ambiguous;
 it is both defined in the enclosing class D and inherited in the enclosing class E as method f (defined in class C)
 In Scala 2, symbols inherited from a superclass shadow symbols defined in an outer scope.
 Such references are ambiguous in Scala 3. To continue using the inherited symbol, write `this.f`.
-Or use `-Wconf:msg=legacy-binding:s` to silence this warning.
+Or use `-Wconf:msg=legacy-binding:s` to silence this warning. [quickfixable]
 Scala 3 migration messages are errors under -Xsource:3. Use -Wconf / @nowarn to filter them or add -Xmigration to demote them to warnings.
 Applicable -Wconf / @nowarn filters for this fatal warning: msg=<part of the message>, cat=scala3-migration, site=D.E.g
     def g = f
diff --git a/test/files/neg/warn-unused-privates.scala b/test/files/neg/warn-unused-privates.scala
index 999c703b2d..30fad17595 100644
--- a/test/files/neg/warn-unused-privates.scala
+++ b/test/files/neg/warn-unused-privates.scala
@@ -1,5 +1,5 @@
 //
-// scalac: -deprecation -Ywarn-unused:privates -Xfatal-warnings
+// scalac: -deprecation -Wunused:privates -Xfatal-warnings
 //
 class Bippy(a: Int, b: Int) {
   private def this(c: Int) = this(c, c)           // warn
@@ -260,3 +260,7 @@ trait `short comings` {
     17
   }
 }
+
+class `issue 12600 ignore abstract types` {
+  type Abs
+}
diff --git a/test/files/pos/annotated-outer.scala b/test/files/pos/annotated-outer.scala
new file mode 100644
index 0000000000..86f6fe675a
--- /dev/null
+++ b/test/files/pos/annotated-outer.scala
@@ -0,0 +1,12 @@
+// scalac: -Werror
+object Test {
+  trait MySet[A]
+  trait MyMap[K, +V] {
+    class Keys extends MySet[K]
+  }
+
+  def areKeys[A](xs: MySet[A]) = xs match {
+    case _: (MyMap[A, _] @unchecked)#Keys => true
+    case _ => false
+  }
+}
diff --git a/test/files/pos/t12600.scala b/test/files/pos/t12600.scala
new file mode 100644
index 0000000000..fc86c2a9fc
--- /dev/null
+++ b/test/files/pos/t12600.scala
@@ -0,0 +1,6 @@
+// scalac: -Werror -Wunused:_
+class Private {
+  private type Curry[A] = { type T[B] = Either[A, B] }
+  def m2[T[A]]: Unit = ()
+  def f() = m2[Curry[Int]#T]
+}
diff --git a/test/files/pos/t12851/C_2.scala b/test/files/pos/t12851/C_2.scala
new file mode 100644
index 0000000000..4e5334029e
--- /dev/null
+++ b/test/files/pos/t12851/C_2.scala
@@ -0,0 +1,2 @@
+// scalac: -Werror
+class C extends T2
diff --git a/test/files/pos/t12851/T_1.scala b/test/files/pos/t12851/T_1.scala
new file mode 100644
index 0000000000..88c0c5d932
--- /dev/null
+++ b/test/files/pos/t12851/T_1.scala
@@ -0,0 +1,7 @@
+
+trait T1 {
+  def f: Int
+}
+trait T2 extends T1 {
+  def f() = 42
+}
diff --git a/test/files/pos/t12851c/ScalaNumber.java b/test/files/pos/t12851c/ScalaNumber.java
new file mode 100644
index 0000000000..5a6a8a7c65
--- /dev/null
+++ b/test/files/pos/t12851c/ScalaNumber.java
@@ -0,0 +1,20 @@
+/*
+ * Scala (https://www.scala-lang.org)
+ *
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala.math;
+
+/** A marker class for Number types introduced by Scala
+ */
+public abstract class ScalaNumber extends java.lang.Number {
+  protected abstract boolean isWhole();
+  public abstract Object underlying();
+}
diff --git a/test/files/pos/t12851c/ScalaNumericConversions.scala b/test/files/pos/t12851c/ScalaNumericConversions.scala
new file mode 100644
index 0000000000..c53f2f225a
--- /dev/null
+++ b/test/files/pos/t12851c/ScalaNumericConversions.scala
@@ -0,0 +1,30 @@
+//> using option -Werror
+/*
+ * Scala (https://www.scala-lang.org)
+ *
+ * Copyright EPFL and Lightbend, Inc.
+ *
+ * Licensed under Apache License 2.0
+ * (http://www.apache.org/licenses/LICENSE-2.0).
+ *
+ * See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ */
+
+package scala
+package math
+
+/** A slightly more specific conversion trait for classes which
+ *  extend ScalaNumber (which excludes value classes.)
+ */
+trait ScalaNumericConversions extends ScalaNumber with ScalaNumericAnyConversions {
+  def underlying: Object
+}
+
+/** Conversions which present a consistent conversion interface
+ *  across all the numeric types, suitable for use in value classes.
+ */
+trait ScalaNumericAnyConversions extends Any {
+  /** @return `'''true'''` if this number has no decimal component, `'''false'''` otherwise. */
+  def isWhole: Boolean
+}
diff --git a/test/files/run/infixPostfixAttachments.check b/test/files/run/infixPostfixAttachments.check
index 98a619ce54..248f5bfc62 100644
--- a/test/files/run/infixPostfixAttachments.check
+++ b/test/files/run/infixPostfixAttachments.check
@@ -1,11 +1,11 @@
 newSource1.scala:15: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method d,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   def t6 = this d
                 ^
 newSource1.scala:16: warning: Auto-application to `()` is deprecated. Supply the empty argument list `()` explicitly to invoke method d,
 or remove the empty argument list from its definition (Java-defined methods are exempt).
-In Scala 3, an unapplied method like this will be eta-expanded into a function.
+In Scala 3, an unapplied method like this will be eta-expanded into a function. [quickfixable]
   def t7 = this.d
                 ^
 t1 this.a(0) List(InfixAttachment)
diff --git a/test/files/run/literals.check b/test/files/run/literals.check
index 62d884bbe3..57c621c4d3 100644
--- a/test/files/run/literals.check
+++ b/test/files/run/literals.check
@@ -1,12 +1,12 @@
-literals.scala:63: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead
+literals.scala:63: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead [quickfixable]
     check_success("1l == 1L", 1l, 1L)
                                ^
-literals.scala:64: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead
+literals.scala:64: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead [quickfixable]
     check_success("1L == 1l", 1L, 1l)
                                    ^
-literals.scala:65: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead
+literals.scala:65: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead [quickfixable]
     check_success("1.asInstanceOf[Long] == 1l", 1.asInstanceOf[Long], 1l)
                                                                        ^
-literals.scala:112: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead
+literals.scala:112: warning: Lowercase el for long is not recommended because it is easy to confuse with numeral 1; use uppercase L instead [quickfixable]
     check_success("1l.asInstanceOf[Double] == 1.0", 1l.asInstanceOf[Double], 1.0)
                                                      ^
diff --git a/test/files/run/reify_ann5.check b/test/files/run/reify_ann5.check
index a7ab8b0e0a..93a8cffa27 100644
--- a/test/files/run/reify_ann5.check
+++ b/test/files/run/reify_ann5.check
@@ -1,6 +1,6 @@
 {
   class C extends AnyRef {
-    @new inline @beanGetter() @new BeanProperty() <paramaccessor> val x: Int = _;
+    @new BeanProperty() @new inline @beanGetter() @new BeanProperty() <paramaccessor> val x: Int = _;
     def <init>(x: Int) = {
       super.<init>();
       ()
@@ -10,13 +10,13 @@
 }
 {
   class C extends AnyRef {
-    @scala.beans.BeanProperty <paramaccessor> private[this] val x: Int = _;
+    @scala.beans.BeanProperty @scala.beans.BeanProperty <paramaccessor> private[this] val x: Int = _;
     <stable> <accessor> <paramaccessor> def x: Int = C.this.x;
     def <init>(x: Int): C = {
       C.super.<init>();
       ()
     };
-    @inline @scala.annotation.meta.beanGetter @<notype> def getX(): Int = C.this.x
+    @scala.beans.BeanProperty @inline @scala.annotation.meta.beanGetter @scala.beans.BeanProperty def getX(): Int = C.this.x
   };
   ()
 }
diff --git a/test/files/run/repl-errors.check b/test/files/run/repl-errors.check
index 836a149112..12cc4c32e6 100644
--- a/test/files/run/repl-errors.check
+++ b/test/files/run/repl-errors.check
@@ -5,7 +5,7 @@ scala> '\060'
 
 scala> def foo() { }
                  ^
-       warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `foo`'s return type
+       warning: procedure syntax is deprecated: instead, add `: Unit =` to explicitly declare `foo`'s return type [quickfixable]
 def foo(): Unit
 
 scala> @annotation.nowarn def sshhh() { }
diff --git a/test/files/run/t11402.check b/test/files/run/t11402.check
index 2ccfa8be1b..7a11246f48 100644
--- a/test/files/run/t11402.check
+++ b/test/files/run/t11402.check
@@ -6,7 +6,7 @@ scala> def f = {
 }
          val x = 'abc
                  ^
-On line 2: warning: symbol literal is deprecated; use Symbol("abc") instead
+On line 2: warning: symbol literal is deprecated; use Symbol("abc") instead [quickfixable]
 def f: String
 
 scala> :quit
diff --git a/test/files/run/t8610.check b/test/files/run/t8610.check
index 24341b6648..9fc78e3133 100644
--- a/test/files/run/t8610.check
+++ b/test/files/run/t8610.check
@@ -1,7 +1,7 @@
 t8610.scala:8: warning: adapted the argument list to the expected 2-tuple: add additional parens instead
         signature: X.f(p: (Int, Int)): Int
   given arguments: 3, 4
- after adaptation: X.f((3, 4): (Int, Int))
+ after adaptation: X.f((3, 4): (Int, Int)) [quickfixable]
   def g = f(3, 4)       // adapted
            ^
 Hi, $name
diff --git a/test/junit/scala/collection/FactoriesTest.scala b/test/junit/scala/collection/FactoriesTest.scala
index d08fac0759..3ddab2d37e 100644
--- a/test/junit/scala/collection/FactoriesTest.scala
+++ b/test/junit/scala/collection/FactoriesTest.scala
@@ -1,9 +1,9 @@
 package scala.collection
 
-import org.junit.Assert.{assertEquals, assertSame, assertTrue}
+import org.junit.Assert.{assertEquals, assertFalse, assertSame, assertTrue}
+import org.junit.Test
 
 import scala.collection.mutable.ArrayBuffer
-import org.junit.{Assert, Test}
 
 import scala.collection.{immutable => im}
 
@@ -16,7 +16,7 @@ class FactoriesTest {
     def cloneCollection[A, C](xs: Iterable[A])(implicit bf: BuildFrom[xs.type, A, C]): C =
       bf.fromSpecific(xs)(xs)
 
-    Assert.assertEquals("ArrayBuffer", cloneCollection(seq).collectionClassName)
+    assertEquals("ArrayBuffer", cloneCollection(seq).collectionClassName)
   }
 
   @Test def factoryIgnoresSourceCollectionFactory(): Unit = {
@@ -24,7 +24,7 @@ class FactoriesTest {
     def cloneElements[A, C](xs: Iterable[A])(cb: Factory[A, C]): C =
       cb.fromSpecific(xs)
 
-    Assert.assertEquals("List", cloneElements(seq)(Seq).collectionClassName)
+    assertEquals("List", cloneElements(seq)(Seq).collectionClassName)
   }
 
   def apply(factory: IterableFactory[Iterable]): Unit = {
@@ -203,8 +203,8 @@ class FactoriesTest {
       im.Set(1),
       im.HashSet("a", "b", "c"),
       im.ListSet('c', 'd'),
-      im.Map("a" -> 1, "b" -> 1, "c" -> 1).keySet,
-      im.HashMap("a" -> 1, "b" -> 1, "c" -> 1).keySet,
+      im.Map("a" -> 1, "b" -> 1, "c" -> 1).keySet,      // MapOps$ImmutableKeySet
+      im.HashMap("a" -> 1, "b" -> 1, "c" -> 1).keySet,  // HashKeySet
     )
 
     sortedFactoryFromIterableOnceReturnsSameReference(SortedSet, im.SortedSet)(
@@ -225,8 +225,9 @@ class FactoriesTest {
 
     mapFactoryFromIterableOnceReturnsSameReference(Map, im.Map)(im.Map(1 -> 2), im.HashMap(1 -> 2))
     mapFactoryFromIterableOnceReturnsSameReference(im.HashMap)(im.HashMap(1 -> 2))
-    mapFactoryFromIterableOnceReturnsSameReference(Map, im.Map)(im.IntMap(1 -> 2))
-    mapFactoryFromIterableOnceReturnsSameReference(Map, im.Map)(im.LongMap(1L -> 2))
+    // unsound due to widening, scala/bug#12745
+    //mapFactoryFromIterableOnceReturnsSameReference(Map, im.Map)(im.IntMap(1 -> 2))
+    //mapFactoryFromIterableOnceReturnsSameReference(Map, im.Map)(im.LongMap(1L -> 2))
 
     mapFactoryFromIterableOnceReturnsSameReference(im.SeqMap, Map, im.Map)(
       im.ListMap(1 -> 2),
@@ -291,6 +292,74 @@ class FactoriesTest {
 
   }
 
+  @Test def `custom set requires rebuild`: Unit = {
+    import scala.collection.immutable.{Set, SortedSet}
+    def testSame(xs: Set[Int], ys: Set[Any]): Boolean = {
+      assertFalse(ys("oops"))
+      assertFalse(ys.contains("oops"))
+      xs.eq(ys)
+    }
+    val s1 = Set(42)
+    assertTrue(testSame(s1, Set.from(s1)))
+    val ss = SortedSet(42)
+    assertFalse(testSame(ss, Set.from(ss)))
+
+    class Custom extends Set[Int] {
+      // Members declared in scala.collection.IterableOnce
+      def iterator: Iterator[Int] = Iterator.empty // implements `def iterator: Iterator[A]`
+
+      // Members declared in scala.collection.SetOps
+      def contains(elem: Int): Boolean = ??? // implements `def contains(elem: A): Boolean`
+
+      // Members declared in scala.collection.immutable.SetOps
+      def excl(elem: Int): scala.collection.immutable.Set[Int] = ??? // implements `def excl(elem: A): C`
+      def incl(elem: Int): scala.collection.immutable.Set[Int] = ??? // implements `def incl(elem: A): C`
+    }
+    val custom = new Custom
+    assertFalse(testSame(custom, Set.from(custom)))
+  }
+
+  @Test def `select maps do not require rebuild`: Unit = {
+    import scala.collection.immutable.{IntMap, ListMap, SeqMap, SortedMap, TreeSeqMap, VectorMap}
+
+    object X {
+      val iter: Iterable[(Any, String)] = List(1, 2, 3, 4, 5).map(i => i -> i.toString).to(SortedMap.sortedMapFactory)
+      val set: Map[Any, String] = Map.from(iter)
+    }
+
+    // where ys is constructed from(xs), verify no CEE, return true if same
+    def testSame(xs: Map[Int, String], ys: Map[Any, String]): Boolean = {
+      assertTrue(ys.get("oops").isEmpty)
+      assertFalse(ys.contains("oops"))
+      xs.eq(ys)
+    }
+    assertFalse(X.set.contains("oops")) // was CCE
+    // exercise small Maps
+    1.to(5).foreach { n =>
+      val m = Map(1.to(n).map(i => i -> i.toString): _*)
+      assertTrue(testSame(m, Map.from(m)))
+    }
+    // other Maps that don't require rebuilding
+    val listMap = ListMap(42 -> "four two")
+    assertTrue(testSame(listMap, Map.from(listMap)))
+    val treeSeqMap = TreeSeqMap(42 -> "four two")
+    assertTrue(testSame(treeSeqMap, Map.from(treeSeqMap)))
+    val vectorMap = VectorMap(42 -> "four two")
+    assertTrue(testSame(vectorMap, Map.from(vectorMap)))
+    val seqMap = SeqMap.empty[Int, String] + (42 -> "four two")
+    assertTrue(testSame(seqMap, Map.from(seqMap)))
+    // require rebuilding
+    val sordid = SortedMap(42 -> "four two")
+    assertFalse(testSame(sordid, Map.from(sordid)))
+    val defaulted = listMap.withDefault(_.toString * 2)
+    assertFalse(testSame(defaulted, Map.from(defaulted)))   // deoptimized, see desorted
+    val desorted = sordid.withDefault(_.toString * 2)
+    assertFalse(testSame(desorted, Map.from(desorted)))
+
+    assertTrue(Map.from(IntMap(42 -> "once", 27 -> "upon"): Iterable[(Any, String)]).get("a time").isEmpty)
+  }
+
+// java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Integer
 
   implicitly[Factory[Char, String]]
   implicitly[Factory[Char, Array[Char]]]
diff --git a/test/junit/scala/collection/ValueClassSeqOpsTest.scala b/test/junit/scala/collection/ValueClassSeqOpsTest.scala
new file mode 100644
index 0000000000..3ac7ecc682
--- /dev/null
+++ b/test/junit/scala/collection/ValueClassSeqOpsTest.scala
@@ -0,0 +1,27 @@
+package scala.collection
+
+import org.junit.Test
+
+class ValueClassSeqOpsImpl(private val array: Array[Int]) extends AnyVal with IterableOnce[Int] with SeqOps[Int, Seq, ValueClassSeqOpsImpl] {
+  def apply(i: Int): Int = array(i)
+  def length: Int = array.length
+  def iterator: Iterator[Int] = array.iterator
+  def toIterable: Iterable[Int] = array.toIndexedSeq
+  protected def coll: ValueClassSeqOpsImpl = this
+  protected def fromSpecific(coll: IterableOnce[Int]): ValueClassSeqOpsImpl =
+    new ValueClassSeqOpsImpl(coll.iterator.toArray)
+  def iterableFactory: IterableFactory[Seq] = Seq
+  protected def newSpecificBuilder: mutable.Builder[Int, ValueClassSeqOpsImpl] =
+    Array.newBuilder[Int].mapResult(new ValueClassSeqOpsImpl(_))
+  override def toString = mkString("ValueClassSeqOpsImpl(", ", ", ")")
+}
+
+class ValueClassSeqOpsTest {
+  @Test
+  def testPermutation(): Unit = {
+    val array = Array(1, 2, 3)
+    val wrapper = new ValueClassSeqOpsImpl(array)
+    val permutations = wrapper.permutations.toSeq.map(_.toSeq)
+    assert(permutations == List(1, 2, 3).permutations.toSeq)
+  }
+}
diff --git a/test/junit/scala/collection/immutable/LazyListLazinessTest.scala b/test/junit/scala/collection/immutable/LazyListLazinessTest.scala
index f3c4691aa4..4fa9aba6a7 100644
--- a/test/junit/scala/collection/immutable/LazyListLazinessTest.scala
+++ b/test/junit/scala/collection/immutable/LazyListLazinessTest.scala
@@ -14,7 +14,7 @@ class LazyListLazinessTest {
   @Test
   def opLazinessChecker_correctness(): Unit = {
     val checker = new OpLazinessChecker
-    val illegalState = (s: String) => new IllegalStateException("sanity check failed: " + s)
+    val illegalState = (s: String) => new IllegalStateException("correctness check failed: " + s)
 
     // check that none start evaluated
     checker.assertAll(evaluated = false, illegalState)
diff --git a/test/junit/scala/collection/immutable/MapTest.scala b/test/junit/scala/collection/immutable/MapTest.scala
index 28b6fba9fb..6ad57836e7 100644
--- a/test/junit/scala/collection/immutable/MapTest.scala
+++ b/test/junit/scala/collection/immutable/MapTest.scala
@@ -1,10 +1,8 @@
 package scala.collection.immutable
 
-import org.junit.Assert.assertEquals
+import org.junit.Assert.{assertEquals, assertSame, assertTrue}
 import org.junit.Test
 
-import scala.annotation.nowarn
-
 class MapTest {
 
   @Test def builderCompare1(): Unit = {
@@ -144,10 +142,17 @@ class MapTest {
     }
   }
 
-  @Test @nowarn("cat=deprecation")
+  @Test @deprecated("Tests deprecated API", since="2.13.11")
   def t12699(): Unit = {
     val m1: HashMap[Int, Int] = HashMap(1 -> 1)
-    assertEquals(7, m1.+(elem1 = 2 -> 2, elem2 = 3 -> 3, elems = List( 4 -> 4, 5 -> 5, 6 -> 6, 7 -> 7): _*).size)
+    assertEquals(7, m1.+(elem1 = 2 -> 2, elem2 = 3 -> 3, elems = List(4 -> 4, 5 -> 5, 6 -> 6, 7 -> 7): _*).size)
     assertEquals(7, m1.+(2 -> 2, 3 -> 3, 4 -> 4, 5 -> 5, 6 -> 6, 7 -> 7).size)
   }
+
+  @Test def `t10496 unsound toMap`: Unit = {
+    val t = Map(42 -> 27)
+    assertSame(t, t.toMap[Any, Any])
+    assertTrue(t.toMap[Any, Any].get("hi").isEmpty)
+    assertTrue(TreeMap((1, 2)).toMap[Any, Any].get("hi").isEmpty) // was: CCE
+  }
 }
diff --git a/test/junit/scala/collection/immutable/SetTest.scala b/test/junit/scala/collection/immutable/SetTest.scala
index 6bc08f19d9..a43a1309aa 100644
--- a/test/junit/scala/collection/immutable/SetTest.scala
+++ b/test/junit/scala/collection/immutable/SetTest.scala
@@ -3,7 +3,7 @@ package scala.collection.immutable
 // "Disabled string conversions so as not to get confused!"
 import scala.Predef.{any2stringadd => _, _}
 
-import org.junit.Assert._
+import org.junit.Assert.{assertEquals, assertNotSame, assertSame, assertTrue}
 import org.junit.Test
 
 class SetTest {
@@ -12,7 +12,7 @@ class SetTest {
     
     def any[A](set: Set[A]): Set[Any] = {
       val anyset = set.toSet[Any]
-      assert((anyset + "fish") contains "fish")
+      assertTrue((anyset + "fish") contains "fish")
       anyset
     }
 
@@ -25,8 +25,8 @@ class SetTest {
       val s2 = si + i
       val s1a = any(s1)
       val s2a = any(s2)
-      assert(s1 eq s1a)
-      assert(s2 eq s2a)
+      assertSame(s1, s1a)
+      assertSame(s2, s2a)
       si = s2
     }
 
@@ -35,7 +35,7 @@ class SetTest {
     val bitsets = Seq(BitSet.empty, BitSet(23), BitSet(23, 99), BitSet(23, 99, 141))
     bitsets.foreach{ b =>
       val ba = any(b)
-      assert(b ne ba)
+      assertNotSame(b, ba)
       assertEquals(b, ba)
     }
 
@@ -43,13 +43,13 @@ class SetTest {
     // does not rebuild itself on widening by toSet
     val hashset = HashSet(1, 3, 5, 7)
     val hashseta = any(hashset)
-    assert(hashset eq hashseta)
+    assertSame(hashset, hashseta)
 
     // Make sure ListSet does not rebuild itself on widening by toSet
     // (Covers Node also, since it subclasses ListSet)
     val listset = ListSet(1, 3, 5, 7)
     val listseta = any(listset)
-    assert(listset eq listseta)
+    assertSame(listset, listseta)
 
     // Make sure SortedSets correctly rebuild themselves on widening with toSet
     // Covers TreeSet and keySet of SortedMap also
@@ -59,7 +59,7 @@ class SetTest {
     )
     sortedsets.foreach{ set => 
       val seta = any(set)
-      assert(set ne seta)
+      assertNotSame(set, seta)
       assertEquals(set, seta)
     }
 
@@ -69,13 +69,13 @@ class SetTest {
       val Mon, Tue, Wed, Thu, Fri, Sat, Sun = Value
     }
     val valuesa = any(WeekDay.values)
-    assert(WeekDay.values ne valuesa)
+    assertNotSame(WeekDay.values, valuesa)
     assertEquals(WeekDay.values, valuesa)
 
     // Make sure regular Map keySets do not rebuild themselves on widening with toSet
     val mapset = Map(1 -> "cod", 2 -> "herring").keySet
     val mapseta = any(mapset)
-    assert(mapset eq mapseta)
+    assertSame(mapset, mapseta) // WIP see Set.from
   }
 
   @deprecated("Uses deprecated API", since="2.13")
@@ -172,5 +172,4 @@ class SetTest {
     val expected = scala.collection.immutable.BitSet(64)
     assertEquals(diff, expected)
   }
-
 }
diff --git a/test/junit/scala/tools/nsc/QuickfixTest.scala b/test/junit/scala/tools/nsc/QuickfixTest.scala
new file mode 100644
index 0000000000..7b0beb5323
--- /dev/null
+++ b/test/junit/scala/tools/nsc/QuickfixTest.scala
@@ -0,0 +1,84 @@
+package scala.tools.nsc
+
+import org.junit.Assert._
+import org.junit.Test
+
+import java.nio.file.Files
+import scala.reflect.internal.util.BatchSourceFile
+import scala.reflect.io.AbstractFile
+import scala.tools.testkit.BytecodeTesting
+import scala.tools.testkit.ReleasablePath._
+import scala.util.Using
+
+class QuickfixTest extends BytecodeTesting {
+  def testQuickfix(a: String, b: String, args: String): Unit = if (!scala.util.Properties.isWin) {
+    Using.resource(Files.createTempFile("unitSource", "scala")) { src =>
+      Files.write(src, a.getBytes)
+      val c = BytecodeTesting.newCompiler(extraArgs = args)
+      val r = c.newRun()
+      val f = AbstractFile.getFile(src.toFile.getAbsolutePath)
+      r.compileSources(List(new BatchSourceFile(f)))
+      assertEquals(b, new String(Files.readAllBytes(src)))
+    }
+  }
+
+  def comp(args: String) = BytecodeTesting.newCompiler(extraArgs = args)
+
+  @Test def multipleRewrites(): Unit = {
+    // procedure syntax is a parser warning
+    // "val" in for-comprehension is a parser error
+    // auto-application is fixed only in 2nd compilation - parser error prevents later phase from running
+    val a =
+      """class C {
+        |  def f { println }
+        |  def g(xs: List[String]) = for (val x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    val b =
+      """class C {
+        |  def f: Unit = { println }
+        |  def g(xs: List[String]) = for (x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    val c =
+      """class C {
+        |  def f: Unit = { println() }
+        |  def g(xs: List[String]) = for (x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    testQuickfix(a, b, "-deprecation -quickfix:any")
+    testQuickfix(b, c, "-deprecation -quickfix:any")
+  }
+
+  @Test def filters(): Unit = {
+    val a =
+      """class C {
+        |  def f { println }
+        |  def g(xs: List[String]) = for (val x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    val b =
+      """class C {
+        |  def f { println }
+        |  def g(xs: List[String]) = for (x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    val c =
+      """class C {
+        |  def f { println() }
+        |  def g(xs: List[String]) = for (x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    val d =
+      """class C {
+        |  def f: Unit = { println() }
+        |  def g(xs: List[String]) = for (x <- xs) yield x.trim
+        |}
+        |""".stripMargin
+    testQuickfix(a, b, "-deprecation -quickfix:msg=comprehension")
+    testQuickfix(b, b, "-deprecation -quickfix:msg=teddy")
+    testQuickfix(b, c, "-deprecation -quickfix:msg=Auto-application")
+    testQuickfix(c, c, "-quickfix:cat=deprecation") // without -deprecation, the warning is not shown and not rewritten
+    testQuickfix(c, d, "-deprecation -quickfix:cat=deprecation")
+  }
+}
diff --git a/test/junit/scala/tools/nsc/reporters/AbstractCodeActionTest.scala b/test/junit/scala/tools/nsc/reporters/AbstractCodeActionTest.scala
index fef6a18edc..bb1e0e77bd 100644
--- a/test/junit/scala/tools/nsc/reporters/AbstractCodeActionTest.scala
+++ b/test/junit/scala/tools/nsc/reporters/AbstractCodeActionTest.scala
@@ -5,56 +5,57 @@ import org.junit.Assert._
 
 import scala.reflect.internal.util.CodeAction
 import scala.tools.testkit.BytecodeTesting
+import scala.tools.testkit.Compiler
 
 abstract class AbstractCodeActionTest extends BytecodeTesting {
-  override def compilerArgs: String = "-Ystop-after:typer -Yvalidate-pos:typer -Yrangepos -deprecation -Xsource:3"
-  protected def reporter = compiler.global.reporter.asInstanceOf[StoreReporter]
-
   @Test
-  def testProcedureSyntaxDecl(): Unit =
+  def procedureSyntax(): Unit =
     assertCodeSuggestion(
       """trait Test {
         |  def foo
         |  def bar;
-        |  def pub { print() }
-        |  def club{ print() }
-        |  def saloon = { print() }
+        |  def pub { println() }
+        |  def club{ println() }
+        |  def saloon = { println() }
         |}""".stripMargin,
       """trait Test {
         |  def foo: Unit
         |  def bar: Unit;
-        |  def pub: Unit = { print() }
-        |  def club: Unit ={ print() }
-        |  def saloon = { print() }
+        |  def pub: Unit = { println() }
+        |  def club: Unit ={ println() }
+        |  def saloon = { println() }
         |}""".stripMargin,
-    )
+      // disable lint to avoid conflicting patches with `nullaryUnit`
+      BytecodeTesting.newCompiler(extraArgs = compilerArgs.replaceAll("-Xlint", "")))
 
   @Test
-  def testGreatParenInsert(): Unit = {
+  def autoApplication(): Unit = {
     assertCodeSuggestion(
-      """trait Test {
+      """import scala.language.postfixOps
+        |trait Test {
         |  def foo = {
         |    println
         |    Predef.println
         |    toString + this.toString
         |  }
-        |  def bar: Unit = Predef println()
+        |  def bar: Unit = Predef println
         |}
       """.stripMargin,
-      """trait Test {
+      """import scala.language.postfixOps
+        |trait Test {
         |  def foo = {
         |    println()
         |    Predef.println()
         |    toString + this.toString
         |  }
-        |  def bar: Unit = Predef println()
+        |  def bar(): Unit = Predef println()
         |}
       """.stripMargin,
     )
   }
 
   @Test
-  def testValInFor(): Unit =
+  def valInFor(): Unit =
     assertCodeSuggestion(
       """trait Test {
         |  def foo: Unit = {
@@ -91,9 +92,90 @@ abstract class AbstractCodeActionTest extends BytecodeTesting {
     )
   }
 
-  def assertCodeSuggestion(original: String, expected: String): Unit = {
-    val run = compiler.newRun()
-    run.compileSources(compiler.global.newSourceFile(original) :: Nil)
+  @Test
+  def unitLiteralType(): Unit = {
+    assertCodeSuggestion("class C { def f: () = () }", "class C { def f: Unit = () }")
+    assertCodeSuggestion("class C { def f(a: Any) = a match { case _: () => 0 } }", "class C { def f(a: Any) = a match { case _: Unit => 0 } }")
+  }
+
+  @Test
+  def constructorProcedureSyntax(): Unit = {
+    assertCodeSuggestion("class C { def this(x: Int) { this() } }", "class C { def this(x: Int) = { this() } }")
+  }
+
+  @Test
+  def symbolLiteral(): Unit = {
+    assertCodeSuggestion("class C { 'hai }", """class C { Symbol("hai") }""")
+  }
+
+  @Test
+  def unaryNilary(): Unit = {
+    assertCodeSuggestion("class C { def unary_-() = 1 }", "class C { def unary_- = 1 }")
+  }
+
+  @Test
+  def symbolicExtends(): Unit = {
+    assertCodeSuggestion("trait T <: Object", "trait T extends Object")
+  }
+
+  @Test
+  def unicodeArrow(): Unit = {
+    assertCodeSuggestion("class C { val f = (x: Int) ⇒ x }", "class C { val f = (x: Int) => x }")
+    assertCodeSuggestion("class C { for (x ← List(1)) yield x }", "class C { for (x <- List(1)) yield x }")
+  }
+
+  @Test
+  def lowerLongL(): Unit = {
+    assertCodeSuggestion("class C { val lo = 1l }", "class C { val lo = 1L }")
+  }
+
+  @Test
+  def inharomnicNumeric(): Unit = {
+    assertCodeSuggestion("class C { val a = 1L; val b: Double = a }", "class C { val a = 1L; val b: Double = a.toDouble }")
+    assertCodeSuggestion("class C { val a = 1L; val b: Double = a + a }", "class C { val a = 1L; val b: Double = (a + a).toDouble }")
+  }
+
+  @Test
+  def widenedDiv(): Unit = {
+    assertCodeSuggestion("class C { val a = 1; val b: Double = a / 2 }", "class C { val a = 1; val b: Double = (a / 2).toDouble }")
+  }
+
+  @Test
+  def etaNullary(): Unit = {
+    assertCodeSuggestion("class C { def f = 1; val g = f _ }", "class C { def f = 1; val g = () => f }")
+  }
+
+  @Test
+  def explicitImplicit(): Unit = {
+    assertCodeSuggestion("class C { implicit val x = 1 }", "class C { implicit val x: Int = 1 }")
+  }
+
+  @Test
+  def adaptToTuple(): Unit = {
+    assertCodeSuggestion("class C { def f(x: (Int, Int)) = 0; f(1, 1) }", "class C { def f(x: (Int, Int)) = 0; f((1, 1)) }")
+  }
+
+  @Test
+  def nilaryNullaryOverride(): Unit = {
+    assertCodeSuggestion(
+      """trait T { def f(): Int; def g: Int }
+        |class C extends T { def f: Int = 1; def g() = 2 }
+        |""".stripMargin,
+      """trait T { def f(): Int; def g: Int }
+        |class C extends T { def f(): Int = 1; def g = 2 }
+        |""".stripMargin
+    )
+  }
+
+  @Test
+  def nullaryUnit(): Unit = {
+    assertCodeSuggestion("class C { def f: Unit = println() }", "class C { def f(): Unit = println() }")
+  }
+
+  def assertCodeSuggestion(original: String, expected: String, comp: Compiler = compiler): Unit = {
+    val run = comp.newRun()
+    run.compileSources(comp.global.newSourceFile(original) :: Nil)
+    val reporter = comp.global.reporter.asInstanceOf[StoreReporter]
     val actions = reporter.infos.flatMap(_.actions).toList
     val newCode = applyChanges(original, actions)
     assertEquals(s"\n$newCode", expected, newCode)
diff --git a/test/junit/scala/tools/nsc/reporters/CodeActionTest.scala b/test/junit/scala/tools/nsc/reporters/CodeActionTest.scala
index 6aaad689c9..87bf475b83 100644
--- a/test/junit/scala/tools/nsc/reporters/CodeActionTest.scala
+++ b/test/junit/scala/tools/nsc/reporters/CodeActionTest.scala
@@ -5,5 +5,5 @@ import org.junit.runners.JUnit4
 
 @RunWith(classOf[JUnit4])
 class CodeActionTest extends AbstractCodeActionTest {
-  override def compilerArgs: String = "-Ystop-after:typer -Yvalidate-pos:typer -Yrangepos -deprecation"
+  override def compilerArgs: String = "-Ystop-after:refchecks -deprecation -Xlint"
 }
diff --git a/test/junit/scala/tools/nsc/reporters/CodeActionXsource3Test.scala b/test/junit/scala/tools/nsc/reporters/CodeActionXsource3Test.scala
index 718bb2f148..f1c713ba96 100644
--- a/test/junit/scala/tools/nsc/reporters/CodeActionXsource3Test.scala
+++ b/test/junit/scala/tools/nsc/reporters/CodeActionXsource3Test.scala
@@ -6,10 +6,10 @@ import org.junit.runners.JUnit4
 
 @RunWith(classOf[JUnit4])
 class CodeActionXsource3Test extends AbstractCodeActionTest {
-  override def compilerArgs: String = "-Ystop-after:typer -Yvalidate-pos:typer -Yrangepos -deprecation -Xsource:3"
+  override def compilerArgs: String = "-Ystop-after:refchecks -deprecation -Xlint -Xsource:3"
 
   @Test
-  def testLambdaParameterList(): Unit =
+  def lambdaParameterParens(): Unit =
     assertCodeSuggestion(
       """trait Test {
         |  def foo: Any = {
@@ -36,4 +36,32 @@ class CodeActionXsource3Test extends AbstractCodeActionTest {
         |}
       """.stripMargin,
     )
+
+  @Test
+  def qmark(): Unit = {
+    assertCodeSuggestion("class C[?]", "class C[`?`]")
+  }
+
+  @Test
+  def scala3Keyword(): Unit = {
+    assertCodeSuggestion("class C { val export = 1 }", "class C { val `export` = 1 }")
+  }
+
+  @Test
+  def infixTypeArg(): Unit = {
+    assertCodeSuggestion("class C { List apply[Int] 1 }", "class C { List.apply[Int](1) }")
+    assertCodeSuggestion("class C { List apply 1 map[Int] identity }", "class C { (List apply 1).map[Int](identity) }")
+    assertCodeSuggestion("class C { List apply 1 map[Int] (_ + 1) }", "class C { (List apply 1).map[Int](_ + 1) }")
+  }
+
+  @Test
+  def overrideInferredType(): Unit = {
+    assertCodeSuggestion(
+      """trait T { def f: Object }
+        |class C extends T { def f = "" }
+        |""".stripMargin,
+      """trait T { def f: Object }
+        |class C extends T { def f: String = "" }
+        |""".stripMargin)
+  }
 }
diff --git a/test/junit/scala/tools/nsc/reporters/PositionFilterTest.scala b/test/junit/scala/tools/nsc/reporters/PositionFilterTest.scala
index 1eaaaa501d..fe1b449df4 100644
--- a/test/junit/scala/tools/nsc/reporters/PositionFilterTest.scala
+++ b/test/junit/scala/tools/nsc/reporters/PositionFilterTest.scala
@@ -27,10 +27,7 @@ class PositionFilterTest {
   def `filters split messages`(): Unit = {
     val filter = createFilter
     val msg = "This is an important warning."
-    val longMessage = s"""$msg
-          |----
-          |Here is some fine print.
-          |Be sure to read it carefully.""".stripMargin
+    val longMessage = s"$msg [quickfixable]"
     filter.warning(pos, longMessage)
     filter.warning(pos, msg)
     assertEquals(1, store.infos.size)
diff --git a/test/junit/scala/tools/xsbt/BasicBridgeTest.scala b/test/junit/scala/tools/xsbt/BasicBridgeTest.scala
new file mode 100644
index 0000000000..3cd29a05c3
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/BasicBridgeTest.scala
@@ -0,0 +1,23 @@
+package scala.tools.xsbt
+
+import org.junit.Test
+
+class BasicBridgeTest extends BridgeTesting {
+  @Test
+  def bridgeCompiles(): Unit = {
+    withTemporaryDirectory { tempDir =>
+      compileSrcs(tempDir, "object Foo")
+      val t = tempDir / "target" / "Foo$.class"
+      assert(t.exists)
+    }
+  }
+
+  @Test
+  def bridgeDocs(): Unit = {
+    withTemporaryDirectory { tempDir =>
+      docSrcs(tempDir.toPath)
+      val t = tempDir / "target" / "index.html"
+      assert(t.exists)
+    }
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/BridgeTesting.scala b/test/junit/scala/tools/xsbt/BridgeTesting.scala
new file mode 100644
index 0000000000..a40112e568
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/BridgeTesting.scala
@@ -0,0 +1,203 @@
+package scala.tools.xsbt
+
+import xsbti.api.ClassLike
+import xsbti.api.DependencyContext._
+import xsbti.compile.{CompileProgress, DependencyChanges}
+import xsbti.{BasicVirtualFileRef, InteractiveConsoleInterface, Logger, Position, Problem, Severity, VirtualFile, VirtualFileRef, Reporter => XReporter}
+
+import java.io.{ByteArrayInputStream, File, InputStream}
+import java.nio.file.{Files, Path}
+import java.util.Optional
+import java.util.function.Supplier
+import scala.collection.mutable.ListBuffer
+import scala.tools.nsc.io.AbstractFile
+import scala.tools.testkit.TempDir
+import scala.tools.xsbt.TestCallback.ExtractedClassDependencies
+import scala.util.hashing.MurmurHash3
+
+class BridgeTesting {
+  def withTemporaryDirectory[T](action: Path => T): T = {
+    val dir = TempDir.createTempDir().toPath
+    try action(dir)
+    finally AbstractFile.getDirectory(dir.toFile).delete()
+  }
+
+  def mkReporter: TestingReporter = new TestingReporter()
+
+  def mkCompiler: CompilerBridge = new CompilerBridge()
+
+  def mkConsole: InteractiveConsoleBridgeFactory = new InteractiveConsoleBridgeFactory()
+
+  def mkScaladoc: ScaladocBridge = new ScaladocBridge()
+
+  private val emptyChanges: DependencyChanges = new DependencyChanges {
+    override val modifiedLibraries = new Array[VirtualFileRef](0)
+    override val modifiedBinaries = new Array[File](0)
+    override val modifiedClasses = new Array[String](0)
+    override def isEmpty = true
+  }
+
+  private val ignoreProgress = new CompileProgress { }
+
+  def compileSrcs(baseDir: Path, srcs: String*): (Seq[VirtualFile], TestCallback) =
+    compileSrcs(baseDir, mkReporter, srcs: _*)
+
+  def compileSrcs(baseDir: Path, reporter: XReporter, srcs: String*): (List[VirtualFile], TestCallback) =
+    compileSrcss(baseDir, reporter, List(srcs.toList))
+
+  def compileSrcss(baseDir: Path, reporter: XReporter, srcss: List[List[String]]): (List[VirtualFile], TestCallback) = {
+    val targetDir = baseDir / "target"
+    Files.createDirectory(targetDir)
+    val analysisCallback = new TestCallback
+    val filess = for ((sourceGroup, groupId) <- srcss.zipWithIndex) yield {
+      val files = sourceGroup.zipWithIndex map {
+        case (src, i) => new StringVirtualFile(s"Test-$groupId-$i.scala", src)
+      }
+      val compiler = mkCompiler
+      compiler.run(
+        sources = files.toArray,
+        changes = emptyChanges,
+        options = Array("-usejavacp", "-deprecation", "-cp", targetDir.getAbsolutePath),
+        output = new TestOutput(targetDir),
+        callback = analysisCallback,
+        delegate = reporter,
+        progress = ignoreProgress,
+        log = TestLogger)
+      files
+    }
+    (filess.flatten, analysisCallback)
+  }
+
+  def docSrcs(baseDir: Path, srcs: String*): Unit = {
+    val targetDir = baseDir / "target"
+    Files.createDirectory(targetDir)
+    val files = for ((src, i) <- srcs.toList.zipWithIndex) yield new StringVirtualFile(s"Test-$i.scala", src)
+    val scaladoc = mkScaladoc
+    scaladoc.run(
+      sources = files.toArray,
+      args = Array("-usejavacp", "-d", targetDir.getAbsolutePath),
+      log = TestLogger,
+      delegate = mkReporter)
+  }
+
+  def extractDependenciesFromSrcs(srcs: String*): ExtractedClassDependencies = withTemporaryDirectory { tmpDir =>
+    val (_, testCallback) = compileSrcs(tmpDir, srcs: _*)
+
+    val memberRefDeps = testCallback.classDependencies.toList collect {
+      case (target, src, DependencyByMemberRef) => (src, target)
+    }
+    val inheritanceDeps = testCallback.classDependencies.toList collect {
+      case (target, src, DependencyByInheritance) => (src, target)
+    }
+    val localInheritanceDeps = testCallback.classDependencies.toList collect {
+      case (target, src, LocalDependencyByInheritance) => (src, target)
+    }
+    ExtractedClassDependencies.fromPairs(memberRefDeps, inheritanceDeps, localInheritanceDeps)
+  }
+
+  def extractBinaryDependenciesFromSrcss(srcss: List[List[String]]): ExtractedClassDependencies = withTemporaryDirectory { tmpDir =>
+    val (_, testCallback) = compileSrcss(tmpDir, mkReporter, srcss)
+    val binaryDependencies = testCallback.binaryDependencies
+    ExtractedClassDependencies.fromPairs(
+      binaryDependencies.toList.collect { case (_, bin, src, DependencyByMemberRef) => src -> bin },
+      binaryDependencies.toList.collect { case (_, bin, src, DependencyByInheritance) =>
+        src -> bin
+      },
+      binaryDependencies.toList.collect { case (_, bin, src, LocalDependencyByInheritance) =>
+        src -> bin
+      },
+    )
+  }
+
+  /**
+   * Compiles given source code using Scala compiler and returns API representation
+   * extracted by ExtractAPI class.
+   */
+  def extractApisFromSrc(src: String): Set[ClassLike] = withTemporaryDirectory { tmpDir =>
+    val (Seq(tempSrcFile), analysisCallback) = compileSrcs(tmpDir, src)
+    analysisCallback.apis(tempSrcFile)
+  }
+
+  /**
+   * Compiles given source code using Scala compiler and returns API representation
+   * extracted by ExtractAPI class.
+   */
+  def extractApisFromSrcs(srcs: List[String]*): Seq[Set[ClassLike]] = withTemporaryDirectory { tmpDir =>
+    val (tempSrcFiles, analysisCallback) = compileSrcss(tmpDir, mkReporter, srcs.toList)
+    tempSrcFiles.map(analysisCallback.apis)
+  }
+
+  def extractUsedNamesFromSrc(src: String): Map[String, Set[String]] = withTemporaryDirectory { tmpDir =>
+    val (_, analysisCallback) = compileSrcs(tmpDir, src)
+    analysisCallback.usedNames.toMap
+  }
+
+  /**
+   * Extract used names from the last source file in `sources`.
+   *
+   * The previous source files are provided to successfully compile examples.
+   * Only the names used in the last src file are returned.
+   */
+  def extractUsedNamesFromSrc(sources: String*): Map[String, Set[String]] = withTemporaryDirectory { tmpDir =>
+    val (srcFiles, analysisCallback) = compileSrcs(tmpDir, sources: _*)
+    srcFiles
+      .map { srcFile =>
+        val classesInSrc = analysisCallback.classNames(srcFile).map(_._1)
+        classesInSrc.map(className => className -> analysisCallback.usedNames(className)).toMap
+      }
+      .reduce(_ ++ _)
+  }
+
+  def interactiveConsole(baseDir: Path)(args: String*): InteractiveConsoleInterface = {
+    val targetDir = baseDir / "target"
+    Files.createDirectory(targetDir)
+    val sc = mkConsole
+    sc.createConsole(
+      args = Array("-usejavacp") ++ args,
+      bootClasspathString = "",
+      classpathString = "",
+      initialCommands = "",
+      cleanupCommands = "",
+      loader = Optional.empty,
+      bindNames = Array(),
+      bindValues = Array(),
+      log = TestLogger)
+  }
+
+  def withInteractiveConsole[A](f: InteractiveConsoleInterface => A): A = withTemporaryDirectory { tmpDir =>
+    val repl = interactiveConsole(tmpDir)()
+    try f(repl)
+    finally repl.close()
+  }
+}
+
+class TestingReporter extends XReporter {
+  val messages: ListBuffer[Problem] = ListBuffer.empty
+
+  override def reset(): Unit = messages.clear()
+  override def hasErrors: Boolean = messages.exists(_.severity() == Severity.Error)
+  override def hasWarnings: Boolean = messages.exists(_.severity() == Severity.Warn)
+  override def printSummary(): Unit = println(messages.mkString("\n"))
+  override def problems(): Array[Problem] = messages.toArray
+  override def log(problem: Problem): Unit = messages += problem
+  override def comment(pos: Position, msg: String): Unit = ()
+}
+
+class StringVirtualFile(path: String, content: String) extends BasicVirtualFileRef(path) with VirtualFile {
+  override def contentHash: Long = MurmurHash3.arrayHash(content.getBytes("UTF-8"))
+  override def input: InputStream = new ByteArrayInputStream(content.getBytes("UTF-8"))
+  override def toString: String = s"StringVirtualFile($path, <content>)"
+}
+
+class TestOutput(override val getOutputDirectoryAsPath: Path) extends xsbti.compile.SingleOutput {
+  override def getOutputDirectory: File = getOutputDirectoryAsPath.toFile
+  override def toString: String = s"TestOutput($getOutputDirectoryAsPath)"
+}
+
+object TestLogger extends Logger {
+  override def error(msg: Supplier[String]): Unit = throw new Exception(msg.get())
+  override def warn(msg: Supplier[String]): Unit = println(msg.get())
+  override def info(msg: Supplier[String]): Unit = println(msg.get())
+  override def debug(msg: Supplier[String]): Unit = ()
+  override def trace(exception: Supplier[Throwable]): Unit = ()
+}
diff --git a/test/junit/scala/tools/xsbt/ClassNameTest.scala b/test/junit/scala/tools/xsbt/ClassNameTest.scala
new file mode 100644
index 0000000000..94afeef22c
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/ClassNameTest.scala
@@ -0,0 +1,289 @@
+package scala.tools.xsbt
+
+import org.junit.{Ignore, Test, Assert}
+
+import java.io.File
+
+class ClassNameTest extends BridgeTesting {
+  @Test
+  def `ClassName should create correct binary names for top level object`(): Unit =  {
+    expectBinaryClassNames("object A", Set("A" -> "A", "A" -> "A$"))
+  }
+
+  @Test
+  def `ClassName should create binary names for top level class`(): Unit = {
+    expectBinaryClassNames("class A", Set("A" -> "A"))
+  }
+
+  @Test
+  def `ClassName should create binary names for top level companions`(): Unit = {
+    val src = "class A; object A"
+    expectBinaryClassNames(src, Set("A" -> "A", "A" -> "A$"))
+  }
+
+  @Test
+  def `ClassName should create binary names for case classes with no companions`(): Unit = {
+    expectBinaryClassNames(
+      "case class LonelyCaseClass(paramA: String)",
+      Set("LonelyCaseClass" -> "LonelyCaseClass", "LonelyCaseClass" -> "LonelyCaseClass$")
+    )
+  }
+
+  @Test
+  def `ClassName should create binary names for case classes with companions`(): Unit = {
+    expectBinaryClassNames(
+      "case class LonelyCaseClass2(paramA: String);object LonelyCaseClass2 { val z: Int = 1 }",
+      Set("LonelyCaseClass2" -> "LonelyCaseClass2", "LonelyCaseClass2" -> "LonelyCaseClass2$")
+    )
+  }
+
+  @Test
+  def `ClassName should create a correct binary name for names with encoded symbols`(): Unit = {
+    val src = "package `package with spaces` { class :: }"
+    expectBinaryClassNames(
+      src,
+      Set(
+        "package$u0020with$u0020spaces.$colon$colon" -> "package$u0020with$u0020spaces.$colon$colon"
+      )
+    )
+  }
+
+  @Test
+  def `ClassName should create a correct binary name for names that are expanded`(): Unit = {
+    val src =
+      """class Fooo {
+        |  // This one is problematic because of expanded names
+        |  private[Fooo] object Bar
+        |}
+        |
+        |package issue127 {
+        |  object Foo {
+        |    private[issue127] class Bippy
+        |    // This one is problematic because of expanded names
+        |    private[issue127] object Bippy
+        |  }
+        |}
+        |""".stripMargin
+    expectBinaryClassNames(
+      src,
+      Set(
+        "Fooo" -> "Fooo",
+        "Fooo.Bar" -> "Fooo$Bar$",
+        "issue127.Foo" -> "issue127.Foo",
+        "issue127.Foo" -> "issue127.Foo$",
+        "issue127.Foo.Bippy" -> "issue127.Foo$Bippy",
+        "issue127.Foo.Bippy" -> "issue127.Foo$Bippy$"
+      )
+    )
+  }
+
+  @Test
+  def `ClassName should create correct binary names for nested object`(): Unit = {
+    expectBinaryClassNames(
+      "object A { object C { object D } }; class B { object E }",
+      Set(
+        "A" -> "A$",
+        "A" -> "A",
+        "A.C" -> "A$C$",
+        "A.C.D" -> "A$C$D$",
+        "B" -> "B",
+        "B.E" -> "B$E$"
+      )
+    )
+  }
+
+  @Test
+  def `ClassName should handle names of anonymous functions`(): Unit = {
+    expectBinaryClassNames(
+      "object A { val a: Unit = { println((a: String) => a) }}",
+      Set(
+        "A" -> "A$",
+        "A" -> "A"
+      ),
+      Set.empty
+    )
+  }
+
+  @Test
+  def `ClassName should handle advanced scenarios of nested classes and objects`(): Unit = {
+    val src =
+      """
+        |package foo.bar
+        |
+        |class A {
+        |  class A2 {
+        |    class A3 {
+        |      object A4
+        |    }
+        |  }
+        |}
+        |object A {
+        |  class B
+        |  object B {
+        |    class C
+        |  }
+        |}
+    """.stripMargin
+
+    expectBinaryClassNames(
+      src,
+      Set(
+        "foo.bar.A" -> "foo.bar.A",
+        "foo.bar.A" -> "foo.bar.A$",
+        "foo.bar.A.A2" -> "foo.bar.A$A2",
+        "foo.bar.A.A2.A3" -> "foo.bar.A$A2$A3",
+        "foo.bar.A.A2.A3.A4" -> "foo.bar.A$A2$A3$A4$",
+        "foo.bar.A.B" -> "foo.bar.A$B",
+        "foo.bar.A.B" -> "foo.bar.A$B$",
+        "foo.bar.A.B.C" -> "foo.bar.A$B$C"
+      )
+    )
+  }
+
+  @Test
+  def `ClassName should create a binary name for both class of the package objects and its classes`(): Unit = {
+    val src = "package object po { class B; object C }"
+    expectBinaryClassNames(
+      src,
+      Set(
+        "po.package" -> "po.package",
+        "po.package" -> "po.package$",
+        "po.B" -> "po.package$B",
+        "po.C" -> "po.package$C$"
+      )
+    )
+  }
+
+  @Test
+  def `ClassName should create a binary name for a trait`(): Unit = {
+    // we do not track $impl classes because nobody can depend on them directly
+    expectBinaryClassNames("trait A", Set("A" -> "A"))
+  }
+
+  @Test
+  def `ClassName should not create binary names nor class files for class of early inits`(): Unit = {
+    val src =
+      """
+        |class M extends {
+        |  val a = 1
+        |} with C
+        |
+        |abstract class C {
+        |  val a: Int
+        |}
+        |""".stripMargin
+
+    expectBinaryClassNames(
+      src,
+      Set(
+        "M" -> "M",
+        "C" -> "C"
+      )
+    )
+  }
+
+  @Test
+  def `ClassName should not create binary names for a refinement class but register its class file`(): Unit = {
+    val src =
+      """
+        |object UseSite {
+        |  val rc: C with C2 { val a: Int } = new C with C2 {
+        |    val a: Int = 1
+        |  }
+        |}
+        |
+        |abstract class C
+        |trait C2
+        |""".stripMargin
+
+    expectBinaryClassNames(
+      src,
+      Set(
+        "UseSite" -> "UseSite",
+        "UseSite" -> "UseSite$",
+        "C" -> "C",
+        "C2" -> "C2"
+      ),
+      // The anonymous
+      Set("UseSite$$anon$1")
+    )
+  }
+
+  @Test @Ignore
+  def `ClassName should not create binary names for local classes`(): Unit = {
+    val src =
+      """
+        |class Container {
+        |  def foo = {
+        |    class C
+        |  }
+        |  def baz = {
+        |    class D(i: Int)
+        |    object D
+        |    new D(1)
+        |  }
+        |  def bar = {
+        |    // anonymous class
+        |    new T {}
+        |  }
+        |}
+        |
+        |trait T
+        |""".stripMargin
+
+    expectBinaryClassNames(
+      src,
+      Set(
+        "Container" -> "Container",
+        "T" -> "T"
+      ),
+      Set(
+        "Container$$anon$1",
+        "Container$C$1",
+        "Container$D$2",
+        "Container$D$3$"
+      )
+    )
+  }
+
+  private def expectBinaryClassNames(
+                                      src: String,
+                                      expectedNames: Set[(String, String)],
+                                      expectedLocalNames: Set[String] = Set.empty
+                                    ): Unit = withTemporaryDirectory { tmpDir =>
+    val (Seq(tempSrcFile), analysisCallback) = compileSrcs(tmpDir, src)
+    val binaryClassNames = analysisCallback.classNames(tempSrcFile).toSet
+    val generatedProducts = analysisCallback.productClassesToSources.keySet.toSet
+
+    if (binaryClassNames == expectedNames) {
+      val paths = (expectedLocalNames.map(n => s"${n}.class") ++
+        expectedNames.map(n => s"${n._2.replace('.', File.separatorChar)}.class"))
+      val generatedProductNames = generatedProducts.map(_.getFileName.toString)
+      val missing = {
+        val ms = generatedProducts
+          .map(gn => gn -> paths.find(p => gn.toAbsolutePath.endsWith(p)))
+        ms.filter(_._2.isEmpty).map(_._1)
+      }
+
+      val extra = paths.map(_.split(File.separatorChar).last).diff(generatedProductNames)
+      if (missing.isEmpty && extra.isEmpty) ()
+      else {
+        Assert.fail(
+          if (missing.nonEmpty && extra.nonEmpty) s"Missing classes $missing; extra classes $extra"
+          else if (missing.nonEmpty) s"Missing classes ${missing}"
+          else s"Extra classes ${extra}"
+        )
+      }
+    } else {
+      val isDisjoint = binaryClassNames.intersect(expectedNames).isEmpty
+      val missing = binaryClassNames.diff(expectedNames).mkString
+      val extra = expectedNames.diff(binaryClassNames).mkString
+      Assert.fail(
+        if (isDisjoint) s"Received ${binaryClassNames}; expected ${expectedNames}"
+        else if (missing.nonEmpty && extra.nonEmpty) s"Missing names $missing; extra names $extra"
+        else if (missing.nonEmpty) s"Missing names ${missing}"
+        else s"Extra names ${extra}"
+      )
+    }
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/CodeActionTest.scala b/test/junit/scala/tools/xsbt/CodeActionTest.scala
new file mode 100644
index 0000000000..0776eb0adc
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/CodeActionTest.scala
@@ -0,0 +1,18 @@
+package scala.tools.xsbt
+
+import org.junit.Test
+import org.junit.Assert.assertEquals
+
+
+class CodeActionTest extends BridgeTesting {
+  @Test
+  def procedureSyntax(): Unit = {
+    withTemporaryDirectory { tempDir =>
+      val reporter = mkReporter
+      compileSrcs(tempDir, reporter, "object Foo { def foo { } }")
+      val edit = reporter.messages.head.actions.get(0).edit().changes().get(0)
+      assertEquals(20, edit.position().offset().get())
+      assertEquals(": Unit =", edit.newText())
+    }
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/DependencyTest.scala b/test/junit/scala/tools/xsbt/DependencyTest.scala
new file mode 100644
index 0000000000..48566d9dd0
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/DependencyTest.scala
@@ -0,0 +1,229 @@
+package scala.tools.xsbt
+
+import org.junit.Test
+import org.junit.Assert.{assertEquals, assertTrue}
+
+import scala.tools.xsbt.TestCallback.ExtractedClassDependencies
+
+class DependencyTest extends BridgeTesting {
+
+  @Test
+  def `Dependency phase should extract class dependencies from public members`(): Unit = {
+    val classDependencies = extractClassDependenciesPublic
+    val memberRef = classDependencies.memberRef
+    val inheritance = classDependencies.inheritance
+    assertEquals(memberRef("A"), Set.empty)
+    assertEquals(inheritance("A"), Set.empty)
+    assertEquals(memberRef("B"), Set("A", "D"))
+    assertEquals(inheritance("B"), Set("D"))
+    assertEquals(memberRef("C"), Set("A"))
+    assertEquals(inheritance("C"), Set.empty)
+    assertEquals(memberRef("D"), Set.empty)
+    assertEquals(inheritance("D"), Set.empty)
+    assertEquals(memberRef("E"), Set.empty)
+    assertEquals(inheritance("E"), Set.empty)
+    assertEquals(memberRef("F"), Set("A", "B", "D", "E", "G", "C")) // C is the underlying type of MyC
+    assertEquals(inheritance("F"), Set("A", "E"))
+    assertEquals(memberRef("H"), Set("B", "E", "G"))
+    // aliases and applied type constructors are expanded so we have inheritance dependency on B
+    assertEquals(inheritance("H"), Set("B", "E"))
+  }
+
+  @Test
+  def `Dependency phase should extract class dependencies from local members`(): Unit = {
+    val classDependencies = extractClassDependenciesLocal
+    val memberRef = classDependencies.memberRef
+    val inheritance = classDependencies.inheritance
+    val localInheritance = classDependencies.localInheritance
+    assertEquals(memberRef("A"), Set.empty)
+    assertEquals(inheritance("A"), Set.empty)
+    assertEquals(memberRef("B"), Set.empty)
+    assertEquals(inheritance("B"), Set.empty)
+    assertEquals(memberRef("C.Inner1"), Set("A"))
+    assertEquals(inheritance("C.Inner1"), Set("A"))
+    assertEquals(memberRef("D"), Set("B"))
+    assertEquals(inheritance("D"), Set.empty)
+    assertEquals(localInheritance("D"), Set("B"))
+    assertEquals(memberRef("E"), Set("B"))
+    assertEquals(inheritance("E"), Set.empty)
+    assertEquals(localInheritance("E"), Set("B"))
+  }
+
+  @Test
+  def `Dependency phase should extract class dependencies with trait as first parent`(): Unit = {
+    val classDependencies = extractClassDependenciesTraitAsFirstPatent
+    val memberRef = classDependencies.memberRef
+    val inheritance = classDependencies.inheritance
+    assertEquals(memberRef("A"), Set.empty)
+    assertEquals(inheritance("A"), Set.empty)
+    assertEquals(memberRef("B"), Set("A"))
+    assertEquals(inheritance("B"), Set("A"))
+    // verify that memberRef captures the oddity described in documentation of `Relations.inheritance`
+    // we are mainly interested whether dependency on A is captured in `memberRef` relation so
+    // the invariant that says that memberRef is superset of inheritance relation is preserved
+    assertEquals(memberRef("C"), Set("A", "B"))
+    assertEquals(inheritance("C"), Set("A", "B"))
+    // same as above but indirect (C -> B -> A), note that only A is visible here
+    assertEquals(memberRef("D"), Set("A", "C"))
+    assertEquals(inheritance("D"), Set("A", "C"))
+  }
+
+  @Test
+  def `Dependency phase should extract class dependencies from macro arguments`(): Unit = {
+    val binaryDependencies = extractBinaryDependenciesFromMacroArgument
+    val memberRef = binaryDependencies.memberRef
+    Set("B$", "C$").foreach(k => assertTrue(k, memberRef("A").contains(k)))
+  }
+
+  @Test
+  def `Dependency phase should extract class dependencies from a refinement`(): Unit = {
+    val srcFoo =
+      "object Outer {\n  class Inner { type Xyz }\n\n  type TypeInner = Inner { type Xyz = Int }\n}"
+    val srcBar = "object Bar {\n  def bar: Outer.TypeInner = null\n}"
+    val classDependencies = extractDependenciesFromSrcs(srcFoo, srcBar)
+
+    val memberRef = classDependencies.memberRef
+    val inheritance = classDependencies.inheritance
+    assertEquals(memberRef("Outer"), Set.empty)
+    assertEquals(inheritance("Outer"), Set.empty)
+    assertEquals(memberRef("Bar"), Set("Outer", "Outer.Inner"))
+    assertEquals(inheritance("Bar"), Set.empty)
+  }
+
+  @Test
+  def `Dependency phase should extract class dependency on a object correctly`(): Unit = {
+    val srcA =
+      """object A {
+        |   def foo = { B; () }
+        |}""".stripMargin
+    val srcB = "object B"
+
+    val classDependencies = extractDependenciesFromSrcs(srcA, srcB)
+
+    val memberRef = classDependencies.memberRef
+    val inheritance = classDependencies.inheritance
+    assertEquals(memberRef("A"), Set("B"))
+    assertEquals(inheritance("A"), Set.empty)
+    assertEquals(memberRef("B"), Set.empty)
+    assertEquals(inheritance("B"), Set.empty)
+  }
+
+  @Test
+  def `Dependency phase should extract class dependency from 'classOf' literal`(): Unit = {
+    val srcA =
+      """object A {
+        |   print(classOf[B])
+        |}""".stripMargin
+    val srcB = "class B"
+
+    val classDependencies = extractDependenciesFromSrcs(srcA, srcB)
+
+    val memberRef = classDependencies.memberRef
+    val inheritance = classDependencies.inheritance
+    assertEquals(memberRef("A"), Set("B"))
+    assertEquals(inheritance("A"), Set.empty)
+    assertEquals(memberRef("B"), Set.empty)
+    assertEquals(inheritance("B"), Set.empty)
+  }
+
+  @Test
+  def `Dependency phase should handle top level import dependencies`(): Unit = {
+    val srcA =
+      """
+        |package abc
+        |object A {
+        |  class Inner
+        |}
+        |class A2""".stripMargin
+    val srcB = "import abc.A; import abc.A.Inner; class B"
+    val srcC = "import abc.{A, A2}; class C"
+    val srcD = "import abc.{A2 => Foo}; class D"
+    val srcE = "import abc.A._; class E"
+    val srcF = "import abc._; class F"
+    val srcG =
+      """|package foo {
+         |  package bar {
+         |    import abc.A
+         |    class G
+         |  }
+         |}
+    """.stripMargin
+    val srcH = "class H { import abc.A }"
+
+    val deps = extractDependenciesFromSrcs(srcA, srcB, srcC, srcD, srcE, srcF, srcG, srcH).memberRef
+
+    assertEquals(deps("A"), Set.empty)
+    assertEquals(deps("B"), Set("abc.A", "abc.A.Inner"))
+    assertEquals(deps("C"), Set("abc.A", "abc.A2"))
+    assertEquals(deps("D"), Set("abc.A2"))
+    assertEquals(deps("E"), Set("abc.A"))
+    assertEquals(deps("F"), Set.empty)
+    assertEquals(deps("foo.bar.G"), Set("abc.A"))
+    assertEquals(deps("H"), Set("abc.A"))
+  }
+
+  private def extractClassDependenciesPublic: ExtractedClassDependencies = {
+    val srcA = "class A"
+    val srcB = "class B extends D[A]"
+    val srcC =
+      """|class C {
+         |  def a: A = null
+         |}""".stripMargin
+    val srcD = "class D[T]"
+    val srcE = "trait E[T]"
+    val srcF = "trait F extends A with E[D[B]] { self: G.MyC => }"
+    val srcG = "object G { type T[x] = B ; type MyC = C }"
+    // T is a type constructor [x]B
+    // B extends D
+    // E verifies the core type gets pulled out
+    val srcH = "trait H extends G.T[Int] with (E[Int] @unchecked)"
+
+    val classDependencies =
+      extractDependenciesFromSrcs(srcA, srcB, srcC, srcD, srcE, srcF, srcG, srcH)
+    classDependencies
+  }
+
+  private def extractClassDependenciesLocal: ExtractedClassDependencies = {
+    val srcA = "class A"
+    val srcB = "class B"
+    val srcC = "class C { private class Inner1 extends A }"
+    val srcD = "class D { def foo: Unit = { class Inner2 extends B } }"
+    val srcE = "class E { def foo: Unit = { new B {} } }"
+
+    val classDependencies =
+      extractDependenciesFromSrcs(srcA, srcB, srcC, srcD, srcE)
+    classDependencies
+  }
+
+  private def extractClassDependenciesTraitAsFirstPatent: ExtractedClassDependencies = {
+    val srcA = "class A"
+    val srcB = "trait B extends A"
+    val srcC = "trait C extends B"
+    val srcD = "class D extends C"
+
+    val classDependencies =
+      extractDependenciesFromSrcs(srcA, srcB, srcC, srcD)
+    classDependencies
+  }
+
+  private def extractBinaryDependenciesFromMacroArgument: ExtractedClassDependencies = {
+    val srcA = "class A { println(B.printTree(C.foo)) }"
+    val srcB =
+      """
+        |import scala.language.experimental.macros
+        |import scala.reflect.macros.blackbox._
+        |object B {
+        |  def printTree(arg: Any): String = macro printTreeImpl
+        |  def printTreeImpl(c: Context)(arg: c.Expr[Any]): c.Expr[String] = {
+        |    val argStr = arg.tree.toString
+        |    val literalStr = c.universe.Literal(c.universe.Constant(argStr))
+        |    c.Expr[String](literalStr)
+        |  }
+        |}""".stripMargin
+    val srcC = "object C { val foo = 1 }"
+
+    val binaryDependencies =
+      extractBinaryDependenciesFromSrcss(List(List(srcB, srcC), List(srcA)))
+    binaryDependencies
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/ExtractAPITest.scala b/test/junit/scala/tools/xsbt/ExtractAPITest.scala
new file mode 100644
index 0000000000..9ab0389d49
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/ExtractAPITest.scala
@@ -0,0 +1,204 @@
+package scala.tools.xsbt
+
+import org.junit.Test
+import org.junit.Assert._
+import xsbti.api._
+
+class ExtractAPITest extends BridgeTesting {
+
+  @Test
+  def `ExtractAPI should extract children of a sealed class`(): Unit = {
+    def compileAndGetFooClassApi(src: String): ClassLike = {
+      val apis = extractApisFromSrc(src)
+      val FooApi = apis.find(_.name() == "Foo").get
+      FooApi
+    }
+
+    val src1 =
+      """|sealed abstract class Foo
+         |case class C1(x: Int) extends Foo
+         |""".stripMargin
+    val fooClassApi1 = compileAndGetFooClassApi(src1)
+    val src2 =
+      """|sealed abstract class Foo
+         |case class C1(x: Int) extends Foo
+         |case class C2(x: Int) extends Foo
+         |""".stripMargin
+    val fooClassApi2 = compileAndGetFooClassApi(src2)
+    assertFalse(SameAPI(fooClassApi1, fooClassApi2))
+  }
+
+  @Test
+  def `ExtractAPI should extract correctly the definition type of a package object`(): Unit = {
+    val src = "package object foo".stripMargin
+    val apis = extractApisFromSrc(src)
+    val Seq(fooClassApi) = apis.toSeq
+    assertEquals(fooClassApi.definitionType, DefinitionType.PackageModule)
+  }
+
+  @Test
+  def `ExtractAPI should extract nested classes`(): Unit = {
+    val src =
+      """class A {
+        |  class B
+        |}""".stripMargin
+    val apis = extractApisFromSrc(src).map(c => c.name -> c).toMap
+    assertEquals(apis.keys, Set("A", "A.B"))
+  }
+
+  @Test
+  def `ExtractAPI should not extract local classes`(): Unit = {
+    val src =
+      """class A
+        |class B
+        |class C { def foo: Unit = { class Inner2 extends B } }
+        |class D { def foo: Unit = { new B {} } }""".stripMargin
+    val apis = extractApisFromSrc(src).map(c => c.name -> c).toMap
+    assertEquals(apis.keys, Set("A", "B", "C", "D"))
+  }
+
+  @Test
+  def `ExtractAPI should extract flat (without members) api for a nested class`(): Unit = {
+    def compileAndGetFooClassApi(src: String): ClassLike = {
+      val apis = extractApisFromSrc(src)
+      val FooApi = apis.find(_.name() == "Foo").get
+      FooApi
+    }
+
+    val src1 =
+      """class Foo {
+        |  class A
+        |}""".stripMargin
+    val fooClassApi1 = compileAndGetFooClassApi(src1)
+    val src2 =
+      """class Foo {
+        |  class A {
+        |    def foo: Int = 123
+        |  }
+        |}""".stripMargin
+    val fooClassApi2 = compileAndGetFooClassApi(src2)
+    assertTrue(SameAPI(fooClassApi1, fooClassApi2))
+  }
+
+  @Test
+  def `ExtractAPI should extract private classes`(): Unit = {
+    val src =
+      """private class A
+        |class B { private class Inner1 extends A }
+        |""".stripMargin
+    val apis = extractApisFromSrc(src).map(c => c.name -> c).toMap
+    assertEquals(apis.keys, Set("A", "B", "B.Inner1"))
+  }
+
+  @Test
+  def `ExtractAPI should give stable names to members of existential types in method signatures`(): Unit = {
+    def compileAndGetFooMethodApi(src: String): Def = {
+      val sourceApi = extractApisFromSrc(src)
+      val FooApi = sourceApi.find(_.name() == "Foo").get
+      val fooMethodApi = FooApi.structure().declared().find(_.name == "foo").get
+      fooMethodApi.asInstanceOf[Def]
+    }
+
+    val src1 =
+      """class Box[T]
+        |class Foo {
+        |	 def foo: Box[_] = null
+        |}""".stripMargin
+    val fooMethodApi1 = compileAndGetFooMethodApi(src1)
+    val src2 =
+      """class Box[T]
+        |class Foo {
+        |  def bar: Box[_] = null
+        |	 def foo: Box[_] = null
+        |}""".stripMargin
+    val fooMethodApi2 = compileAndGetFooMethodApi(src2)
+    assertTrue("APIs are not the same.", SameAPI.apply(fooMethodApi1, fooMethodApi2))
+  }
+
+  /**
+   * Checks if representation of the inherited Namer class (with a declared self variable) in Global.Foo
+   * is stable between compiling from source and unpickling. We compare extracted APIs of Global when Global
+   * is compiled together with Namers or Namers is compiled first and then Global refers
+   * to Namers by unpickling types from class files.
+   */
+  @Test
+  def `ExtractAPI should make a stable representation of a self variable that has no self type`(): Unit = {
+    def selectNamer(apis: Set[ClassLike]): ClassLike = {
+      // TODO: this doesn't work yet because inherited classes are not extracted
+      apis.find(_.name == "Global.Foo.Namer").get
+    }
+
+    val src1 =
+      """|class Namers {
+         |  class Namer { thisNamer => }
+         |}
+         |""".stripMargin
+    val src2 =
+      """|class Global {
+         |  class Foo extends Namers
+         |}
+         |""".stripMargin
+    val apis =
+      extractApisFromSrcs(List(src1, src2), List(src2))
+    val _ :: src2Api1 :: src2Api2 :: Nil = apis.toList
+    val namerApi1 = selectNamer(src2Api1)
+    val namerApi2 = selectNamer(src2Api2)
+    assertTrue(SameAPI(namerApi1, namerApi2))
+  }
+
+  @Test
+  def `ExtractAPI should make a different representation for an inherited class`(): Unit = {
+    val src =
+      """|class A[T] {
+         |  abstract class AA { def t: T }
+         |}
+         |class B extends A[Int]
+    """.stripMargin
+    val apis = extractApisFromSrc(src).map(a => a.name -> a).toMap
+    assertEquals(apis.keySet, Set("A", "A.AA", "B", "B.AA"))
+    assertNotEquals(apis("A.AA"), apis("B.AA"))
+  }
+
+  @Test
+  def `ExtractAPI should handle package objects and type companions`(): Unit = {
+    val src =
+      """|package object abc {
+         |  type BuildInfoKey = BuildInfoKey.Entry[_]
+         |  object BuildInfoKey {
+         |    sealed trait Entry[A]
+         |  }
+         |}
+    """.stripMargin
+    val apis = extractApisFromSrc(src).map(a => a.name -> a).toMap
+    assertEquals(apis.keySet, Set("abc.package", "abc.BuildInfoKey", "abc.BuildInfoKey.Entry"))
+  }
+
+  /**
+   * Checks if self type is properly extracted in various cases of declaring a self type
+   * with our without a self variable.
+   */
+  @Test
+  def `ExtractAPI should represent a self type correctly`(): Unit = {
+    val srcX = "trait X"
+    val srcY = "trait Y"
+    val srcC1 = "class C1 { this: C1 => }"
+    val srcC2 = "class C2 { thisC: C2 => }"
+    val srcC3 = "class C3 { this: X => }"
+    val srcC4 = "class C4 { thisC: X => }"
+    val srcC5 = "class C5 extends AnyRef with X with Y { self: X with Y => }"
+    val srcC6 = "class C6 extends AnyRef with X { self: X with Y => }"
+    val srcC7 = "class C7 { _ => }"
+    val srcC8 = "class C8 { self => }"
+    val apis = extractApisFromSrcs(
+      List(srcX, srcY, srcC1, srcC2, srcC3, srcC4, srcC5, srcC6, srcC7, srcC8)
+    ).map(_.head)
+    val emptyType = EmptyType.of()
+
+    def hasSelfType(c: ClassLike): Boolean =
+      c.selfType != emptyType
+
+    val (withSelfType, withoutSelfType) = apis.partition(hasSelfType)
+    assertEquals(withSelfType.map(_.name).toSet, Set("C3", "C4", "C5", "C6"))
+    assertEquals(withoutSelfType.map(_.name).toSet, Set("X", "Y", "C1", "C2", "C7", "C8"))
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/ExtractUsedNamesTest.scala b/test/junit/scala/tools/xsbt/ExtractUsedNamesTest.scala
new file mode 100644
index 0000000000..67c9ca377a
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/ExtractUsedNamesTest.scala
@@ -0,0 +1,266 @@
+package scala.tools.xsbt
+
+import org.junit.Assert._
+import org.junit.{Ignore, Test}
+
+class ExtractUsedNamesTest extends BridgeTesting {
+
+  @Test
+  def `Used names extraction should extract imported name`(): Unit = {
+    val src =
+      """package a { class A }
+        |package b {
+        | import a.{A => A2}
+        |}""".stripMargin
+    val usedNames = extractUsedNamesFromSrc(src)
+    val expectedNames = standardNames ++ Set("a", "A", "A2", "b")
+    // names used at top level are attributed to the first class defined in a compilation unit
+
+    assertEquals(usedNames("a.A"), expectedNames)
+  }
+
+  // test covers https://github.com/gkossakowski/sbt/issues/6
+  @Test
+  def `Used names extraction should extract names in type tree`(): Unit = {
+    val srcA =
+      """|package a {
+         |  class A {
+         |    class C { class D }
+         |  }
+         |  class B[T]
+         |}
+         |package c {
+         |  class BB
+         |}
+         |
+         |""".stripMargin
+    val srcB =
+      """|package b {
+         | abstract class X {
+         |     def foo: a.A#C#D
+         |     def bar: a.B[c.BB]
+         |   }
+         |}""".stripMargin
+    val usedNames = extractUsedNamesFromSrc(srcA, srcB)
+    val expectedNames = standardNames ++ Set("a", "c", "A", "B", "C", "D", "b", "X", "BB")
+    assertEquals(usedNames("b.X"), expectedNames)
+  }
+
+  // test for https://github.com/gkossakowski/sbt/issues/5
+  @Test
+  def `Used names extraction should extract symbolic names`(): Unit = {
+    val srcA =
+      """|class A {
+         |  def `=`: Int = 3
+         |}""".stripMargin
+    val srcB =
+      """|class B {
+         |  def foo(a: A) = a.`=`
+         |}""".stripMargin
+    val usedNames = extractUsedNamesFromSrc(srcA, srcB)
+    val expectedNames = standardNames ++ Set("A", "a", "B", "=", "Int")
+    assertEquals(usedNames("B"), expectedNames)
+  }
+
+  @Test
+  def `Used names extraction should extract type names for objects depending on abstract types`(): Unit = {
+    val srcA =
+      """abstract class A {
+        | type T
+        | object X {
+        |    def foo(x: T): T = x
+        |  }
+        |}
+    """.stripMargin
+    val srcB = "class B extends A { type T = Int }"
+    val srcC = "object C extends B"
+    val srcD = "object D { C.X.foo(12) }"
+    val usedNames = extractUsedNamesFromSrc(srcA, srcB, srcC, srcD)
+    val namesA = standardNames ++ Set("A")
+    val namesAX = standardNames ++ Set("X", "x", "T", "A")
+    val namesB = Set("B", "A", "Int", "A;init;", "scala")
+    val namesC = Set("B;init;", "C", "B")
+    val namesD = standardNames ++ Set("D", "C", "X", "foo", "Int", "T")
+    assertEquals(usedNames("A"), namesA)
+    assertEquals(usedNames("A.X"), namesAX)
+    assertEquals(usedNames("B"), namesB)
+    assertEquals(usedNames("C"), namesC)
+    assertEquals(usedNames("D"), namesD)
+  }
+
+  // See source-dependencies/types-in-used-names-a for an example where
+  // this is required.
+  @Test
+  def `Used names extraction should extract names in the types of trees`(): Unit = {
+    val src1 =
+      """|class X0
+         |class X1 extends X0
+         |class Y
+         |class A {
+         |  type T >: X1 <: X0
+         |}
+         |class M
+         |class N
+         |class P0
+         |class P1 extends P0
+         |object B {
+         |  type S = Y
+         |  val lista: List[A] = ???
+         |  val at: A#T = ???
+         |  val as: S = ???
+         |  def foo(m: M): N = ???
+         |  def bar[Param >: P1 <: P0](p: Param): Param = ???
+         |}""".stripMargin
+    val src2 =
+      """|object Test_lista {
+         |  val x = B.lista
+         |}
+         |object Test_at {
+         |  val x = B.at
+         |}
+         |object Test_as {
+         |  val x = B.as
+         |}
+         |object Test_foo {
+         |  val x = B.foo(???)
+         |}
+         |object Test_bar {
+         |  val x = B.bar(???)
+         |}
+         |""".stripMargin
+    val usedNames = extractUsedNamesFromSrc(src1, src2)
+    val expectedNames_lista = standardNames ++ Set("Test_lista", "x", "B", "lista", "List", "A")
+    val expectedNames_at = standardNames ++ Set("Test_at", "x", "B", "at", "A", "T", "X0", "X1")
+    val expectedNames_as = standardNames ++ Set("Test_as", "x", "B", "as", "S", "Y")
+    val expectedNames_foo = standardNames ++ Set(
+      "Test_foo",
+      "x",
+      "B",
+      "foo",
+      "M",
+      "N",
+      "Predef",
+      "???",
+      "Nothing"
+    )
+    val expectedNames_bar = standardNames ++ Set(
+      "Test_bar",
+      "x",
+      "B",
+      "bar",
+      "Param",
+      "P1",
+      "P0",
+      "Predef",
+      "???",
+      "Nothing"
+    )
+    assertEquals(usedNames("Test_lista"), expectedNames_lista)
+    assertEquals(usedNames("Test_at"), expectedNames_at)
+    assertEquals(usedNames("Test_as"), expectedNames_as)
+    assertEquals(usedNames("Test_foo"), expectedNames_foo)
+    assertEquals(usedNames("Test_bar"), expectedNames_bar)
+  }
+
+  @Test
+  def `Used names extraction should extract used names from an existential`(): Unit = {
+    val srcFoo =
+      """import scala.language.existentials
+        |class Foo {
+        |  val foo: T forSome { type T <: Double } = ???
+        |}
+    """.stripMargin
+    val usedNames = extractUsedNamesFromSrc(srcFoo)
+    val expectedNames = standardNames ++ Seq(
+      "Double",
+      "Foo",
+      "T",
+      "foo",
+      "scala",
+      "language",
+      "existentials",
+      "Nothing",
+      "???",
+      "Predef"
+    )
+    assertEquals(usedNames("Foo"), expectedNames)
+  }
+
+  @Test
+  def `Used names extraction should extract used names from a refinement`(): Unit = {
+    val srcFoo =
+      "object Outer {\n  class Inner { type Xyz }\n\n  type TypeInner = Inner { type Xyz = Int }\n}"
+    val srcBar = "object Bar {\n  def bar: Outer.TypeInner = null\n}"
+    val usedNames = extractUsedNamesFromSrc(srcFoo, srcBar)
+    val expectedNames = standardNames ++ Set("Bar", "Outer", "TypeInner", "Inner", "Xyz", "Int")
+    assertEquals(usedNames("Bar"), expectedNames)
+  }
+
+  // test for https://github.com/gkossakowski/sbt/issues/3
+  @Test
+  def `Used names extraction should extract used names from the same compilation unit`(): Unit = {
+    val src = "class A { def foo: Int = 0; def bar: Int = foo }"
+    val usedNames = extractUsedNamesFromSrc(src)
+    val expectedNames = standardNames ++ Set("A", "foo", "Int")
+    assertEquals(usedNames("A"), expectedNames)
+  }
+
+  // pending test for https://issues.scala-lang.org/browse/SI-7173
+  @Test @Ignore
+  def `Used names extraction should extract names of constants`(): Unit = {
+    val src = "class A { final val foo = 12; def bar: Int = foo }"
+    val usedNames = extractUsedNamesFromSrc(src)
+    val expectedNames = standardNames ++ Set("A", "foo", "Int")
+    assertEquals(usedNames, expectedNames)
+    ()
+  }
+
+  // test for https://github.com/gkossakowski/sbt/issues/4
+  // TODO: we should fix it by having special treatment of `selectDynamic` and `applyDynamic` calls
+  @Test @Ignore
+  def `Used names extraction should extract names from method calls on Dynamic`(): Unit = {
+    val srcA =
+      """|import scala.language.dynamics
+         |class A extends Dynamic {
+         | def selectDynamic(name: String): Int = name.length
+         |}""".stripMargin
+    val srcB = "class B { def foo(a: A): Int = a.bla }"
+    val usedNames = extractUsedNamesFromSrc(srcA, srcB)
+    val expectedNames = standardNames ++ Set("B", "A", "a", "Int", "selectDynamic", "bla")
+    assertEquals(usedNames, expectedNames)
+    ()
+  }
+
+  @Test @Ignore
+  def `Used names extraction should correctly find Out0 (not stored in inspected trees) both in TuplerInstances and TuplerInstances.<refinement>`(): Unit = {
+    val src =
+      """|sealed trait HList extends Product with Serializable
+         |trait DepFn1[T] {
+         |  type Out
+         |  def apply(t: T): Out
+         |}
+         |trait Tupler[L <: HList] extends DepFn1[L] with Serializable
+         |trait TuplerInstances {
+         |  type Aux[L <: HList, Out0] = Tupler[L] { type Out = Out0 }
+         |}""".stripMargin
+    val usedNames = extractUsedNamesFromSrc(src)
+    val expectedNamesForTuplerInstances =
+      Set("Tupler", "AnyRef", "L", "Out0", "scala", "HList", "Object")
+    val expectedNamesForTuplerInstancesRefinement = Set("Out0")
+    assertEquals(usedNames("TuplerInstances"), expectedNamesForTuplerInstances)
+    assertEquals(usedNames("TuplerInstances.<refinement>"), expectedNamesForTuplerInstancesRefinement)
+  }
+
+
+  /**
+   * Standard names that appear in every compilation unit that has any class
+   * definition.
+   */
+  private val standardNames = Set(
+    "scala",
+    // The default parent of a class is "AnyRef" which is an alias for "Object"
+    "AnyRef",
+    "Object",
+    "java;lang;Object;init;"
+  )
+}
diff --git a/test/junit/scala/tools/xsbt/InteractiveConsoleInterfaceTest.scala b/test/junit/scala/tools/xsbt/InteractiveConsoleInterfaceTest.scala
new file mode 100644
index 0000000000..7d13391f59
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/InteractiveConsoleInterfaceTest.scala
@@ -0,0 +1,64 @@
+package scala.tools.xsbt
+
+import org.junit.Test
+import xsbti.InteractiveConsoleResult
+
+class InteractiveConsoleInterfaceTest extends BridgeTesting {
+
+  @Test
+  def `Scala interpreter should evaluate arithmetic expression`(): Unit = {
+    withInteractiveConsole { repl =>
+      val response = repl.interpret("1+1", false)
+      assert(response.output.trim == "val res0: Int = 2")
+      assert(response.result == InteractiveConsoleResult.Success)
+    }
+  }
+
+  @Test
+  def `it should evaluate list constructor`(): Unit = {
+    withInteractiveConsole { repl =>
+      val response = repl.interpret("List(1,2)", false)
+      assert(response.output.trim == "val res0: List[Int] = List(1, 2)")
+      assert(response.result == InteractiveConsoleResult.Success)
+    }
+  }
+
+  @Test
+  def `it should evaluate import`(): Unit = {
+    withInteractiveConsole { repl =>
+      val response = repl.interpret("import scala.collection.mutable._", false)
+      assert(response.output.trim == "import scala.collection.mutable._")
+      assert(response.result == InteractiveConsoleResult.Success)
+    }
+  }
+
+  @Test
+  def `it should mark partial expression as incomplete`(): Unit = {
+    withInteractiveConsole { repl =>
+      val response = repl.interpret("val a =", false)
+      assert(response.result == InteractiveConsoleResult.Incomplete)
+    }
+  }
+
+  @Test
+  def `it should not evaluate incorrect expression`(): Unit = {
+    withInteractiveConsole { repl =>
+      val response = repl.interpret("1 ++ 1", false)
+      assert(response.result == InteractiveConsoleResult.Error)
+    }
+  }
+
+  val postfixOpExpression = "import scala.concurrent.duration._\nval t = 1 second"
+
+  @Test
+  def `it should evaluate postfix op without warning when -language:postfixOps arg passed`(): Unit = withTemporaryDirectory { tempDir =>
+    val repl = interactiveConsole(tempDir.toPath)("-language:postfixOps")
+    try {
+      val response = repl.interpret(postfixOpExpression, false)
+      assert(!response.output.trim.startsWith("warning"))
+      assert(response.result == InteractiveConsoleResult.Success)
+    } finally {
+      repl.close()
+    }
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/SameAPI.scala b/test/junit/scala/tools/xsbt/SameAPI.scala
new file mode 100644
index 0000000000..b716de9266
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/SameAPI.scala
@@ -0,0 +1,398 @@
+package scala.tools.xsbt
+
+import xsbti.api._
+
+import Function.tupled
+import scala.annotation.tailrec
+import scala.collection.{ immutable, mutable }
+
+/** Checks the API of two source files for equality.*/
+object SameAPI {
+  def apply(a: AnalyzedClass, b: AnalyzedClass): Boolean =
+    a.apiHash == b.apiHash
+
+  def hasSameExtraHash(a: AnalyzedClass, b: AnalyzedClass): Boolean =
+    a.extraHash() == b.extraHash()
+
+  def apply(a: Definition, b: Definition): Boolean =
+    new SameAPI(false, true).sameDefinitions(List(a), List(b), topLevel = true)
+
+  def apply(a: Companions, b: Companions): Boolean = {
+    val sameClasses = apply(a.classApi, b.classApi)
+    val sameObjects = apply(a.objectApi, b.objectApi)
+    sameClasses && sameObjects
+  }
+
+  def apply(a: ClassLike, b: ClassLike): Boolean = new SameAPI(false, true).check(a, b)
+
+  def separateDefinitions(s: Seq[Definition]): (Seq[Definition], Seq[Definition]) =
+    s.partition(isValueDefinition)
+  def isValueDefinition(d: Definition): Boolean =
+    d match {
+      case _: FieldLike | _: Def => true
+      case c: ClassLikeDef       => isValue(c.definitionType)
+      case _                     => false
+    }
+  def isValue(d: DefinitionType): Boolean =
+    d == DefinitionType.Module || d == DefinitionType.PackageModule
+
+  /** Puts the given definitions in a map according to their names.*/
+  def byName(s: Seq[Definition]): Map[String, List[Definition]] = {
+    var map = Map[String, List[Definition]]()
+    for (d <- s; name = d.name)
+      map = map.updated(name, d :: map.getOrElse(name, Nil))
+    map
+  }
+
+  /**
+   * Removes definitions that should not be considered for API equality.
+   * All top-level definitions are always considered: 'private' only means package-private.
+   * Other definitions are considered if they are not qualified with 'private[this]' or 'private'.
+   */
+  def filterDefinitions(ds: Seq[Definition], topLevel: Boolean, includePrivate: Boolean) =
+    if (topLevel || includePrivate) ds else ds.filter(!_.access().isInstanceOf[Private])
+
+}
+
+/**
+ * Used to implement API equality.
+ *
+ * If `includePrivate` is true, `private` and `private[this]` members are included in the comparison.  Otherwise, those members are excluded.
+ */
+class SameAPI(includePrivate: Boolean, includeParamNames: Boolean) {
+  import SameAPI._
+
+  private val pending = new mutable.HashSet[AnyRef]
+  private[this] val debugEnabled = java.lang.Boolean.getBoolean("xsbt.api.debug")
+  def debug(flag: Boolean, msg: => String): Boolean = {
+    if (debugEnabled && !flag) println(msg)
+    flag
+  }
+
+  /** Returns true if source `a` has the same API as source `b`.*/
+  def check(a: ClassLike, b: ClassLike): Boolean = {
+    debug(a.name == b.name, "Class names differed") &&
+      debug(sameDefinitionContent(a, b), "Classes differed")
+  }
+
+  def sameTopLevel(a: ClassLike, b: ClassLike): Boolean =
+    a.topLevel == b.topLevel
+
+  def sameDefinitions(a: Seq[Definition], b: Seq[Definition], topLevel: Boolean): Boolean = {
+    val (avalues, atypes) = separateDefinitions(filterDefinitions(a, topLevel, includePrivate))
+    val (bvalues, btypes) = separateDefinitions(filterDefinitions(b, topLevel, includePrivate))
+    debug(sameDefinitions(byName(avalues), byName(bvalues)), "Value definitions differed") &&
+      debug(sameDefinitions(byName(atypes), byName(btypes)), "Type definitions differed")
+  }
+  def sameDefinitions(
+                       a: scala.collection.Map[String, List[Definition]],
+                       b: scala.collection.Map[String, List[Definition]]
+                     ): Boolean =
+    debug(
+      sameStrings(a.keySet, b.keySet),
+      "\tDefinition strings differed (a: " + (a.keySet.toSet -- b.keySet) + ", b: " + (b.keySet.toSet -- a.keySet) + ")"
+    ) &&
+      zippedEntries(a, b).forall(tupled(sameNamedDefinitions))
+
+  /**
+   * Checks that the definitions in `a` are the same as those in `b`, ignoring order.
+   * Each list is assumed to have already been checked to have the same names (by `sameDefinitions`, for example).
+   */
+  def sameNamedDefinitions(a: List[Definition], b: List[Definition]): Boolean = {
+    def sameDefs(a: List[Definition], b: List[Definition]): Boolean = {
+      a match {
+        case adef :: atail =>
+          @tailrec
+          def sameDef(seen: List[Definition], remaining: List[Definition]): Boolean =
+            remaining match {
+              case Nil => debug(flag = false, "Definition different in new API: \n" + adef.name)
+              case bdef :: btail =>
+                val eq = sameDefinitionContent(adef, bdef)
+                if (eq) sameDefs(atail, seen ::: btail) else sameDef(bdef :: seen, btail)
+            }
+          sameDef(Nil, b)
+        case Nil => true
+      }
+    }
+    debug(
+      a.length == b.length,
+      "\t\tLength differed for " + a.headOption.map(_.name).getOrElse("empty")
+    ) && sameDefs(a, b)
+  }
+
+  /** Checks that the two definitions are the same, other than their name.*/
+  def sameDefinitionContent(a: Definition, b: Definition): Boolean =
+    samePending(a, b)(sameDefinitionContentDirect)
+  def sameDefinitionContentDirect(a: Definition, b: Definition): Boolean = {
+    // a.name == b.name &&
+    debug(sameAccess(a.access, b.access), "Access differed") &&
+      debug(sameModifiers(a.modifiers, b.modifiers), "Modifiers differed") &&
+      debug(sameAnnotations(a.annotations, b.annotations), "Annotations differed") &&
+      debug(sameDefinitionSpecificAPI(a, b), "Definition-specific differed")
+  }
+
+  def sameAccess(a: Access, b: Access): Boolean =
+    (a, b) match {
+      case (_: Public, _: Public)         => true
+      case (qa: Protected, qb: Protected) => sameQualifier(qa, qb)
+      case (qa: Private, qb: Private)     => sameQualifier(qa, qb)
+      case _                              => debug(flag = false, "Different access categories")
+    }
+  def sameQualifier(a: Qualified, b: Qualified): Boolean =
+    sameQualifier(a.qualifier, b.qualifier)
+  def sameQualifier(a: Qualifier, b: Qualifier): Boolean =
+    (a, b) match {
+      case (_: Unqualified, _: Unqualified)     => true
+      case (_: ThisQualifier, _: ThisQualifier) => true
+      case (ia: IdQualifier, ib: IdQualifier) =>
+        debug(ia.value == ib.value, "Different qualifiers")
+      case _ =>
+        debug(
+          flag = false,
+          "Different qualifier categories: " + a.getClass.getName + " -- " + b.getClass.getName
+        )
+    }
+
+  def sameModifiers(a: Modifiers, b: Modifiers): Boolean =
+    bitSet(a) == bitSet(b)
+
+  def bitSet(m: Modifiers): immutable.BitSet = {
+    import m._
+    val modifiers =
+      List(isAbstract, isOverride, isFinal, isSealed, isImplicit, isLazy, isMacro).zipWithIndex
+    (modifiers foldLeft immutable.BitSet.empty) { case (bs, (mod, i)) => if (mod) bs + i else bs }
+  }
+  def setIf(bs: mutable.BitSet, flag: Boolean, i: Int): Unit = {
+    if (flag) bs += i
+    ()
+  }
+
+  def sameAnnotations(a: Array[Annotation], b: Array[Annotation]): Boolean =
+    sameAnnotations(a.toIndexedSeq, b.toIndexedSeq)
+  def sameAnnotations(a: Seq[Annotation], b: Seq[Annotation]): Boolean =
+    sameSeq(a, b)(sameAnnotation)
+  def sameAnnotation(a: Annotation, b: Annotation): Boolean =
+    debug(sameType(a.base, b.base), "Annotation base type differed") &&
+      debug(
+        sameAnnotationArguments(a.arguments, b.arguments),
+        "Annotation arguments differed (" + a + ") and (" + b + ")"
+      )
+  def sameAnnotationArguments(a: Array[AnnotationArgument], b: Array[AnnotationArgument]): Boolean =
+    sameAnnotationArguments(a.toIndexedSeq, b.toIndexedSeq)
+  def sameAnnotationArguments(a: Seq[AnnotationArgument], b: Seq[AnnotationArgument]): Boolean =
+    argumentMap(a) == argumentMap(b)
+  def argumentMap(a: Seq[AnnotationArgument]): Map[String, String] =
+    Map() ++ a.map(arg => (arg.name, arg.value))
+
+  def sameDefinitionSpecificAPI(a: Definition, b: Definition): Boolean =
+    (a, b) match {
+      case (fa: FieldLike, fb: FieldLike) => sameFieldSpecificAPI(fa, fb)
+      case (pa: ParameterizedDefinition, pb: ParameterizedDefinition) =>
+        sameParameterizedDefinition(pa, pb)
+      case (ca: ClassLike, cb: ClassLike) => sameClassLikeSpecificAPI(ca, cb)
+      case _                              => false
+    }
+
+  def sameParameterizedDefinition(a: ParameterizedDefinition, b: ParameterizedDefinition): Boolean =
+    debug(
+      sameTypeParameters(a.typeParameters, b.typeParameters),
+      "Different type parameters for " + a.name
+    ) &&
+      sameParameterizedSpecificAPI(a, b)
+
+  def sameParameterizedSpecificAPI(
+                                    a: ParameterizedDefinition,
+                                    b: ParameterizedDefinition
+                                  ): Boolean =
+    (a, b) match {
+      case (da: Def, db: Def)                         => sameDefSpecificAPI(da, db)
+      case (ca: ClassLikeDef, cb: ClassLikeDef)       => sameClassLikeDefSpecificAPI(ca, cb)
+      case (ta: TypeAlias, tb: TypeAlias)             => sameAliasSpecificAPI(ta, tb)
+      case (ta: TypeDeclaration, tb: TypeDeclaration) => sameDeclarationSpecificAPI(ta, tb)
+      case _                                          => false
+    }
+
+  def sameDefSpecificAPI(a: Def, b: Def): Boolean =
+    debug(
+      sameValueParameters(a.valueParameters, b.valueParameters),
+      "Different def value parameters for " + a.name
+    ) &&
+      debug(sameType(a.returnType, b.returnType), "Different def return type for " + a.name)
+  def sameAliasSpecificAPI(a: TypeAlias, b: TypeAlias): Boolean =
+    debug(sameType(a.tpe, b.tpe), "Different alias type for " + a.name)
+  def sameDeclarationSpecificAPI(a: TypeDeclaration, b: TypeDeclaration): Boolean =
+    debug(
+      sameType(a.lowerBound, b.lowerBound),
+      "Different lower bound for declaration " + a.name
+    ) &&
+      debug(sameType(a.upperBound, b.upperBound), "Different upper bound for declaration " + a.name)
+  def sameFieldSpecificAPI(a: FieldLike, b: FieldLike): Boolean =
+    debug(
+      sameFieldCategory(a, b),
+      "Different field categories (" + a.name + "=" + a.getClass.getName + " -- " + a.name + "=" + a.getClass.getName + ")"
+    ) &&
+      debug(sameType(a.tpe, b.tpe), "Different field type for " + a.name)
+
+  def sameFieldCategory(a: FieldLike, b: FieldLike): Boolean =
+    (a, b) match {
+      case (_: Val, _: Val) => true
+      case (_: Var, _: Var) => true
+      case _                => false
+    }
+
+  def sameClassLikeSpecificAPI(a: ClassLike, b: ClassLike): Boolean = {
+    debug(sameTopLevel(a, b), "Top level flag differs") &&
+      sameDefinitionType(a.definitionType, b.definitionType) &&
+      sameType(a.selfType, b.selfType) &&
+      sameSeq(a.childrenOfSealedClass, b.childrenOfSealedClass)(sameType) &&
+      sameStructure(a.structure, b.structure)
+  }
+
+  def sameClassLikeDefSpecificAPI(a: ClassLikeDef, b: ClassLikeDef): Boolean =
+    sameDefinitionType(a.definitionType, b.definitionType)
+
+  def sameValueParameters(a: Array[ParameterList], b: Array[ParameterList]): Boolean =
+    sameValueParameters(a.toIndexedSeq, b.toIndexedSeq)
+  def sameValueParameters(a: Seq[ParameterList], b: Seq[ParameterList]): Boolean =
+    sameSeq(a, b)(sameParameterList)
+
+  def sameParameterList(a: ParameterList, b: ParameterList): Boolean =
+    (a.isImplicit == b.isImplicit) &&
+      sameParameters(a.parameters, b.parameters)
+  def sameParameters(a: Array[MethodParameter], b: Array[MethodParameter]): Boolean =
+    sameParameters(a.toIndexedSeq, b.toIndexedSeq)
+  def sameParameters(a: Seq[MethodParameter], b: Seq[MethodParameter]): Boolean =
+    sameSeq(a, b)(sameMethodParameter)
+  def sameMethodParameter(a: MethodParameter, b: MethodParameter): Boolean =
+    (!includeParamNames || a.name == b.name) &&
+      sameType(a.tpe, b.tpe) &&
+      (a.hasDefault == b.hasDefault) &&
+      sameParameterModifier(a.modifier, b.modifier)
+  def sameParameterModifier(a: ParameterModifier, b: ParameterModifier) =
+    a == b
+  def sameDefinitionType(a: DefinitionType, b: DefinitionType): Boolean =
+    a == b
+  def sameVariance(a: Variance, b: Variance): Boolean =
+    a == b
+
+  def sameTypeParameters(a: Array[TypeParameter], b: Array[TypeParameter]): Boolean =
+    sameTypeParameters(a.toIndexedSeq, b.toIndexedSeq)
+  def sameTypeParameters(a: Seq[TypeParameter], b: Seq[TypeParameter]): Boolean =
+    debug(sameSeq(a, b)(sameTypeParameter), "Different type parameters")
+  def sameTypeParameter(a: TypeParameter, b: TypeParameter): Boolean = {
+    sameTypeParameters(a.typeParameters, b.typeParameters) &&
+      debug(sameAnnotations(a.annotations, b.annotations), "Different type parameter annotations") &&
+      debug(sameVariance(a.variance, b.variance), "Different variance") &&
+      debug(sameType(a.lowerBound, b.lowerBound), "Different lower bound") &&
+      debug(sameType(a.upperBound, b.upperBound), "Different upper bound") &&
+      sameTags(a.id, b.id)
+  }
+  def sameTags(a: String, b: String): Boolean =
+    debug(a == b, "Different type parameter bindings: " + a + ", " + b)
+
+  def sameType(a: Type, b: Type): Boolean =
+    samePending(a, b)(sameTypeDirect)
+  def sameTypeDirect(a: Type, b: Type): Boolean = {
+    (a, b) match {
+      case (pa: Projection, pb: Projection) =>
+        debug(sameProjection(pa, pb), "Different projection")
+      case (pa: ParameterRef, pb: ParameterRef) =>
+        debug(sameParameterRef(pa, pb), "Different parameter ref")
+      case (pa: Polymorphic, pb: Polymorphic) =>
+        debug(samePolymorphicType(pa, pb), "Different polymorphic type")
+      case (pa: Parameterized, pb: Parameterized) =>
+        debug(sameParameterized(pa, pb), "Different parameterized")
+      case (sa: Singleton, sb: Singleton) => debug(sameSingleton(sa, sb), "Different singleton")
+      case (ca: Constant, cb: Constant) =>
+        debug(
+          sameConstantType(ca, cb),
+          "Different constant types: " + ca + " and " + cb
+        )
+      case (aa: Annotated, ab: Annotated) =>
+        debug(sameAnnotatedType(aa, ab), "Different annotated types")
+      case (sa: Structure, sb: Structure) =>
+        debug(sameStructureDirect(sa, sb), "Different structure type")
+      case (ea: Existential, eb: Existential) =>
+        debug(sameExistentialType(ea, eb), "Different existential type")
+      case (_: EmptyType, _: EmptyType) => true
+      case _                            => differentCategory("type", a, b)
+    }
+  }
+
+  def sameConstantType(ca: Constant, cb: Constant): Boolean =
+    sameType(ca.baseType, cb.baseType) &&
+      ca.value == cb.value
+  def sameExistentialType(a: Existential, b: Existential): Boolean =
+    sameTypeParameters(a.clause, b.clause) &&
+      sameType(a.baseType, b.baseType)
+  def samePolymorphicType(a: Polymorphic, b: Polymorphic): Boolean =
+    sameTypeParameters(a.parameters, b.parameters) &&
+      sameType(a.baseType, b.baseType)
+  def sameAnnotatedType(a: Annotated, b: Annotated): Boolean =
+    sameType(a.baseType, b.baseType) &&
+      sameAnnotations(a.annotations, b.annotations)
+  def sameStructure(a: Structure, b: Structure): Boolean =
+    samePending(a, b)(sameStructureDirect)
+
+  private[this] def samePending[T](a: T, b: T)(f: (T, T) => Boolean): Boolean =
+    if (pending add ((a, b))) f(a, b) else true
+
+  def sameStructureDirect(a: Structure, b: Structure): Boolean = {
+    sameSeq(a.parents, b.parents)(sameType) &&
+      sameMembers(a.declared, b.declared) &&
+      sameMembers(a.inherited, b.inherited)
+  }
+
+  def sameMembers[D <: Definition](a: Array[D], b: Array[D]): Boolean =
+    sameMembers(a.toIndexedSeq, b.toIndexedSeq)
+  def sameMembers(a: Seq[Definition], b: Seq[Definition]): Boolean =
+    sameDefinitions(a, b, topLevel = false)
+
+  def differentCategory(label: String, a: AnyRef, b: AnyRef): Boolean =
+    debug(
+      flag = false,
+      "Different category of " + label + " (" + a.getClass.getName + " and " + b.getClass.getName + ") for (" + a + " and " + b + ")"
+    )
+
+  def sameParameterized(a: Parameterized, b: Parameterized): Boolean =
+    sameType(a.baseType, b.baseType) &&
+      sameSeq(a.typeArguments, b.typeArguments)(sameType)
+  def sameParameterRef(a: ParameterRef, b: ParameterRef): Boolean = sameTags(a.id, b.id)
+  def sameSingleton(a: Singleton, b: Singleton): Boolean =
+    samePath(a.path, b.path)
+  def sameProjection(a: Projection, b: Projection): Boolean =
+    sameType(a.prefix, b.prefix) &&
+      (a.id == b.id)
+
+  def samePath(a: Path, b: Path): Boolean =
+    samePathComponents(a.components, b.components)
+  def samePathComponents(a: Array[PathComponent], b: Array[PathComponent]): Boolean =
+    samePathComponents(a.toIndexedSeq, b.toIndexedSeq)
+  def samePathComponents(a: Seq[PathComponent], b: Seq[PathComponent]): Boolean =
+    sameSeq(a, b)(samePathComponent)
+  def samePathComponent(a: PathComponent, b: PathComponent): Boolean =
+    (a, b) match {
+      case (_: This, _: This)     => true
+      case (sa: Super, sb: Super) => samePathSuper(sa, sb)
+      case (ia: Id, ib: Id)       => samePathId(ia, ib)
+      case _                      => false
+    }
+  def samePathSuper(a: Super, b: Super): Boolean =
+    samePath(a.qualifier, b.qualifier)
+  def samePathId(a: Id, b: Id): Boolean =
+    a.id == b.id
+
+  // precondition: a.keySet == b.keySet
+  protected def zippedEntries[A, B](
+                                     a: scala.collection.Map[A, B],
+                                     b: scala.collection.Map[A, B]
+                                   ): Iterable[(B, B)] =
+    for ((key, avalue) <- a) yield (avalue, b(key))
+
+  def sameStrings(a: scala.collection.Set[String], b: scala.collection.Set[String]): Boolean =
+    a == b
+  final def sameSeq[T](a: Array[T], b: Array[T])(eq: (T, T) => Boolean): Boolean =
+    sameSeq(a.toIndexedSeq, b.toIndexedSeq)(eq)
+  final def sameSeq[T](a: Seq[T], b: Seq[T])(eq: (T, T) => Boolean): Boolean =
+    (a.length == b.length) && (a zip b).forall(tupled(eq))
+}
diff --git a/test/junit/scala/tools/xsbt/TestCallback.scala b/test/junit/scala/tools/xsbt/TestCallback.scala
new file mode 100644
index 0000000000..4a33ab1583
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/TestCallback.scala
@@ -0,0 +1,183 @@
+package scala.tools.xsbt
+
+import xsbti.api.{ClassLike, DependencyContext}
+import xsbti.{Action, AnalysisCallback2, DiagnosticCode, DiagnosticRelatedInformation, Position, Severity, UseScope, VirtualFile, VirtualFileRef}
+
+import java.io.File
+import java.nio.file.Path
+import java.util
+import java.util.Optional
+import scala.collection.mutable.ArrayBuffer
+
+class TestCallback extends AnalysisCallback2 {
+  case class TestUsedName(name: String, scopes: util.EnumSet[UseScope])
+
+  val classDependencies = new ArrayBuffer[(String, String, DependencyContext)]
+  val binaryDependencies =
+    new ArrayBuffer[(Path, String, String, DependencyContext)]
+  val productClassesToSources =
+    scala.collection.mutable.Map.empty[Path, VirtualFileRef]
+  val usedNamesAndScopes =
+    scala.collection.mutable.Map.empty[String, Set[TestUsedName]].withDefaultValue(Set.empty)
+  val classNames =
+    scala.collection.mutable.Map
+      .empty[VirtualFileRef, Set[(String, String)]]
+      .withDefaultValue(Set.empty)
+  val apis: scala.collection.mutable.Map[VirtualFileRef, Set[ClassLike]] =
+    scala.collection.mutable.Map.empty
+
+  def usedNames = usedNamesAndScopes.view.mapValues(_.map(_.name)).toMap
+
+  override def startSource(source: File): Unit = ???
+  override def startSource(source: VirtualFile): Unit = {
+    assert(
+      !apis.contains(source),
+      s"The startSource can be called only once per source file: $source"
+    )
+    apis(source) = Set.empty
+  }
+
+  def classDependency(
+                       onClassName: String,
+                       sourceClassName: String,
+                       context: DependencyContext
+                     ): Unit = {
+    if (onClassName != sourceClassName)
+      classDependencies += ((onClassName, sourceClassName, context))
+    ()
+  }
+
+  override def binaryDependency(
+                                 classFile: File,
+                                 onBinaryClassName: String,
+                                 fromClassName: String,
+                                 fromSourceFile: File,
+                                 context: DependencyContext
+                               ): Unit = ???
+
+  override def binaryDependency(
+                                 onBinary: Path,
+                                 onBinaryClassName: String,
+                                 fromClassName: String,
+                                 fromSourceFile: VirtualFileRef,
+                                 context: DependencyContext
+                               ): Unit = {
+    binaryDependencies += ((onBinary, onBinaryClassName, fromClassName, context))
+    ()
+  }
+
+  override def generatedNonLocalClass(
+                                       sourceFile: File,
+                                       classFile: File,
+                                       binaryClassName: String,
+                                       srcClassName: String
+                                     ): Unit = ???
+
+  override def generatedNonLocalClass(
+                                       sourceFile: VirtualFileRef,
+                                       classFile: Path,
+                                       binaryClassName: String,
+                                       srcClassName: String
+                                     ): Unit = {
+    productClassesToSources += ((classFile, sourceFile))
+    classNames(sourceFile) += ((srcClassName, binaryClassName))
+    ()
+  }
+
+  override def generatedLocalClass(
+                                    sourceFile: File,
+                                    classFile: File
+                                  ): Unit = ???
+
+  override def generatedLocalClass(
+                                    sourceFile: VirtualFileRef,
+                                    classFile: Path
+                                  ): Unit = {
+    productClassesToSources += ((classFile, sourceFile))
+    ()
+  }
+
+  def usedName(className: String, name: String, scopes: util.EnumSet[UseScope]): Unit =
+    usedNamesAndScopes(className) += TestUsedName(name, scopes)
+
+  override def api(source: File, api: ClassLike): Unit = ???
+
+  override def api(source: VirtualFileRef, api: ClassLike): Unit = {
+    apis(source) += api
+    ()
+  }
+
+  override def mainClass(source: File, className: String): Unit = ()
+
+  override def mainClass(source: VirtualFileRef, className: String): Unit = ()
+
+  override def enabled(): Boolean = true
+
+  def problem(
+               category: String,
+               pos: xsbti.Position,
+               message: String,
+               severity: xsbti.Severity,
+               reported: Boolean
+             ): Unit = ()
+
+  override def problem2(what: String,
+                        pos: Position,
+                        msg: String,
+                        severity: Severity,
+                        reported: Boolean,
+                        rendered: Optional[String],
+                        diagnosticCode: Optional[DiagnosticCode],
+                        diagnosticRelatedInformation: util.List[DiagnosticRelatedInformation],
+                        actions: util.List[Action]): Unit = ()
+
+  override def dependencyPhaseCompleted(): Unit = {}
+
+  override def apiPhaseCompleted(): Unit = {}
+
+  override def classesInOutputJar(): util.Set[String] = java.util.Collections.emptySet()
+
+  override def isPickleJava: Boolean = false
+
+  override def getPickleJarPair = Optional.empty()
+}
+
+object TestCallback {
+  case class ExtractedClassDependencies(
+                                         memberRef: Map[String, Set[String]],
+                                         inheritance: Map[String, Set[String]],
+                                         localInheritance: Map[String, Set[String]]
+                                       )
+  object ExtractedClassDependencies {
+    def fromPairs(
+                   memberRefPairs: Seq[(String, String)],
+                   inheritancePairs: Seq[(String, String)],
+                   localInheritancePairs: Seq[(String, String)]
+                 ): ExtractedClassDependencies = {
+      ExtractedClassDependencies(
+        pairsToMultiMap(memberRefPairs),
+        pairsToMultiMap(inheritancePairs),
+        pairsToMultiMap(localInheritancePairs)
+      )
+    }
+
+    private def pairsToMultiMap[A, B](pairs: Seq[(A, B)]): Map[A, Set[B]] = {
+      import scala.collection.{mutable => m}
+      val emptyMultiMap = new m.HashMap[A, m.Set[B]]
+      val multiMap = pairs.foldLeft(emptyMultiMap) {
+        case (acc, (key, value)) => acc.get(key) match {
+          case None =>
+            val s = m.Set.empty[B]
+            s += value
+            acc(key) = s
+            acc
+          case Some(s) =>
+            s += value
+            acc
+        }
+      }
+      // convert all collections to immutable variants
+      multiMap.toMap.view.mapValues(_.toSet).toMap.withDefaultValue(Set.empty)
+    }
+  }
+}
diff --git a/test/junit/scala/tools/xsbt/package.scala b/test/junit/scala/tools/xsbt/package.scala
new file mode 100644
index 0000000000..00d2a24662
--- /dev/null
+++ b/test/junit/scala/tools/xsbt/package.scala
@@ -0,0 +1,14 @@
+package scala.tools
+
+import java.io.File
+import java.nio.file.Path
+
+package object xsbt {
+  import scala.language.implicitConversions
+
+  implicit class PathOps(private val path: Path) extends AnyVal {
+    def / (sub: String) = path.resolve(sub)
+  }
+
+  implicit def pathToFile(path: Path): File = path.toFile
+}
diff --git a/test/scaladoc/resources/`t12846`.scala b/test/scaladoc/resources/`t12846`.scala
new file mode 100644
index 0000000000..aa18b34fba
--- /dev/null
+++ b/test/scaladoc/resources/`t12846`.scala
@@ -0,0 +1,7 @@
+
+package example
+
+/** There is nothing extraordinary about this code,
+ *  but the file name includes backticks, which must be encoded in a URI.
+ */
+final case class `X-Upload-Content-Type` private (contentType: String)
diff --git a/test/scaladoc/run/diagrams-base.check b/test/scaladoc/run/diagrams-base.check
index ec9c6d6a74..31db4f1900 100644
--- a/test/scaladoc/run/diagrams-base.check
+++ b/test/scaladoc/run/diagrams-base.check
@@ -1,10 +1,10 @@
-newSource:10: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.T)
+newSource:10: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.T) [quickfixable]
       object E { implicit def eToT(e: E) = new T }
                               ^
-newSource:18: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.E)
+newSource:18: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.E) [quickfixable]
       object X { implicit def xToE(x: X) = new E}
                               ^
-newSource:21: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.E)
+newSource:21: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.E) [quickfixable]
       object Z { implicit def zToE(z: Z) = new E}
                               ^
 Done.
diff --git a/test/scaladoc/run/diagrams-filtering.check b/test/scaladoc/run/diagrams-filtering.check
index 6f40b2c327..fcd4067f9b 100644
--- a/test/scaladoc/run/diagrams-filtering.check
+++ b/test/scaladoc/run/diagrams-filtering.check
@@ -1,7 +1,7 @@
-newSource:30: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.T)
+newSource:30: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.T) [quickfixable]
             implicit def eToT(e: E) = new T
                          ^
-newSource:31: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.A)
+newSource:31: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.diagrams.A) [quickfixable]
             implicit def eToA(e: E) = new A { }
                          ^
 Done.
diff --git a/test/scaladoc/run/implicits-ambiguating.check b/test/scaladoc/run/implicits-ambiguating.check
index f716066eb1..ecb3e58679 100644
--- a/test/scaladoc/run/implicits-ambiguating.check
+++ b/test/scaladoc/run/implicits-ambiguating.check
@@ -1,7 +1,7 @@
-newSource:70: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.ambiguating.X[T])
+newSource:70: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.ambiguating.X[T]) [quickfixable]
   implicit def AtoX[T](a: A[T]) = new X[T]
                ^
-newSource:71: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.ambiguating.Z[T])
+newSource:71: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.ambiguating.Z[T]) [quickfixable]
   implicit def AtoZ[T](a: A[T]) = new Z[T]
                ^
 Done.
diff --git a/test/scaladoc/run/implicits-base.check b/test/scaladoc/run/implicits-base.check
index e5f9afca6e..c5cfe5299b 100644
--- a/test/scaladoc/run/implicits-base.check
+++ b/test/scaladoc/run/implicits-base.check
@@ -1,19 +1,19 @@
-newSource:36: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.EnrichedA[V])
+newSource:36: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.EnrichedA[V]) [quickfixable]
   implicit def enrichA0[V](a: A[V]) = new EnrichedA(a)
                ^
-newSource:37: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.NumericA[ZBUR])
+newSource:37: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.NumericA[ZBUR]) [quickfixable]
   implicit def enrichA1[ZBUR: Numeric](a: A[ZBUR]) = new NumericA[ZBUR](a)
                ^
-newSource:38: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.IntA)
+newSource:38: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.IntA) [quickfixable]
   implicit def enrichA2(a: A[Int]) = new IntA(a)
                ^
-newSource:39: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.GtColonDoubleA)
+newSource:39: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.GtColonDoubleA) [quickfixable]
   implicit def enrichA3(a: A[T] forSome { type T <: Double }) = new GtColonDoubleA(a)
                ^
-newSource:42: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.MyNumericA[Z])
+newSource:42: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.MyNumericA[Z]) [quickfixable]
   implicit def enrichA6[Z: MyNumeric](a: A[Z]) = new MyNumericA[Z](a)
                ^
-newSource:44: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.ManifestA[H] with scala.test.scaladoc.implicits.base.MyTraversableOps[H])
+newSource:44: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.base.ManifestA[H] with scala.test.scaladoc.implicits.base.MyTraversableOps[H]) [quickfixable]
   implicit def enrichA7[H <: Double : Manifest](a: A[H]) = new ManifestA[H](a) with MyTraversableOps[H] { def convToTraversableOps(x: H): H = sys.error("no") }
                ^
 Done.
diff --git a/test/scaladoc/run/implicits-chaining.check b/test/scaladoc/run/implicits-chaining.check
index 9cbfe46b4a..67603c5228 100644
--- a/test/scaladoc/run/implicits-chaining.check
+++ b/test/scaladoc/run/implicits-chaining.check
@@ -1,16 +1,16 @@
-newSource:22: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit1[T])
+newSource:22: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit1[T]) [quickfixable]
     implicit def implicit1[T <: Intermediate[_, _]](implicit b: Implicit2[T])                = new Implicit1[T](b)
                  ^
-newSource:24: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit2[T])
+newSource:24: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit2[T]) [quickfixable]
     implicit def implicit2alt1[T <: Intermediate[_ <: String, _]](implicit c: Implicit3[T])  = new Implicit2[T](c)
                  ^
-newSource:25: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit2[T])
+newSource:25: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit2[T]) [quickfixable]
     implicit def implicit2alt2[T <: Intermediate[_ <: Double, _]](implicit c: Implicit3[T])  = new Implicit2[T](c)
                  ^
-newSource:27: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit3[T])
+newSource:27: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit3[T]) [quickfixable]
     implicit def implicit3alt1[T <: Intermediate[_, _ <: Int]]                               = new Implicit3[T]()
                  ^
-newSource:28: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit3[T])
+newSource:28: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.Implicit3[T]) [quickfixable]
     implicit def implicit3alt2[T <: Intermediate[_ <: Double, _ <: AnyRef],X]                = new Implicit3[T]()
                  ^
 Done.
diff --git a/test/scaladoc/run/implicits-known-type-classes.check b/test/scaladoc/run/implicits-known-type-classes.check
index 225b60e6cf..ee58da5e5f 100644
--- a/test/scaladoc/run/implicits-known-type-classes.check
+++ b/test/scaladoc/run/implicits-known-type-classes.check
@@ -1,49 +1,49 @@
-newSource:13: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Numeric[T]])
+newSource:13: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Numeric[T]]) [quickfixable]
     implicit def convertNumeric       [T: Numeric]       (a: A[T]) = new B(implicitly[Numeric[T]])
                  ^
-newSource:14: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Integral[T]])
+newSource:14: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Integral[T]]) [quickfixable]
     implicit def convertIntegral      [T: Integral]      (a: A[T]) = new B(implicitly[Integral[T]])
                  ^
-newSource:15: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Fractional[T]])
+newSource:15: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Fractional[T]]) [quickfixable]
     implicit def convertFractional    [T: Fractional]    (a: A[T]) = new B(implicitly[Fractional[T]])
                  ^
-newSource:16: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Manifest[T]])
+newSource:16: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[Manifest[T]]) [quickfixable]
     implicit def convertManifest      [T: Manifest]      (a: A[T]) = new B(implicitly[Manifest[T]])
                  ^
-newSource:17: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[reflect.ClassManifest[T]])
+newSource:17: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[reflect.ClassManifest[T]]) [quickfixable]
     implicit def convertClassManifest [T: ClassManifest] (a: A[T]) = new B(implicitly[ClassManifest[T]])
                  ^
-newSource:18: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[OptManifest[T]])
+newSource:18: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[OptManifest[T]]) [quickfixable]
     implicit def convertOptManifest   [T: OptManifest]   (a: A[T]) = new B(implicitly[OptManifest[T]])
                  ^
-newSource:19: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.reflect.ClassTag[T]])
+newSource:19: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.reflect.ClassTag[T]]) [quickfixable]
     implicit def convertClassTag      [T: ClassTag]      (a: A[T]) = new B(implicitly[ClassTag[T]])
                  ^
-newSource:20: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[reflect.runtime.universe.TypeTag[T]])
+newSource:20: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[reflect.runtime.universe.TypeTag[T]]) [quickfixable]
     implicit def convertTypeTag       [T: TypeTag]       (a: A[T]) = new B(implicitly[TypeTag[T]])
                  ^
-newSource:29: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.K[T]])
+newSource:29: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.K[T]]) [quickfixable]
     implicit def convertK [T: K] (a: A[T]) = new B(implicitly[K[T]])
                  ^
-newSource:30: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.L[T]])
+newSource:30: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.L[T]]) [quickfixable]
     implicit def convertL [T: L] (a: A[T]) = new B(implicitly[L[T]])
                  ^
-newSource:31: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.M[T]])
+newSource:31: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.M[T]]) [quickfixable]
     implicit def convertM [T: M] (a: A[T]) = new B(implicitly[M[T]])
                  ^
-newSource:32: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.N[T]])
+newSource:32: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.N[T]]) [quickfixable]
     implicit def convertN [T: N] (a: A[T]) = new B(implicitly[N[T]])
                  ^
-newSource:33: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.O[T]])
+newSource:33: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.O[T]]) [quickfixable]
     implicit def convertO [T: O] (a: A[T]) = new B(implicitly[O[T]])
                  ^
-newSource:34: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.P[T]])
+newSource:34: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.P[T]]) [quickfixable]
     implicit def convertP [T: P] (a: A[T]) = new B(implicitly[P[T]])
                  ^
-newSource:35: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.Q[T]])
+newSource:35: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.Q[T]]) [quickfixable]
     implicit def convertQ [T: Q] (a: A[T]) = new B(implicitly[Q[T]])
                  ^
-newSource:36: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.R[T]])
+newSource:36: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.typeclasses.B[scala.test.scaladoc.implicits.typeclasses.A.R[T]]) [quickfixable]
     implicit def convertR [T: R] (a: A[T]) = new B(implicitly[R[T]])
                  ^
 Done.
diff --git a/test/scaladoc/run/implicits-shadowing.check b/test/scaladoc/run/implicits-shadowing.check
index 59ba86b25c..ec57bb9042 100644
--- a/test/scaladoc/run/implicits-shadowing.check
+++ b/test/scaladoc/run/implicits-shadowing.check
@@ -1,4 +1,4 @@
-newSource:63: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.shadowing.Z[T])
+newSource:63: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.implicits.shadowing.Z[T]) [quickfixable]
   implicit def AtoZ[T](a: A[T]) = new Z[T]
                ^
 Done.
diff --git a/test/scaladoc/run/implicits-var-exp.check b/test/scaladoc/run/implicits-var-exp.check
index 9cc519cab9..d70a3f795c 100644
--- a/test/scaladoc/run/implicits-var-exp.check
+++ b/test/scaladoc/run/implicits-var-exp.check
@@ -1,7 +1,7 @@
-newSource:8: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.variable.expansion.C)
+newSource:8: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.variable.expansion.C) [quickfixable]
             implicit def aToC(a: A) = new C
                          ^
-newSource:9: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.variable.expansion.E with scala.test.scaladoc.variable.expansion.F)
+newSource:9: warning: Implicit definition should have explicit type (inferred scala.test.scaladoc.variable.expansion.E with scala.test.scaladoc.variable.expansion.F) [quickfixable]
             implicit def aToE(a: A) = new E with F
                          ^
 Done.
diff --git a/test/scaladoc/run/t12846.check b/test/scaladoc/run/t12846.check
new file mode 100644
index 0000000000..1b0af7a960
--- /dev/null
+++ b/test/scaladoc/run/t12846.check
@@ -0,0 +1,2 @@
+Some(http://acme.com/source/%60t12846%60.scala#L7)
+Done.
diff --git a/test/scaladoc/run/t12846.scala b/test/scaladoc/run/t12846.scala
new file mode 100644
index 0000000000..0ca2ec6d02
--- /dev/null
+++ b/test/scaladoc/run/t12846.scala
@@ -0,0 +1,21 @@
+
+import scala.tools.nsc.doc.model._
+import scala.tools.partest.ScaladocModelTest
+
+object Test extends ScaladocModelTest {
+
+  override def resourceFile = "`t12846`.scala"
+
+  // resourcePath has the form ../resources in the test, but that's ok for relativizing
+  override def scaladocSettings = s"-Xlint -doc-source-url http://acme.com/source/€{FILE_PATH_EXT}#L€{FILE_LINE} -sourcepath $resourcePath"
+
+  override def code = ???
+
+  def testModel(root: Package) = {
+    import access._
+    println(root._package("example")._class("X-Upload-Content-Type").sourceUrl)
+  }
+
+  // `makeUniverse` takes either file names or source code, so we override to specify file name
+  override def model = newDocFactory.makeUniverse(Left(List(s"$resourcePath/$resourceFile")))
+}
-- 
2.41.0

